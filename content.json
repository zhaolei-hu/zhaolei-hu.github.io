{"pages":[],"posts":[{"title":"CSS3实现元素缺角及缺角的边框","text":"在项目中碰到一个数据可视化的业务，ui画了一些不规则的缺角矩形作为背景，但是又没有提供切图，本着求人不如求己的原则，就尝试拿CSS来画这种缺角的矩形及边框吧。 缺角的实现CSS3中有一个很常用的属性background，但是他的有些取值却不是那么常用，比如说gradient渐变，我们就可以通过渐变来实现缺角。 CSS3中定义了两种类型的渐变： 线性渐变 径向渐变 当然关于渐变的更多内容不在这里过多赘述，我是用到了线形渐变，所以会在后续把用到的线性渐变内容放上去。 线性渐变的语法： 1background-imag: linear-gradient(direction, color-stop1, color-stop2, ....) 关于方向，你可以用top、bottom等指定，也可以给定一个角度值。比如0deg表示从下往上的方向渐变。45deg表示从左下往右上的方向渐变。-45deg表示从右下往左上的方向渐变。 一个切角可能现在大家还不清楚渐变跟缺角有什么关系，那就到代码中来看吧，比如咱们来实现一个右上角的缺角。 12&lt;div class=&quot;rect&quot;&gt;&lt;/div&gt; 12345.rect{ width: 200px; height: 200px; background: linear-gradient(-135deg, transparent 10px, #f00 0);} 效果如下： 我们定义了一个从右上角到左下角的渐变，第一个色标为透明，长度10px，所以从右上角切出了一个角。 第二个色标我们给的是#f00 0，前边的#f00表示颜色，0表示填充剩余部分，所以剩余部分全部填充了红色。 两个切角通过这种方法我们可以实现一个切角，但如果是多个切角呢？ 先说结论，如果是多个切角我们需要使用多块背景色进行拼接来实现，为了方便演示我会使用多种颜色来实现以直观的显示出来背景是多块拼接而成的，实际使用中只要将多块背景色设置为一致就可以了。 现在我们将矩形的左上角和右上角进行切角。 12&lt;div class=&quot;rect&quot;&gt;&lt;/div&gt; 12345678.rect{ width: 200px; height: 200px; background: linear-gradient(-135deg, transparent 10px, #f00 0) right, linear-gradient(135deg, transparent 10px, #0f0 0) left; background-size: 50% 100%; background-repeat: no-repeat; } 效果如下： 首先我们定义了两个线性渐变的背景并为其指定了位置，然后我们对背景的大小进行设置，根据切角的位置呢我们会把矩形左右分开，所以我们设置背景大小的将X设为50%，Y设为100% 四个切角实现四个切角的思想跟实现两个切角是一样的，只是把背景分成了四块而已。 12345678910.rect{ width: 200px; height: 200px; background: linear-gradient(-135deg, transparent 10px, #f00 0) top right, linear-gradient(135deg, transparent 10px, #0f0 0) top left, linear-gradient(45deg, transparent 10px, #00f 0) bottom left, linear-gradient(-45deg, transparent 10px, #0ff 0) bottom right; background-size: 50% 50%; background-repeat: no-repeat; } 效果如下： 思想还是一样的，只是需要注意现在分成了四块，所以我们设置背景大小的时候要把X和Y都设置为50% 现在可能会有小伙伴要问，如果是切三个角怎么办啊，这怎么分，背景大小怎么设置呢？ 答案是：还是按照四个角来切，只是其中一个角不需要使用transparent来做切角效果了。 现在我们看一下切三个角并且将颜色保持一致的效果： 12345678910.rect{ width: 200px; height: 200px; background: linear-gradient(-135deg, transparent 10px, #f00 0) top right, linear-gradient(135deg, transparent 10px, #f00 0) top left, linear-gradient(45deg, transparent 10px, #f00 0) bottom left, linear-gradient(-45deg, #f00 0, #f00 100%) bottom right; background-size: 50% 50%; background-repeat: no-repeat; } 注意！前边的内容应该很简单，大家也都知道使用渐变来切角是通过多块背景色拼接来实现的 但是，这个操作还有但是！ 元素的宽高一定设置为偶数，如果设置为奇数会因为无法均分导致出现大家不想看到的效果 比如： clip-path是的，CSS还有这么一个属性，我前几天的博客写到一个clip-rect的用法，但是那个只能用来切一个矩形，现在这个正如其名，可以根据一条路径来进行切割。 比如我们要切角的元素是一张图片，而不是填充的背景色，这个时候渐变肯定不好用了。 语法： 1clip-path: polygon(x y, x1 y1, x2 y2, x3 y3, ... xn,yn) clip-path的用法比clip-rect更好理解，就是一对坐标点，连起来就是我们要显示的区域了。 clip-path比较灵活，可以自己设置要裁切的坐标点，所以不只是能用来切角，只要创意足够多，可以实现更多有意思的效果。 兼容性不敢保证哦，老版本浏览器可能就翻车了。 缺角边框缺角的效果是两个矩形叠加形成的。 123&lt;div class=&quot;out&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; 保证内部的矩形处于外部矩形的正中央，且宽高为外部矩形的100%，这样就可以通过外部矩形的padding来设置边框的宽度了。 直接看代码： 1234567891011121314.out{ width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; background: linear-gradient(45deg, transparent 10px, #f00 0); padding: 4px;}.inner{ width: 100%; height: 100%; background: linear-gradient(45deg, transparent 10px, #fff 0);} 效果如下： 看网上有大神可以通过linear gradient实现更多有趣的效果，比如： 还有更多好玩的用法就等你自己去挖掘了。 下次碰到这种问题，直接问ui要一个切图可使头发留存率+300%！","link":"/2021/12/17/CSS3%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E7%BC%BA%E8%A7%92%E5%8F%8A%E7%BC%BA%E8%A7%92%E7%9A%84%E8%BE%B9%E6%A1%86/"},{"title":"CSS中height,max-height,min-height的优先级问题","text":"height,max-height,min-height都是CSS中比较常用的属性，但关于他们的优先级却从没有认真考虑过。最开始考虑这个问题源于秋招时百度的一道笔试题，题目为问div的高度是多少？ 123456789101112&lt;style&gt; #app{ height: 1000px; min-height: 500px; max-height: 300px; }&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt;&lt;/body&gt; 这个问题当初并没有回答正确，在考试结束后查阅相关内容并经过实践得出的结论是： max-height这个属性用来设置给定元素的最大高度，会阻止height属性的设置值变得比max-height更大，如果height比max-height更大则height属性会失效。简单说就是height不能比max-height更大。 max-height会覆盖掉height，但是min-height和max-height同时存在的时候又会覆盖到max-height。 实际效果有如下规律： 当height和max-height同时存在，取较小值： max-height &lt; height ——&gt; 高度以max-height为准 max-height &gt; height ——&gt; 高度以height为准 当height和min-height同时存在，取较大值： min-height &lt; height ——&gt; 高度以height为准 min-height &gt; height ——&gt; 高度以min-height为准 当height、min-height和max-height三者同时存在时： height &gt; max-height &gt; min-height —–&gt; 高度以max-height为准 height &gt; min-height &gt; max-height ——&gt; 高度以min-height为准 min-height &gt; height &gt; max-height ——&gt; 高度以min-height为准 综合上述规律，我们可以得知题目的答案为500px。 作为一名前端开发人员，大家要一起努力打好基础呀！","link":"/2021/10/20/CSS%E4%B8%ADheight-max-height-min-height%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/"},{"title":"01背包与完全背包问题","text":"动态规划是刷题过程中的常见算法，有难有易，简单的如斐波那契数列问题很容易找到规律，难一些的就很容易钻牛角尖了，而背包问题又是动态规划的一个典型问题，这里就拿比较典型的01背包与完全背包问题做一下记录。 01背包问题01背包问题题目要求 有N件物品和一个容量为V的背包 第i件物品的体积是Vi，其价值是Wi 每件物品只能使用一次 要求物品体积不超过背包容量且价值最大 理清楚思路就容易理解了。用到了两层for循环，外层是依次循环每个物品，内层是背包容积，依次去计算当前容积下的最大价值，后续的计算可以依赖前边的计算，完成算法。 1234567891011121314151617181920212223242526272829303132/** * @description 0-1背包问题 * @param {number} n 物品数量 * @param {number} v 背包的容积 * @param {number[]} w 物品价值数组,索引为0的物品价值为0 * @param {number[]} c 物品体积数组,索引为0的物品价值为0 */function zeroOneBag(n, v, w, c){ // w和c都是索引为0的值也是0，因为没有第0件物品 // 所以我们生成二维数组的时候也用到了n+1，保证索引对应 // 需要注意的是，不要用这种方式生成二维数组： // let dp = new Array(n+1).fill(new Array(v+1).fill(0)) // 因为数组是引用类型，会导致修改一个其他的也受影响 let dp = [] for(let i = 0; i &lt; n+1; i++){ dp.push(new Array(v+1).fill(0)) } for(let i=1; i&lt;n+1; i++){ for(let j=1; j&lt;v+1; j++){ // 如果容积小于物品体积那么放不进去 if(j &lt; c[i]){ // 当前的最大值就不不放入这个物品的值 dp[i][j] = dp[i-1][j] }else{ // 如果容积大于物品体积，则考虑取较大值： // 1.不放当前物品 || 2.放当前物品+减去当前物品剩余容积的最大价值 dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-c[i]] + w[i]) } } } return dp[n][v]} 但是这样用到了一个二维数组，空间复杂度较高，有没有可能通过一维数组实现呢？ 01背包问题空间复杂度优化 关键点只有一个，容积要逆序循环保证不会重复使用物品 12345678910111213141516171819202122/** * @description 0-1背包问题 * @param {number} n 物品数量 * @param {number} v 背包的容积 * @param {number[]} w 物品价值数组,索引为0的物品价值为0 * @param {number[]} c 物品体积数组,索引为0的物品价值为0 */function zeroOneBag(n, v, w, c){ let dp = new Array(v+1).fill(0) for(let i=1; i&lt;n+1; i++){ // 注意：第二层循环要逆序循环，逆序循环保证每个物品只能用一次 // 如果顺序循环的话，当j&gt;c[i]，去取dp[j-c[i]]的时候可能已经用到了该物品，就会导致该物品被重复使用，不符合01背包要求，所以逆序循环 for(let j=v; j&gt;0; j--){ if(j &gt;= c[i]){ // 每次都比较当前容积下是不拿当前物品的价值更高还是拿了当前物品的价值更高 dp[j] = Math.max(dp[j], dp[j-c[i]]+w[i]) } } } } 完全背包问题01背包问题题目要求 有N件物品和一个容量为V的背包 第i件物品的体积是Vi，其价值是Wi 每件物品可以无限次使用 要求物品体积不超过背包容量且价值最大 01背包与完全背包的区别是，完全背包中每个物品都是可以无限次使用的。 其解法与01背包的一维数组方式也是基本一致的，只需要注意容积是正序循环的，因为可以重复使用物品 123456789101112131415161718192021/** * @description 0-1背包问题 * @param {number} n 物品数量 * @param {number} v 背包的容积 * @param {number[]} w 物品价值数组,索引为0的物品价值为0 * @param {number[]} c 物品体积数组,索引为0的物品价值为0 */function zeroOneBag(n, v, w, c){ let dp = new Array(v+1).fill(0) for(let i=1; i&lt;n+1; i++){ // 与01背包的一维数组解法相似，只是这里可以重复使用物品所以正序循环 for(let j=1; j&lt;v+1; j++){ if(j &gt;= c[i]){ // 对于一个物品，要么不拿为dp[j]，要么拿了为dp[j-c[i]]+w[i] // #而dp[j-c[i]]代表之前的状态，正序循环所以包含拿过物品i的状态 dp[j] = Math.max(dp[j], dp[j-c[i]]+w[i]) } } }} 总结0-1背包二维数组解法：核心计算公式是dp[i][j] = max(dp[i-1][j],dp[i-1][j-c[i]]+w[i]) 参与计算的是dp[i-1]所以每个物品是只用过一次的 0-1背包一维数组解法：核心计算公式是dp[j] = max(dp[j],dp[j-c[i]]+w[i]) 因为是逆序进行的，背包容量从大往小算，刚开始的时候小容积的价值还没有计算当前物品，所以不会重复使用 完全背包：核心计算公式dp[j] = max(dp[j],dp[j-c[i]]+w[i])，与01背包一致。 区别在于正序进行的过程中是可以对同一物品多次使用的。","link":"/2022/08/25/01%E8%83%8C%E5%8C%85%E4%B8%8E%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"title":"ES6语法Proxy的基本使用","text":"最近接触Vue3越来越多，大家都知道Vue3中的ref是使用get和set拦截value实现的，所以用ref定义的数据需要用.value的方式来访问，但是reactive是使用proxy和reflect来实现的，就趁着这个时间把Proxy和Reflect 先看一看，本篇仅限于Proxy，Reflect会单独开一篇笔记。 基本概念Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义 Proxy是一个可构造对象，通过new创建实例。 语法： 1const p = new Proxy(target, handler) 参数： target 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。 Proxy的方法除了直接 new Proxy 对象外，Proxy 构造函数上还有一个静态函数 revocable，可以构造一个能被销毁的代理对象。 与new Proxy创建的代理对象不同，revocable还会返回一个销毁函数： 123456Proxy.revocable( target: Object, handlers: Object ) : ObjectProxy.revocable( target, handlers ) → { proxy: Proxy, // 代理对象 revoke: ƒ () // 销毁函数} 销毁函数不需要任何参数，我们可以随时调用销毁函数将代理对象和目标对象的代理关系断开。断开代理后，再对代理对象执行任何操作都会抛出 TypeError 错误。 Proxy特点 Proxy 在处理属性名的时候会把除 Symbol 类型外的所有属性名都转化成字符串，所以处理函数在判断属性名时需要尤其注意。 对代理对象的任何操作都会被拦截，一旦代理对象被创建就没有办法再修改它本身。 Proxy 的代理是非常底层的，在没有主动暴露原始目标对象的情况下，没有任何办法越过代理对象访问目标对象 Proxy 代理的目标只能是对象，不能是 JavaScript 中的原始类型 handler方法handler 对象是一个容纳一批特定属性的占位符对象。它包含有 Proxy 的各个捕获器（trap）。 所有的捕捉器是可选的。如果没有定义某个捕捉器，那么就会保留源对象的默认行为。 apply() construct() defineProperty () deleteProperty () get () getOwnPropertyDescrip () getPrototypeOf () has () isExtensible () ownKeys () preventExtensions () set () setPrototypeOf () handler的方法我们称之为陷阱。每个陷阱用于捕获一种行为。 defineProperty和deletePropertydefineProperty用于拦截Object.defineProperty操作，返回一个布尔值，表示该操作是否成功。 deleteProperty用于拦截属性的delete操作，也是返回布尔值。 getget用于拦截属性的读取操作，是很常用的属性。 1234var p = new Proxy(target, { get: function(target, property, receiver) { }}); target : 目标对象。 property : 被获取的属性名。 receiver : Proxy 或者继承 Proxy 的对象 setset方法拦截对属性值的操作 1234const p = new Proxy(target, { set: function(target, property, value, receiver) { }}); 应当返回一个布尔值。返回 true 代表属性设置成功 以上是一个基本介绍，具体细节望请查看mdn文档，proxy一般会用来配合reflect使用，下一节会介绍reflect。","link":"/2022/07/22/ES6%E8%AF%AD%E6%B3%95Proxy%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"Egg.js基础入门一:项目搭建与控制器","text":"2022年4月1日，周五，已完成本周的工作安排，明天又是个工作日，想来在公司会有一天半左右的相对自由的时间，所以分几个小模块说一下Egg.js的入门内容吧，毕竟自己也是个Egg初学者，太深入的内容自己也不懂。 项目搭建学习egg.js就从搭环境开始吧： 首先yarn create egg --type=simple创建一个egg项目，当然可以指定别的模板。 创建成功后yarn install安装相关依赖，yarn dev启动开发服务器。 egg项目内置了多种运行模式，主要说下dev与start的区别： dev：开发调试模式，可以热更新而不需重启项目 start：线上服务模式，有进程守护，不需要pm2等插件来守护进程。 通过yarn dev启动后我们可以看到项目运行在了127.0.0.1:7001这个端口，我们可以访问试一下验证项目是否成功运行。 项目目录通过yarn create egg --type=simple生成的项目目录大致如下： | app # 主要代码目录 | | controller | | public | | router | config # 配置 | logs # 日志文件 | run # 项目运行时生成的临时文件 | test # 用于写单元测试 | typing # 类型声明 导言Egg.js的宗旨是约定优于配置，那么什么是约定呢？ 比如下边这些就是： 控制器controller需要写在 /app/controller 目录下 服务service需要写在 /app/service 目录下 路由必须配置在 /app/router.js 文件中 ejs引擎渲染的内容需要放到 /app/view 目录下 单元测试写在 /test 目录下 静态资源放到 /app/public 目录下 插件要在 /config/plugin.js 和 /config/config.default.js 文件中配置 中间件必须放到 /app/middleware 目录下 对象扩展内容必须放到 /app/extend 目录下，且命名有要求 定时任务必须放到 /app/schedule 目录下 如上就是一些约定，当然不理解也没什么，往下看就会理解在说什么的。如果有些目录项目中不存在可以自行创建。 Egg.js是基于Koa实现的，所以最好能简单了解一下Koa的语法、洋葱模型等，当然不了解也无伤大雅。 后续所有的代码演示，都会在第一行的注释中声明文件路径 控制器实现大家可以好好看一下控制器的实现方式，因为service服务和定时任务的实现与控制器是极为相似的。 在演示之前先说一些规则，大家记住就好： ctx上下文和app对象可以从this中取出 request、response、helper、cookie、session等可以从上下文ctx中取出 具体的语法就放到代码中演示了 1234567891011121314151617// /app/controller/demo.js// 记得启用严格模式'use strict'// 从egg中引入controllerconst Controller = require('egg').Controller// 定义一个自定义控制器类 继承自 Controllerclass DemoController extends Controller { // 类的内部就可以写控制器方法了，必须使用async async index(){ const { ctx } = this // 与koa一致，使用ctx.body返回内容 ctx.body = &quot;这里是返回的内容&quot; }}// 将定义的controller暴露出去module.exports = DemoController 注册路由我们实现控制器之后，肯定要在路由中使用，下面介绍一下使用方法： 123456789// /app/router.jsmodule.exports = app =&gt; { // 解构 const { router, controller } = app // 注册路由 // 使用 controller.文件名.方法名 的方式来制定要使用控制器 router.get('/demo', controller.demo.index)} 接下来我们访问127.0.0.1:7001/demo，就能看到我们返回的内容了。 单元测试每写完一个方法都进行相应的单元测试肯定是一个好习惯，接下来我们就对刚刚写的方法进行单元测试。 当然我们的示例比较简单，返回内容也很简单，实际项目中的单元测试要麻烦的多 所以在这里只是演示一个单元测试的书写语法 仿照项目生成的测试用例来书写即可： 1234567891011121314// /test/app/controller/demo.test.js'use strict'const { app } = require('egg-mock/bootstrap')// describe函数 , 第一个参数是描述内容describe('test/app/controller/demo.test.js', () =&gt; { // 正式的测试用例，it函数也接受两个参数，第一个是对测试接口的描述 it('index method test', () =&gt; { return app.httpRequest() .get('/demo') // 请求接口路径 .expect(200) // 期望得到的状态码 .expect('这里是返回的内容') // 期望得到的返回内容 })}) 也可以对异步任务进行测试，单元测试的方法加上async即可 1234567// /test/app/controller/demo.test.jsit('index method test', async () =&gt; { return app.httpRequest() .get('/url') // 请求接口路径 .expect(200) // 期望得到的状态码 .expect('期望得到的返回内容') // 期望得到的返回内容})","link":"/2022/04/01/Egg-js%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%80-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"title":"Dart语言快速上手","text":"Dart作为Flutter的开发语言，与其他语言有很多相似之处，我们来看一下快速上手Dart语言的相关知识。 表达式创建并初始化变量： 1var name = 'Bob'; 显式的声明类型： 1String name = 'Bob'; 如果一个对象不受限于单一类型，可以指定为 Object 类型（或在必要时使用 dynamic）。 空安全空安全能够防止意外访问 null 的变量而导致的错误。 空安全引入了三个关键更改： 当你为变量、参数或另一个相关组件指定类型时，可以控制该类型是否允许 null 。要让一个变量可以为空，你可以在类型声明的末尾添加 ? 。 123String? name // Nullable type. Can be `null` or string.String name // Non-nullable type. Cannot be `null` but can be string. 你必须在使用变量之前对其进行初始化。可空变量是默认初始化为 null 的。 Dart 不会为非可空类型设置初始值，它强制要求你设置初始值。 Dart 不允许你观察未初始化的变量。这可以防止你在接收者类型可以为 null 但 null 不支持的相关方法或属性的情况下使用它。 你不能在可空类型的表达式上访问属性或调用方法。同样的例外情况适用于 null 支持的属性或方法，例如 hashCode 或 toString() 。 空安全将潜在的 运行时错误 转变为 编辑时 分析错误。当非空变量已经是以下情况之一时，空安全标记为非空变量： 使用非空值不初始化。 赋值为 null 。 默认值具有可空类型的未初始化变量的初始值为 null 。即使是具有数值类型的变量，初始值也为空，因为数字（就像 Dart 中的其他所有东西一样）都是对象。 12int? lineCount;assert(lineCount == null); 对于空安全，你必须在使用非空变量之前初始化它们的值.你不必在声明变量时初始化变量，但在使用之前需要为其赋值。 123456789int lineCount;if (weLikeToCount) { lineCount = countLines();} else { lineCount = 0;}print(lineCount); 顶级变量和类变量是延迟初始化的，它们会在第一次被使用时再初始化。 延迟初始化late 修饰符有两种用法： 声明一个非空变量，但不在声明时初始化。 延迟初始化一个变量。 如果你确定变量在使用之前已设置，但 Dart 推断错误的话，可以将变量标记为 late 来解决这个问题： 123456late String description;void main() { description = 'Feijoada!'; print(description);} 当一个 late 修饰的变量在声明时就指定了初始化方法，那么内容会在第一次使用变量时运行初始化。 终值和常量如果你不打算更改一个变量，可以使用 final 或 const 修饰它，而不是使用 var 或作为类型附加。一个 final 变量只能设置一次，const 变量是编译时常量。（const 常量隐式包含了 final。） 下面是创建和设置 final 变量的示例： 12final name = 'Bob'; // Without a type annotationfinal String nickname = 'Bobby'; 你不能修改 final 变量的值： 1name = 'Alice'; // Error: a final variable can only be set once. 请使用 const 修饰 编译时常量 的变量。如果 const 变量位于类级别，请将其标记为 static const（静态常量）。 类型内置类型有： Numbers(int, double) Strings(String) Booleans(bool) Records((value1, value2)) Lists(List, also known as arrays) Sets(Set) Maps(Map) Runes(Runes) Symbols(Symbol) The value null(Null) 常见类型就不说了，看一下Records类型： Records在dart3.0及以上版本可用。Records是不可变的，只有getter而没有setter 语法：以逗号分隔的命名字段或位置字段列表，用小括号包裹： 123456var record = ('first', a: 2, b: true, 'last');// 读取字段：命名字段有同名的getter，位置字段用$positionprint(record.$1); // 'first'print(record.a); // 2print(record.b); // trueprint(record.$2); // 'last' dart中范型的用法与TypeScript比较像。 typedef可以定义类型别名，比如： 1234// 定义类型别名IntListtypedef IntList = List&lt;int&gt;;IntList l = [1, 2, 3]; 类型别名也可以使用范型： 12345typedef ListMapper&lt;X&gt; = Map&lt;X, List&lt;X&gt;&gt;;ListMapper&lt;String&gt; m = { &quot;key&quot;: &quot;value&quot;,}; 函数方法Dart是面向对象的语言，所以即使是函数也是对象，并且有一个类型Function。这意味着函数可以分配给变量或作为参数传递给其他函数。 123456789101112// 函数示例int sum(int a, int b) { return a + b;}// 省略类型也生效sum(int a, int b) { return a + b;}// 箭头函数int sum(int a, int b) =&gt; a + b; =&gt; expr 语法是 { return expr; } 的简写。=&gt; 表示法有时称为箭头语法。 参数一个函数可以具有任意数量的必需位置参数。这些参数后面可以跟着命名参数或可选的位置参数（但不能同时跟这两个参数）。 在向函数传递参数或定义函数参数时，可以使用尾随逗号。 命名参数命名参数是可选的，除非它们被显式标记为required. 定义函数时，请使用 {param1, param2, …} 指定命名参数。如果未提供默认值或将命名参数标记为required，则其类型必须为 null，因为其默认值为 null: 1void enableFlags({bool? bold, bool? hidden}) {...} 可选位置参数将一组函数参数包装在 [] 中将它们标记为可选位置参数。如果未提供默认值，则其类型必须可为 null，因为其默认值将为 null: 1234567String say(String from, String msg, [String? device]) { var result = '$from says $msg'; if (device != null) { result = '$result with a $device'; } return result;} main函数每个应用都必须有一个顶级 main() 函数，该函数用作应用的入口点。main() 函数返回 void 并具有可选的 List&lt;String&gt; 参数参数。 下面是一个简单的 main() 函数： 123void main() { print('Hello, World!');} 下面是接受参数的命令行应用的 main() 函数示例： 12345678// Run the app like this: dart args.dart 1 testvoid main(List&lt;String&gt; arguments) { print(arguments); assert(arguments.length == 2); assert(int.parse(arguments[0]) == 1); assert(arguments[1] == 'test');} 匿名函数匿名函数看起来类似于命名函数，即零个或多个参数，括号之间用逗号和可选的类型注释分隔。 下面的代码块包含函数的主体： 1([[Type] param1[, …]]) { codeBlock;}; 流程控制if, for, while, break, continue等关键字及用法，与其他语言基本一致，不过多赘述，给几个示例： 标准for循环迭代： 123for (int i = 0; i &lt; 5; i++) { print(i);} forEach： 1234List&lt;int&gt; coll = [1, 2, 3];coll.forEach((element) { print(element);}); while和do-chile 1234567while(条件){ doSomething();}do { doSomething()} while(条件); if语句： 1234567if(bool) { } else if(bool) { } else { } switch语句 12345678switch(expr) { case '1': doSomething(); case '2': doSomething(); default: doSomething();} 类和对象Dart是一种面向对象的语言，具有类和基于mixin的继承。每个对象都是一个类的实例，除Null之外的所有类都派生自Object。基于mixin的继承意味着尽管每个类（除了顶层类Object）只有一个超类，但类体可以在多个类层次结构中重用。 类成员对象的成员由方法和实例变量组成 12345var p = Point(2, 2);// 读取变量print(p.x);// 调用方法p.distanceTo(Point(4, 4)); 可以使用?.调用来避免左侧操作数为null时发生异常： 1var x = p?.x; 构造函数创建与类名同名的函数来声明构造函数，初始化形式参数以实例化任何实例变量。 123456class Point { double x = 0; double y = 0; // 构造函数，接收形参以实例化成员变量 Point(this.x, this.y);} 使用命名构造函数为一个类实现多个构造函数，或提供额外的清晰度： 1234567891011121314const double xOrigin = 0;const double yOrigin = 0;class Point { final double x; final double y; Point(this.x, this.y); // Named constructor Point.origin() : x = xOrigin, y = yOrigin;} 请记住，构造函数不是继承的，这意味着超类的命名构造函数不是由子类继承的。如果要使用超类中定义的命名构造函数创建子类，则必须在子类中实现该构造函数。 您可以使用构造函数创建对象。构造函数名称可以是 ClassName 或 ClassName.identifier。例如，以下代码使用 Point和 Point.fromJson() 构造函数创建 Point() 对象： 12var p1 = Point(2, 2);var p2 = Point.fromJson({'x': 1, 'y': 2}); 以下代码具有相同的效果，但在构造函数名称之前使用可选的 new 关键字： 12var p1 = new Point(2, 2);var p2 = new Point.fromJson({'x': 1, 'y': 2}); 静态变量使用 static 关键字实现类范围的变量和方法。 静态变量（类变量）对于类范围的状态和常量很有用： 12345678class Queue { static const initialCapacity = 16; // ···}void main() { assert(Queue.initialCapacity == 16);} 静态变量在使用之前不会初始化。 并发Dart 库充满了返回 Future 或 Stream 对象的函数。这些函数是异步的：它们在设置可能耗时的操作（如 I/O）后返回，而无需等待该操作完成。 async 和 await 关键字支持异步编程，允许您编写类似于同步代码的异步代码。 当您需要完成的 Future 的结果时，您有两种选择： 使用 async 和 await 使用 Future API 使用 async 和 await 的代码是异步的，但它看起来很像同步代码。例如，下面是一些使用 await 等待异步函数结果的代码： 1await lookUpVersion(); 若要使用 await，代码必须位于async步函数中，即标记为async的函数: 1234Future&lt;void&gt; checkVersion() async { var version = await lookUpVersion(); // Do something with version} 使用 try、catch 和 finally 处理使用 await 的代码中的错误和清理: 12345try { version = await lookUpVersion();} catch (e) { // React to inability to look up the version} 您可以在async函数中多次使用 await。 补充补充一些注意事项，如果你是从其他语言转过来的，可能用得上： 在dart中可以使用!做类型断言不为空，比如data.name! 类中的方法以_开头表示不对外暴露，仅内部可访问，这个内部指的是文件，即这个文件中都可以访问，但是其他文件不可以访问。 dart中有类似于js中模板字符串的用法： 渲染变量: 'xxx $variable xxx' - 直接用$变量即可 进行运算：'xxx ${var1 + var2} xxx' - 用${表达式}渲染 函数中的位置参数如果不标记为可选都是必传的，通过{}包裹的命名参数如果不使用required修饰则都是可选的 dart中构造函数默认不能自定义返回值，如果需要可以使用工厂构造，比如Color.fromRGBO这些就是： 123456789101112131415class Chat { final String name; final String message; final String imageUrl; Chat({ required this.name, required this.message, required this.imageUrl, }); // 工厂构造, 可以自定义返回值 factory Chat.fromMap(Map mapData) { return Chat(name: mapData['name'], message: mapData['message'], imageUrl: mapData['imageUrl']); }} dart中的类实例才可以a.b这样访问属性，但是在map中需要a[b]这样访问。 这是一些dart的快速上手内容，了解了之后，就可以直接写起来了，在写的过程中，才能慢慢深入了解dart这门语言。","link":"/2024/03/18/Dart%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"title":"ES6语法Reflect的基本使用","text":"上回说到了Proxy，接下来对Reflect做一些介绍。 学过其他语言的人看到 Reflect 这个词可能会首先联想到“反射”这个概念，但 JavaScript 由于语言特性是不需要反射的，所以这里的 Reflect 其实和反射无关，是 JavaScript 给 Proxy 配套的一系列函数。Reflect 在 JS 环境里是一个全局对象，包含了与 Proxy 各种陷阱配套的函数。 Reflect 上的所有函数都对应一个 Proxy 的陷阱。这些函数接受的参数，返回值的类型，都和 Proxy 上的别无二致，可以说 Reflect 就是 Proxy 拦截的那些操作的原本实现。 Reflect不是一个函数对象，所以它是不可构造的，也就是说它不是一个构造器，不能通过 new 操作符去新建或者将其作为一个函数去调用 Reflect 对象。 Reflect的用法很简单，比如在不使用Reflect的情况下读取数据 12let obj = {name : &quot;lll&quot;}obj.name 使用Reflect 12let obj = {name: &quot;111&quot;}Reflect.get(obj, name) 这里说几个Reflect的陷阱，比如proxy中提到的deleteProperty和set： 语法： 1Reflect.deleteProperty(target, propertyKey) 返回值是一个布尔值，表示操作成功与否。 不知道大家是否还记得，proxy中的deleteProperty陷阱就是需要返回一个布尔值，但是我们直接使用delete删除得到的并不是一个布尔值，所以我们可以在Proxy的陷阱中调用Reflect对应的api来完成操作并且能得到符合要求的返回值。 set方法也与之类似。 12345let handler = { deleteProperty(...){ return Reflect.deleteProperty(...) }} Reflect 里的函数都和 Proxy 的陷阱配套，返回值的类型也和 Proxy 要求的相同，所以如果我们要实现原本的功能，直接调用 Reflect 里对应的函数就好了。 Proxy和Reflect的get方法的配合更是无处不在，关于这一块还是单独拿出来写一篇，见下一章节吧。","link":"/2022/07/22/ES6%E8%AF%AD%E6%B3%95Reflect%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"Egg.js基础入门三:中间件与定时任务","text":"续接上篇～～～ 中间件egg中间件与koa一致保持洋葱模型 按照约定中间件必须位于/app/middleware目录下 全局使用中间件定义一个全局中间件： 1234567891011121314151617// /app/middleware/counter.js'use strict'// 中间件必须接受一个options参数module.exports = options =&gt; { // 返回一个异步函数，异步函数接收两个参数，与koa一致分别是ctx和next return async (ctx, next) =&gt; { if(ctx.session.counter){ ctx.session.counter ++ } else { ctx.session.counter = 1 } // 需要next才能向下运行，await等待后续代码运行 // 中间件使用洋葱模型， // next之前的代码第一次进入时运行，next之后的代码会在第二次进入后运行 await next() }} 中间件想要在区局使用必须在config中进行一些配置： 123456789101112131415161718// /config/config.default.js'use strict';module.exports = appInfo =&gt; { const config = exports = {}; // 如果想要全局使用中间件需要在此进行配置 // 我们按照约定将中间价写入到/app/middleware目录下 // 所以在此处配置中写入中间件的文件名即可加载中间件到全局使用 config.middleware = ['counter']; return { ...config };}; 指定路由使用中间件可以将中间件应用于指定路由： 在config中取消对于中间件的全局配置 在router中取出中间件并将其配置到指定路由中 123456789101112131415// /config/config.default.js'use strict';module.exports = appInfo =&gt; { const config = exports = {}; // 中间件仅用于指定路由，不能在这里配置 config.middleware = []; return { ...config };}; 123456789101112// /app/router.js'use strict';module.exports = app =&gt; { // 取出中间件 const counter = app.middleware.counter() const { router, controller } = app; // 指定中间件仅在该路由使用，在路由中作为第二个参数传入 router.get('/mid4path', counter, controller.demo.useMiddleWare)}; 中间件的执行顺序前边说过Egg中的中间件是严格遵守洋葱模型的，可以看如下示例： 假设有如下路由： 12345678// /app/router.js'use strict';module.exports = app =&gt; { const { router, controller } = app; router.get('/testMiddleWare', controller.home.testMiddleWare)}; 控制器代码如下： 123456// /app/controller/home.jsasync testMiddleWare(){ const ctx = this.ctx console.log('控制器') ctx.body = 'success'} 编写两个中间件并在config中进行配置： 12345678910// /app/middleware/demo.js'use strict'module.exports = options =&gt; { return async (ctx, next) =&gt; { console.log('一号中间件1') await next() console.log('一号中间件2') }} 12345678910// /app/middleware/test.js'use strict'module.exports = options =&gt; { return async (ctx, next) =&gt; { console.log('二号中间件1') await next() console.log('二号中间件2') }} 12// /config/config.default.jsconfig.middleware = ['demo', 'test']; 从代码可以看出我们定义了两个中间件，在next前后分别进行了输出来演示洋葱模型的效果。 在config中我们定义中间件的顺序为demo在前。test在后。 所以我们访问路由应该会依次访问 demo -&gt; test -&gt; controller -&gt; test -&gt; demo 事实上控制台确实会依次打印如下内容： 12345一号中间件1二号中间件1控制器二号中间件2一号中间件2 定时任务定时任务必须放到/app/schedule目录下 定时任务的方式与Controller类似，但是类中的方法命名也有具体要求 12345678910111213141516171819202122232425262728// /app/schedule/get_time.js'use strict'// 必须引入Subscriptionconst Subscription = require('egg').Subscription// 定义一个类继承自Subscriptionclass GetTime extends Subscription { // 静态方法声明任务的一些属性，需要使用get关键字 // 必须叫schedule，要返回一个对象包含任务的属性配置 static get schedule(){ // 返回一个对象 return { // 任务间隔时间 // 除了用interval之外，也可以使用cron，输入cron表达式,不用传年份 // cron: '* * * * * *' interval: '10s', // 任务的类型： worker / all type: 'worker' } } // 任务的内容，是一个异步方法,命名为subscribe async subscribe(){ console.log('run schedule') }}// 暴露module.exports = GetTime 我们如上定义好一个定时任务之后，不需要做额外的配置，只要启动程序，定时任务就会启动。","link":"/2022/04/01/Egg-js%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%89-%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"title":"Egg.js基础入门二:Service服务与插件","text":"续接上篇～～～ 接收参数我们大多会把对于数据库的操作放到service服务中，然而对于数据库的操作的一些条件都是需要通过参数来确定的，所以在开始引入Service之前先说一下接收参数吧 在Egg中接收参数的方式与Koa是基本一致的，看一眼就能懂啦 Get请求参数Gue请求我们可以通过query传参数也可以通过path来传递参数 先说一下query传递参数： 假设有路由如下 12// /app/router.jsrouter.get('/getQuery', controller.demo.getQuery) 123456789// /app/controller/demo.jsasync getQuery(){ const { ctx } = this // 与koa一致，通过ctx.query拿到参数 // 假设访问的是getQuery?name=a&amp;age=18,那ctx.query就是{name:a,age:18} const query = ctx.query ctx.body = query} 用path传参数需要在路由上进行定义 12// /app/router.jsrouter.get('/getPath/:name/:age', controller.demo.getPath) 123456// /app/controller/demo.jsasync getPath(){ const { ctx } = this // 通过ctx.params 拿到参数 ctx.body = ctx.params} Post请求参数post请求通过ctx.request.body接收参数，与koa一致 12345// /app/controller/demo.jsasync postMethod(){ const { ctx } = this ctx.body = ctx.request.body} Service服务Service是用于在复杂场景下用于对复杂业务逻辑封装的一个抽象层，所有和数据库交互的代码可以放到这里，这样做有几个好处： 保持Controller逻辑更加简单 保持业务逻辑的独立性，Service可以被多个Controller调用 将数据逻辑和展现逻辑分离，测试用例写起来更加简单 Egg要求我们所有的Service必须放到/app/service目录下，如果没有该目录可以自行创建 Service的代码实现与Controller很相似 在controller中可以通过上下文来使用service，使用方法为ctx.service.文件名.方法名 假设我们有一个service如下： 1234567891011121314151617// /app/service/demo.js'use strict'// 引入 serviceconst Service = require('egg').Serviceclass DemoService extends Service{ // 异步方法哦 async demo(id){ // 在这里进行数据库操作 // 返回内容 return { name: 'asssd', age: 18 } }}// 导出module.exports = DemoService 接下来就可以在controller中使用Service服务来 12345678910// /app/controller/demo.jsasync useService(){ const { ctx } = this // 获取查询条件 const id = ctx.query.id // 调用service得到查询结果， 记住要用await, ctx.service.文件名.方法名 const res = await ctx.service.demo.demo(id) ctx.body = res } 插件Egg提供了很多插件，我们可以去安装使用，也可以自己编写插件，插件的配置都大同小异，具体的用法要查看插件的文档了，我们拿ejs引擎来介绍一下配置方法 安装egg提供的插件都是以egg-开头的，可以通过yarn或者npm进行安装 1yarn add egg-view-ejs 配置Egg的项目中有两个配置文件，一个是plugin.js，一个是config.default.js 毫无疑问plugin.js就是用来声明插件的，而config.default.js可以做很多中配置，不仅限于插件。 123456789// /config/plugin.js'use strict'exports.ejs = { // 启用插件 enable: true, // 制定包名 package: 'egg-view-ejg'} 这样我们就声明了ejs插件，几乎所有插件都要在这里用这种形式去声明 我们还可以在config.default.js中对其做一些额外的配置 1234567891011121314151617// /config/config.default.js'use strict'module.exports = appInfo =&gt; { const config = exports = {} config.view = { // 配置所有的html都使用ejs引擎来解析 mapping: { '.html': 'ejs' } } // 对于ejs引擎的个性化配置 config.ejs = { // 将ejs引擎解析的%替换成$ delimiter: &quot;$&quot; }} 关于插件具体有哪些可配置项，就需要查看插件的文档了，在此不过多赘述。","link":"/2022/04/01/Egg-js%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%BA%8C-Service%E6%9C%8D%E5%8A%A1%E4%B8%8E%E6%8F%92%E4%BB%B6/"},{"title":"Egg.js基础入门四:对象扩展","text":"续接上篇～～～ Egg虽然提供了很多内置的方法，但如果有时候感觉不够用，也可以自己对Egg中的方法进行扩展。 Egg.js可以对内部的五种对象进行扩展： 可扩展对象 说明 this指向 使用方式 application 全局应用对象 app对象 this.app context 请求上下文 ctx对象 this.ctx request 请求级别的对象，提供了请求相关的属性和方法 ctx.request对象 this.ctx.request response 请求级别的对象，提供了响应相关的属性和方法 ctx.response对象 this.ctx.response helper 帮助函数 ctx.helper对象 this.ctx.helper 所有扩展内容必须写在/app/extend目录下 如果我们对application进行扩展，必须在该目录下创建application.js，扩展其他内容同理 所有可扩展对象都可以对属性和方法进行扩展 对属性进行扩展需要使用get/set关键字 application扩展对扩展进行声明： 1234567891011121314151617181920212223// /app/extend/application.js'use strict'// 扩展内容必须使用module.exports导出一个对象module.exports = { // 方法扩展 currentTime(){ return getTime() }, // 属性扩展,属性扩展需要使用get/set关键字声明 get timeProp(){ return getTime() }}function getTime(){ let now = new Date() let year = now.getFullYear() let month = now.getMonth() + 1 let date = now.getDate() let nowTime = year + '/' + month + '/' +date return nowTime} 在控制器中使用： 1234567891011121314151617181920212223// /app/controller/demo.js'use strict';const Controller = require('egg').Controller;// 定义一个类继承自引入的Controllerclass DemoController extends Controller { // application扩展 async extendApp(){ // 需要从this中取出app这个全局对象 const { ctx, app } = this // 获取扩展方法返回的内容 let nowTimeByMethod = app.currentTime() // 获取扩展属性返回的内容 let nowTimeByProp = app.timeProp ctx.body = { extendMethod: nowTimeByMethod, extendProp: nowTimeByProp } }}// 将定义的controller暴露出去module.exports = DemoController; context扩展声明扩展： 123456789101112131415// /app/extend/context.js'use strict'module.exports = { // 方法扩展 - 返回请求参数 getParams(key){ // 通过ctx调用，所以this指向ctx const method = this.request.method if(method === 'GET'){ return key ? this.query[key] : this.query }else{ return key ? this.request.body[key] : this.request.body } }} 在controller中可以通过ctx进行使用 12345678910// /app/controller/demo.js// context扩展async extendCtx(){ const { ctx } = this // 通过扩展的params获取指定参数 const params = ctx.getParams('name') ctx.body = { name: params }} request扩展对request扩展 123456789101112// /app/extend/request.js'use strict'module.exports = { // 属性扩展 get token(){ // this.get('token') 获取ctx.request中的token的值，egg提供的语法,就是获取请求头的字段的值 // 在控制器中直接使用ctx.request.get('token')也是一样的 return this.get('token') }} request对象存在于ctx上下文中，所以需要使用ctx.request.的方式来调用 12345678910// /app/controller/demo.js// request扩展async extendReq(){ const { ctx } = this // request在上下文中，所以我们要通过ctx.request来访问扩展内容 const token = ctx.request.token ctx.body = { token }} response扩展1234567891011// /app/extend/resposne.js'use strict'module.exports = { // 设置属性，使用set关键字，必须接受参数 set token(token){ // 设置ctx.response的属性的值，就是设置响应头的字段的值 this.set('token', token) }} 12345678910// /app/controller/demo.js// response扩展async extendRes(){ const { ctx } = this // response存在于ctx上下文中，通过ctx.response访问 ctx.response.token = 'newToken' // 在浏览器的响应头就能接收到token这个字段 ctx.body = 'extendRes'} helper扩展扩展方法： 123456789// /app/extend/helper.js'use strict'module.exports = { // 方法扩展 - 加密字符串为base64 base64Encode(str = ''){ return new Buffer(str).toString('base64') }} 控制器中通过ctx.helper. 使用 123456789// app/controller/demo.js// helper扩展async extendHelper(){ const { ctx } = this const { name } = ctx.query.name // helper也存在于ctx上下文中 const text = ctx.helper.base64Encode(name) ctx.body = text} 上边简单演示了一下五种对象的扩展，当然实际开发中不会有这么简单的需求，但本章内容旨在入门，仅对语法进行了演示，后续自己仍需要进行深入学习。 我也会在空闲时间继续学习Egg，如果能有一些理解会继续更新内容。 那么Egg的基础入门系列就到这里啦。","link":"/2022/04/01/Egg-js%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%9B%9B-%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95/"},{"title":"Element-UI 2.x源码学习1","text":"开始看ElementUI的组件库源码，学习一下优秀的组件实现方式。单个组件来进行学习。 本文涉及到基础组件。 Button组件注意点如下： disabled通过disabled和loading两个状态来判断 通过type和size属性，来生成不同的class实现不同样式的渲染，其他如round、circle等属性也是如此。 通过$slots.default渲染默认插槽内容 click事件触发的时候传递event事件对象 简略版实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;template&gt; &lt;button class=&quot;el-button&quot; @click=&quot;handleClick&quot; :disabled=&quot;disabled || loading&quot; :autofocus=&quot;autofocus&quot; :type=&quot;nativeType&quot; :class=&quot;[ type? 'el-button--'+type : '', size?'el-button--'+size : '', { 'is-disabled': disabled, 'is-loading': loading, 'is-plain': plain, 'is-round': round, 'is-circle': circle } ]&quot; &gt; &lt;!-- Loading --&gt; &lt;i v-if=&quot;loading&quot; class=&quot;el-icon-loading&quot;&gt;&lt;/i&gt; &lt;!-- 如果传入icon且不处于loading的状态展示icon --&gt; &lt;i :class=&quot;icon&quot; v-if=&quot;!loading &amp;&amp; icon&quot;&gt;&lt;/i&gt; &lt;!-- $slots用来访问被插槽分发的内容。每个具名插槽有其对应的属性，例如v-slot:foo会在$slots.foo中找到。default属性包括所有没被包含在具名插槽的节点。 --&gt; &lt;span v-if=&quot;$slots.default&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/span&gt; &lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default { name: &quot;ElButton&quot;, props: { // 用于生成不同样式 // 根据type不同生成不同的class type: { type: String, default: &quot;&quot; }, nativeType: { type:String, default: &quot;button&quot; }, // 根据size生成Class来渲染不同的组件大小 size:String, icon:{ type:String, default:&quot;&quot; }, loading:Boolean, disabled:Boolean, plain: Boolean, autofocus: Boolean, round: Boolean, circle: Boolean }, methods: { // 点击事件接收event事件对象 handleClick(evt){ // 通过$emit触发click事件并将event事件对象传递出去 // 这就是为什么在el-button上的click事件能接收到event事件对象 this.$emit(&quot;click&quot;, evt) } }}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;// 样式代码略，可以查看packages/theme-chalk/src/button.scss&lt;/style&gt; 当然原版代码考虑了更多内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;template&gt; &lt;button class=&quot;el-button&quot; @click=&quot;handleClick&quot; :disabled=&quot;buttonDisabled || loading&quot; :autofocus=&quot;autofocus&quot; :type=&quot;nativeType&quot; :class=&quot;[ type ? 'el-button--' + type : '', buttonSize ? 'el-button--' + buttonSize : '', { 'is-disabled': buttonDisabled, 'is-loading': loading, 'is-plain': plain, 'is-round': round, 'is-circle': circle } ]&quot; &gt; &lt;i class=&quot;el-icon-loading&quot; v-if=&quot;loading&quot;&gt;&lt;/i&gt; &lt;i :class=&quot;icon&quot; v-if=&quot;icon &amp;&amp; !loading&quot;&gt;&lt;/i&gt; &lt;span v-if=&quot;$slots.default&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/span&gt; &lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'ElButton', // inject接收父组件的值 inject: { elForm: { default: '' }, elFormItem: { default: '' } }, props: { type: { type: String, default: 'default' }, size: String, icon: { type: String, default: '' }, nativeType: { type: String, default: 'button' }, loading: Boolean, disabled: Boolean, plain: Boolean, autofocus: Boolean, round: Boolean, circle: Boolean }, // 没有直接使用size、disabled等属性，而是做了更多的处理 computed: { _elFormItemSize() { return (this.elFormItem || {}).elFormItemSize; }, buttonSize() { return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size; }, buttonDisabled() { return this.$options.propsData.hasOwnProperty('disabled') ? this.disabled : (this.elForm || {}).disabled; } }, methods: { handleClick(evt) { this.$emit('click', evt); } } };&lt;/script&gt; ButtonGroup组件ButtonGroup组件没太多内容，就是通过插槽渲染Button 12345&lt;template&gt; &lt;div class=&quot;el-button-group&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; ButtonGroup中Button的渲染形式不同是通过样式实现的。 ButtonGroup的样式还是有可聊之处的，ButtonGroup的样式引入了utils-clearfix，引入的这个样式的写法挺巧妙的，是我之前没想到过的写法，如下： 1234567891011121314151617@mixin utils-clearfix { // 声明变量赋值为&amp; $selector: &amp;; @at-root { // @at-root可以跳出规则嵌套，也就是与引入这个混入的选择器同级。 // 如果要对这个选择器的父级添加一些样式，需要用到&amp;，但是在@at-root中直接用&amp;达不到效果。 // 所以在外部使用变量先声明&amp;,然后在这里通过插值语法使用 #{$selector}::before, #{$selector}::after { display: table; content: &quot;&quot;; } #{$selector}::after { clear: both } }} ICON组件icon组件的实现更为简单 通过给定name给予不同的样式名 根据样式名渲染不同的icon（使用font-family的方式实现） 12345678910111213&lt;template&gt; &lt;i :class=&quot;'el-icon-' + name&quot;&gt;&lt;/i&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'ElIcon', props: { name: String } };&lt;/script&gt; LINK组件Link组件的实现也很简单，通过传入不同的type来渲染不同样式的链接,通过href指定跳转路径，通过icon属性指定icon图标，通过disabled指定是否禁用。 只是多了slot插槽内容用于自定义: 需要注意的是click事件，只有在非禁用且href不存在的情况下才会被触发。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;a :class=&quot;[ 'el-link', type ? `el-link--${type}` : '', disabled &amp;&amp; 'is-disabled', underline &amp;&amp; !disabled &amp;&amp; 'is-underline' ]&quot; :href=&quot;disabled ? null : href&quot; v-bind=&quot;$attrs&quot; @click=&quot;handleClick&quot; &gt; &lt;i :class=&quot;icon&quot; v-if=&quot;icon&quot;&gt;&lt;/i&gt; &lt;span v-if=&quot;$slots.default&quot; class=&quot;el-link--inner&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/span&gt; &lt;template v-if=&quot;$slots.icon&quot;&gt;&lt;slot v-if=&quot;$slots.icon&quot; name=&quot;icon&quot;&gt;&lt;/slot&gt;&lt;/template&gt; &lt;/a&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'ElLink', props: { type: { type: String, default: 'default' }, underline: { type: Boolean, default: true }, disabled: Boolean, href: String, icon: String }, methods: { handleClick(event) { if (!this.disabled) { if (!this.href) { this.$emit('click', event); } } } }};&lt;/script&gt; LAYOUT组件layout布局依赖于row和col两个组件，分别看他们两个： ROWrow组件占据一行，接收以下属性： 1234567891011tag: { // 标签 type: String, default: 'div'},gutter: Number, // 间隔type: String, // 布局方式justify: { // 水平排列 type: String, default: 'start'},align: String // 竖直排列 生成间隔的方式很有意思，通过间隔/2加到两侧边距上，当然间隔这个东西得在列上加才能看到效果，后边看一下在col组件如何处理的： 123456789101112computed: { style() { const ret = {}; if (this.gutter) { ret.marginLeft = `-${this.gutter / 2}px`; ret.marginRight = ret.marginLeft; } return ret; }}, row组件使用h函数写的，内容比较简单很容易看懂： 1234567891011render(h) { return h(this.tag, { class: [ 'el-row', this.justify !== 'start' ? `is-justify-${this.justify}` : '', this.align ? `is-align-${this.align}` : '', { 'el-row--flex': this.type === 'flex' } ], style: this.style }, this.$slots.default);} 不难看出，默认渲染标签是div，中间的col组件通过插槽加载。 justify和align用于布局，仅在flex布局下生效，代码中没有体现，但不是flex布局下，即便加了justify-content样式也是无效的。 COLcol组件接收如下属性： 123456789101112131415161718props: { span: { // 占据的列数 type: Number, default: 24 }, tag: { // 标签 type: String, default: 'div' }, offset: Number, // 左侧检测的列数 pull: Number, // 向右移动多少列 push: Number, // 向左移动多少列 xs: [Number, Object], sm: [Number, Object], md: [Number, Object], lg: [Number, Object], xl: [Number, Object] }, row上定义的gutter终于要用到了： 1234567891011computed: { gutter() { let parent = this.$parent; // 找到row while (parent &amp;&amp; parent.$options.componentName !== 'ElRow') { parent = parent.$parent; } // 拿到了row的gutter return parent ? parent.gutter : 0; }}, 也是使用h函数渲染的： 123456789101112131415161718192021222324252627282930313233343536373839render(h) { let classList = []; let style = {}; // 通过左右内边距的形式将间隔渲染出来： if (this.gutter) { style.paddingLeft = this.gutter / 2 + 'px'; style.paddingRight = style.paddingLeft; } // 根据样式生成占用列数及位移 ['span', 'offset', 'pull', 'push'].forEach(prop =&gt; { if (this[prop] || this[prop] === 0) { classList.push( prop !== 'span' ? `el-col-${prop}-${this[prop]}` : `el-col-${this[prop]}` ); } }); // 一些响应式处理 ['xs', 'sm', 'md', 'lg', 'xl'].forEach(size =&gt; { if (typeof this[size] === 'number') { classList.push(`el-col-${size}-${this[size]}`); } else if (typeof this[size] === 'object') { let props = this[size]; Object.keys(props).forEach(prop =&gt; { classList.push( prop !== 'span' ? `el-col-${size}-${prop}-${props[prop]}` : `el-col-${size}-${props[prop]}` ); }); } }); return h(this.tag, { class: ['el-col', classList], style }, this.$slots.default); } 只是简单的过一下，没有去深究很详尽的细节，elemenu的基础组件就到这里了。","link":"/2022/06/28/Element-UI%202.x%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A01/"},{"title":"Gin中间件工作流程","text":"Gin是Go语言中一个很流行的Web框架，其性能比较高，比较简洁，中间件与Koa类似，采用了洋葱模型，我们来看一下它的大概执行原理。 中间件使用方式中间件使用方式示例： 123456789101112131415161718// 自定义中间件Loggerfunc Logger() gin.HandlerFunc { return func(c *gin.Context) { // 请求处理前做一些事 c.Next() // 继续执行后边的中间件 // 请求处理后做一些事 }}func main() { r := gin.New() r.Use(Logger()) // 监听并在 0.0.0.0:8080 上启动服务 r.Run(&quot;:8080&quot;)} 洋葱模型实现执行流程示例先给出一个示例，然后我们对照该实例去实现它。 12345678910111213141516171819202122func Middleware1(c *gin.Context) { fmt.Println(&quot;middleware1 before&quot;) c.Next() fmt.Println(&quot;middleware1 after&quot;)}func Middleware2(c *gin.Context) { fmt.Println(&quot;middleware2 before&quot;)}func Middleware3(c *gin.Context) { fmt.Println(&quot;middleware3 before&quot;) c.Next() fmt.Println(&quot;middleware3 after&quot;)}func HandlerFunc(c *gin.Context) { fmt.Println(&quot;handler()&quot;)}r.Use(Middleware1, Middleware2, Middleware3)r.Get(&quot;/&quot;, HandlerFunc) 可见我们定义了三个中间件和一个处理函数，在请求/时触发的流程为： 123456middleware1 beforemiddleware2 beforemiddleware3 beforehandler()middleware3 aftermiddleware1 after 符合洋葱模型的执行流程 代码实现我们只会实现其大致流程，不关注细节。 首先是Context的定义： 1234567// Context的基本定义，忽略无关属性type Context struct { // 该请求流程应用的所有中间件，处理函数也会收集进来 handlers []gin.HandlerFunc // 执行到第几个中间件,注意初始化为-1 index int} 收集流程涉及太多其他内容，不在这里赘述，我们只需要清除是先收集中间件，后将处理函数加入到handlers的结尾并手动调用Next方法。 如上示例中，handlers该有以下内容： 1[Middleware1, Middleware2, Middleware3, HandlerFunc] 实现洋葱模型的核心就是Next()方法，我们看一下它的实现： 12345678910func (c *Context) Next() { // 先执行一次自增，开始执行中间件 // 初始化为-1，正好自增后可以执行第一个 c.index++ // 循环调用 for c.index &lt; int8(len(c.handlers)) { c.handlers[c.index](c) c.index++ }} 实现就是这么简单，与Koa一样，实现方式很简洁，根据上边的示例我们可以想一下它的执行流程： 执行Middleware1中的before部分 执行Middleware1中的Next() index++后执行Middleware2中的before部分 for循环继续运行执行Middleware3中的before部分 执行Middleware3中的Next() index++后执行HandlerFunc for循环已经跳出，执行调用栈中Middleware3的after部分 执行调用栈中Middleware1的after部分 执行流程一致。 主要有两个细节需要注意： 为什么要执行for循环？ 因为不是所有的中间件都需要在请求处理函数后做一些操作，那么也就不是所有的中间件内部都会执行Next()方法。 所以需要加一个循环，即便不调用Next()也会依次执行所有中间件 执行第一个中间件调用Next开始for循环，执行后续中间件中的Next又会开始for循环，会不会导致后续的中间件重复执行？ 并不会。 因为我们修改的是c.index，而c是*Context，所以在所有中间件中使用的是同一个Context，其index值的修改会影响到所有中间件，并不会重复执行。","link":"/2023/09/03/Gin%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"title":"HarmonyOS快速上手","text":"近一段时间HarmonyOS热度高涨，也跟风看一下文档，做一下HarmonyOS快速上手的内容记录。 目录结构在不使用云开发的情况下，基本目录结构如下： AppScope - 存放应用全局所需要的资源文件 entry - 应用主模块，存放代码、资源等 main - 总文件夹 ets - 存放ets代码 entryability - 存放ability文件，用于应用逻辑和生命周期管理 pages - 存放UI界面相关代码文件 resources - 存放多媒体和布局文件 module.json5 - 模块配置文件 ohosTest - 单元测试目录 build-profile.json5 - 模块级配置信息，包括编译、构建配置项 hvigorfile.ts - 模块级构建脚本 oh-package.json5 - 模块级依赖配置文件 oh_modules - 工程依赖 build-profile.json5 - 工程级配置信息，包括签名、产品配置等 hvigorfile.ts - 工程级编译构建任务脚本 oh-package.json5 - 工程级依赖配置文件 需要描述UI的界面使用.ets文件 其他的普通文件如ability, 云服务等使用.ts文件。 组件与装饰器组件分类 基础组件 容器组件 媒体组件 绘制组件 画布组件 比如Text, Image, Button等就是基础组件，我们在构建页面的时候，最外层要使用布局组件来进行包裹，常用的布局组件有Row, Column, List, Grid。 组件都是通过属性和方法来构建其样式和绑定事件的，布局组件和包含子组件的组件，使用{}包裹起内部组件。 12345678910111213141516171819202122232425262728@Component // 构建组件的装饰器，先不关注，只看内容struct Index { build() { // 布局组件 Row({ space: 16, // 属性 }) { // 基础组件不包含子组件，不需要使用{} Text('文本内容') .fontSize(28) .fontWeight(FontWeight.Bold) Button('登录') .width('90%') .height(40) .onClick(() =&gt; { // 绑定事件 console.log('click handler') }) } .padding({ top: 40, left: 20, right: 20, }) .width('100%') .height('100%') }} Row, Column就是用来构建Flex布局，比较简单，不过多赘述了，简单看一下List, Grid组件吧。 List一般与子组件ListItem配合使用，实现垂直/水平方向线性排列 List是很常用的滚动类容器组件，一般和子组件ListItem一起使用，List列表中的每一个列表项对应一个ListItem组件。 1234List(value?: {space?: number | string, initialIndex?: number, scroller?: Scroller})space - 列表项间距initialIndex - 初次加载起始位置显示的itemscroller控制器 - 控制List滚动 滚动事件监听： onScroll - 滑动时触发，返回值scrollOffset为滑动偏移量，scrollState为当前滑动状态 onScrollIndex - 滑动时触发，返回值为滑动起始位置索引和滑动结束位置索引 onReachStart - 到达起始位置时触发 onReachEnd - 到达末尾时触发 onScrollStop - 滑动停止时触发 Grid组件为网格容器，是一种网格列表，由“行”和“列”分割的单元格所组成，通过指定“项目”所在的单元格做出各种各样的布局。Grid组件一般和子组件GridItem一起使用，Grid列表中的每一个条目对应一个GridItem组件。 123456789101112131415161718Grid() { ForEach(数组, (item: string) =&gt; { GridItem() { Text(item) .fontSize(16) .fontColor(Color.White) .backgroundColor(0x007DFF) .width('100%') .height('100%') .textAlign(TextAlign.Center) } }, item =&gt; item)}.columnsTemplate('1fr 1fr 1fr 1fr') // 列.rowsTemplate('1fr 1fr 1fr 1fr') // 行.columnsGap(10) // 列间距.rowsGap(10) // 行间距.height(300) // grid高度 构建的网格布局如果使用了固定的行数和列数，那么构建出的网格是不可滚动的。然而有时候因为内容较多，我们通过滚动的方式来显示更多的内容，就需要一个可以滚动的网格布局。我们只需要设置rowsTemplate和columnsTemplate中的一个即可（要指定固定的高度或者宽度）。 装饰器常用的装饰器有如下几个： @Component - 自定义组件，必须实现build方法 @Entry - 组件作为页面的默认入口组件 @State - 装饰组件内部的状态数据，变化后自动触发更新 @Prop - 装饰的变量必须使用父组件的@State进行初始化，组件内部修改后不会通知父组件，是单向数据绑定 @Link - 装饰的变量可以和父组件的@State变量建立双向绑定，并且需要在父组件中进行初始化 @Builder - 装饰的方法用于定义组件的声明式UI描述。 @Provider/@Consume 组件状态在组件范围传递的状态管理常见的场景如下： 场景 装饰器 组件内的状态管理 @State 从父组件单向同步状态 @Prop 与父组件双向同步状态 @Link 跨组件层级双向同步状态 @Provide, @Consume 如果需要观察嵌套类对象属性变化，需要使用@Observed和@ObjectLink装饰器，因为上述表格中的装饰器只能观察到对象的第一层属性变化。 当状态改变，需要对状态变化进行监听做一些相应的操作时，可以使用@Watch装饰器来修饰状态 父子组件通信前边说到的@Prop装饰器可以接收父组件传递的@State装饰的数据，但是有些时候没这么复杂，我们只是想在子组件接收父组件传递的数据进行渲染，可以直接定义属性 123456789101112131415// 子组件@Componentstruct TodoItem { private content: string; build() { Row() { Text(this.content) } }}// 父组件TodoItem({ content: 'abc'}) 生命周期自定义组件对于@Component定义的自定义组件生命周期为： 组件创建 aboutToAppear() - 创建组件之后，执行build之前 - 可以做一些数据初始化的工作 aboutToDisappear() - 释放资源，清除副作用 组件销毁 123456@Componentstruct MyComponent { aboutToAppear() {} aboutToDisappear() {}} 入口组件对于使用@Entry修饰的页面入口组件还有额外的三个生命周期函数： 组件创建 aboutToAppear() onPageShow() - 页面显示 onBackPress() - 返回 onPageHide() - 页面消失 aboutToDisappear() 组件销毁 123456789@Entry@Componentstruct MyComponent { onPageShow() {} onPageHide() {} onBackPress() {}} 条件/循环渲染使用if / else if / else进行条件渲染： 123456789build() { Column() { if (boolean) { Text('true') } else { Text('false') } }} 三元运算符也可以使用 使用ForEach迭代数组，为每个数组项创建组件 1234567891011@Builder RankList() { Column() { List() { ForEach(数组数据, (item, index) =&gt; { ListItem() { // ... } }, (item, index) =&gt; item.id) } }} ForEach接收三个参数： 数组数据 组件生成函数 唯一键生成函数 路由假设pages目录下有以下两个文件： Index.ets Second.ets 最常用的我们可以使用pushUrl进行路由的跳转，会将新的路由页面加入到栈中。 12345678910111213141516171819202122// Index.etsimport router from '@ohos.router'@Entry@Componentstruct Index { build() { Column({ space: 16, }) { Button('Next') .onClick(() =&gt; { router.pushUrl({ url: 'pages/Second', params: { 'msg': '来自第一个的数据' } }) }) } }} 12345678910111213141516171819202122232425262728// Second.etsimport router from '@ohos.router'interface RouteParams { msg: string}@Entry@Componentstruct Second { @State params: RouteParams = router.getParams() as RouteParams build() { Row() { Column() { Text(this.params.msg) .fontSize(50) .fontWeight(FontWeight.Bold) Button('Back') .onClick(() =&gt; { // 也可以通过参数返回到指定页面 router.back() }) } .width('100%') } .height('100%') }} 其他常用的路由跳转方法还有如replaceUrl()等 在返回之前还可以先调用router.enableBackPageAlert()方法开启页面返回询问对话框功能。 路由跳转模式： Standard - 多实例模式，也是默认情况下的跳转模式。目标页面会被添加到页面栈顶，无论栈中是否存在相同url的页面。 Single - 单实例模式。如果目标页面的url已经存在于页面栈中，则该url页面移动到栈顶。 UIAbilityUIAbility生命周期 UIAbility Start Create - 实例创建时触发，系统会调用onCreate回调 WindowStageCreate - 实例创建完成之后，在进入Foreground之前。WindowStage为本地窗口管理器，用于管理窗口相关的内容，例如与界面相关的获焦/失焦、可见/不可见。可以在onWindowStageCreate回调中，设置UI页面加载、设置WindowStage的事件订阅。 Foreground - UIAbility切换至前台 Background - UIAbility切换至后台 WindowStageDestroy - 在UIAbility实例销毁之前，则会先进入onWindowStageDestroy回调，我们可以在该回调中释放UI页面资源。 Destroy - 在UIAbility销毁时触发。可以在onDestroy回调中进行系统资源的释放、数据的保存等操作。 UIAbility End UIAbility生命周期包括四个状态： Create Foreground Background Destroy 注意是UIAbility的状态 启动模式UIAbility启动模式： 单实例模式singleton - 默认情况下的启动模式。每次调用startAbility()方法时，如果应用进程中该类型的UIAbility实例已经存在，则复用系统中的UIAbility实例。系统中只存在唯一一个该UIAbility实例，即在最近任务列表中只存在一个该类型的UIAbility实例。 多实例模式multiton - 每次调用startAbility()方法时，都会在应用进程中创建一个新的该类型UIAbility实例。即在最近任务列表中可以看到有多个该类型的UIAbility实例。 指定实例模式specified - 针对一些特殊场景使用（例如文档应用中每次新建文档希望都能新建一个文档实例，重复打开一个已保存的文档希望打开的都是同一个文档实例） 在module.json5文件中的“launchType”字段配置 网络请求 需要在module.json5中申明网络访问权限。 使用方式： 导入http模块 1import http from '@ohos.net.http'; 创建httpRequest 1let httpRequest = http.createHttp(); 每一个HttpRequest对象对应一个HTTP请求。如需发起多个HTTP请求，须为每个HTTP请求创建对应HttpRequest对象。最多只能创建100个HttpRequest对象。 订阅头信息（可选） 用于订阅http响应头，会比request请求先返回，如果有需要可以订阅 123httpReqquest.on('headersReceive', (header) =&gt; { console.log(JSON.stringify(header))}) 发送http请求 123456789101112let url = 'https://xxxxx';let promise = httpRequest.request( url, { method: http.RequestMethod.GET, connectTimeout: 60000, readTimeout: 60000, header: { } }) post请求的参数需要添加到extraData中： 123456789101112httpRequest.request( url, { method: http.RequestMethod.POST, // 数据 extraData: { 'param1': 'value1', 'param2': 'value2', // ... } }) 处理响应 1234567promise.then(data =&gt; { if (data.responseCode === http.ResponseCode.OK) { console.log(data.result); }}).catch(err =&gt; { }) 每一个httpRequest对应一个HTTP请求任务，不可复用","link":"/2024/04/06/HarmonyOS%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"title":"GetX快速上手","text":"GetX是一个状态管理插件，不仅有状态管理功能，还有路由管理、主题管理多语言、Obx局部更新、网络请求、数据验证等功能，可以作为基本框架使用了。 GetX的三个原则： 性能 效率 结构 GetX仅会编译你使用到的功能，没用到的功能不会编译到代码中。他的众多功能都在独立的容器中，只有使用了才会启动。 本来想先写一个Flutter的快速上手再来写GetX来着，但是整理了一下感觉Flutter的内容还是有些多，所以把Flutter的内容先网后放一放，直接记录一下GetX。 因此，阅读本篇之前，要有Flutter基础哦。 GetX的三大主要功能： 状态管理 路由管理 依赖管理 要使用GetX的一些功能时要在根节点包装为GetMaterialApp。 如果你只用Get来进行状态管理或依赖管理，就没有必要使用GetMaterialApp。GetMaterialApp对于路由、snackbar、国际化、bottomSheet、对话框以及与路由相关的高级apis和没有上下文（context）的情况下是必要的。 状态管理GetX里边的状态本质都是Streams。 声明响应式变量 使用Rx{Type} 1234final name = RxString('');final. isLogged = RxBool(false);final items = RxList&lt;String&gt;([]);final myMap = RxMap&lt;String, int&gt;({}); 使用Rx并规定范型Rx&lt;Type&gt; 1234final name = Rx&lt;String&gt;('');final isLogged = Rx&lt;Bool&gt;(false);final items = Rx&lt;List&lt;String&gt;&gt;([]);final myMap = Rx&lt;Map&lt;String, int&gt;&gt;({}); 添加.obs作为value的属性 1234final name = ''.obs;final isLogged = alse.obs;final items = &lt;String&gt;[].obs;final myMap = &lt;String, int&gt;{}.obs; Dart现在注重空安全， 所以总是用一个初始值来开始变量。 在变量的末尾添加.obs使其变成可观察到变量，它的.value就是初始值。 List是完全可观察的，在List中不需要使用.value。不过像String, int这些原始类型不能被扩展，需要强制使用.value，当然可以使用getter/setter来封装处理这些类型。 在UI中显示该值并在变化时更新页面，只需要： 1Obx(() =&gt; Text(&quot;${name}&quot;)); 使用GetX，一般来说不再需要使用StatefulWidget了。 路由管理导航到新页面 1Get.to(NextScreen()); 用别名导航到新页面 1Get.toNamed('/details'); 要关闭snackbars, dialogs, bottomsheets或任何你通常会用Navigator.pop(context)关闭的东西。 1Get.back(); 进入下一个页面，但没有返回上一个页面的选项（用于闪屏页，登录页面等）。 1Get.off(NextScreen()); 进入下一个页面并取消之前的所有路由（在购物车、投票和测试中很有用） 1Get.offAll(NextScreen()); 别名路由浏览并删除前一个页面。 1Get.offNamed(&quot;/NextScreen&quot;); 别名路由浏览并删除所有以前的页面。 1Get.offAllNamed(&quot;/NextScreen&quot;); 要导航到下一条路由，并在返回后立即接收或更新数据。 1var data = await Get.to(Payment()); 在另一个页面上，发送前一个路由的数据。 1Get.back(result: 'success'); 并使用它，例： 1if(data == 'success') madeAnything(); 如果你要在没有context的情况下使用路由/SnackBars/Dialogs/BottomSheets，或者使用高级的Get API，你需要使用GetMaterialApp 要定义路由，使用GetMaterialApp。 1234567891011121314151617void main() { runApp( GetMaterialApp( initialRoute: '/', // 定义路由 getPages: [ GetPage(name: '/', page: () =&gt; MyHomePage()), GetPage(name: '/second', page: () =&gt; Second()), GetPage( name: '/third', page: () =&gt; Third(), transition: Transition.zoom ), ], ) );} 要处理到未定义路线的导航（404错误），可以在GetMaterialApp中定义unknownRoute页面 123456789101112void main() { runApp( GetMaterialApp( unknownRoute: GetPage(name: '/notfound', page: () =&gt; UnknownRoutePage()), initialRoute: '/', getPages: [ GetPage(name: '/', page: () =&gt; MyHomePage()), GetPage(name: '/second', page: () =&gt; Second()), ], ) );} 发送数据到别名路由只要发送想要的参数即可，这里可以接受任何东西： 1Get.toNamed(&quot;/NextScreen&quot;, arguments: 'Get is the best'); 在类/控制器上可以接受： 1print(Get.arguments); Get提供高级动态URL，就像在Web上一样。Web开发者可能已经在Flutter上想要这个功能了，Get也解决了这个问题 1Get.offAllNamed(&quot;/NextScreen?device=phone&amp;id=354&amp;name=Enzo&quot;); 在你的controller/bloc/stateful/stateless类上： 1234print(Get.parameters['id']);// out: 354print(Get.parameters['name']);// out: Enzo 你也可以用Get轻松接收NamedParameters。 123456789101112131415161718192021222324252627void main() { runApp( GetMaterialApp( initialRoute: '/', getPages: [ GetPage( name: '/', page: () =&gt; MyHomePage(), ), GetPage( name: '/profile/', page: () =&gt; MyProfile(), ), //你可以为有参数的路由定义一个不同的页面，也可以为没有参数的路由定义一个不同的页面，但是你必须在不接收参数的路由上使用斜杠&quot;/&quot;，就像上面说的那样。 GetPage( name: '/profile/:user', page: () =&gt; UserProfile(), ), GetPage( name: '/third', page: () =&gt; Third(), transition: Transition.cupertino ), ], ) );} 发送别名路由数据 1Get.toNamed(&quot;/profile/34954&quot;); 在第二个页面上，通过参数获取数据 12print(Get.parameters['user']);// out: 34954 或像这样发送多个参数 1Get.toNamed(&quot;/profile/34954?flag=true&quot;); 在第二个屏幕上，通常按参数获取数据 123print(Get.parameters['user']);print(Get.parameters['flag']);// out: 34954 true 依赖管理Get有一个简单而强大的依赖管理器，它允许你只用1行代码就能检索到与你的Bloc或Controller相同的类，无需Provider context，无需inheritedWidget。 1Controller controller = Get.put(Controller()); Get.put(): 最常见的插入依赖关系的方式 123Get.put&lt;SomeClass&gt;(SomeClass());Get.put&lt;LoginController&gt;(LoginController(), permanent: true);Get.put&lt;ListItemController&gt;(ListItemController, tag: &quot;some unique string&quot;); Get.lazyPut: 可以懒加载一个依赖，这样它只有在使用时才会被实例化。这对于计算代价高的类来说非常有用 12345678910111213///只有当第一次使用Get.find&lt;ApiMock&gt;时，ApiMock才会被调用。Get.lazyPut&lt;ApiMock&gt;(() =&gt; ApiMock());Get.lazyPut&lt;FirebaseAuth&gt;( () { // ... some logic if needed return FirebaseAuth(); }, tag: Math.random().toString(), fenix: true)Get.lazyPut&lt;Controller&gt;( () =&gt; Controller() ) Get.putAsync: 如果你想注册一个异步实例，你可以使用 1234567Get.putAsync&lt;SharedPreferences&gt;(() async { final prefs = await SharedPreferences.getInstance(); await prefs.setInt('counter', 12345); return prefs;});Get.putAsync&lt;YourAsyncClass&gt;( () async =&gt; await YourAsyncClass() ) Get.find(): 会找到你的控制器，并将其提供给你。 123final controller = Get.find&lt;Controller&gt;();// 或者Controller controller = Get.find(); GetX插件GetX的使用比较简单，只在使用层面，也没有太多需要去通过示例来描述的，大家查看API文档即可。GetX推出了代码生成插件，非常好用，可以简单介绍一下： 在Android Studio中通过GetX插件可以右键创建GetX代码。 常用功能一般有选择page/component，创建文件夹，生成前缀。 我们以默认配置生成的文件有三个，比如我们创建order： order_view.dart - 视图6 order_logic.dart - 逻辑 order_state.dart - 状态 使用方式如下： 12345678910111213// state中定义响应式变量import 'package:get/get.dart';class OrderState { late RxInt age; late RxString name; OrderState() { ///Initialize variables age = 20.obs; name = 'sink'.obs; }} 12345678910111213// logic中定义数据修改逻辑import 'package:get/get.dart';import 'order_state.dart';class OrderLogic extends GetxController { final OrderState state = OrderState(); void increment() { state.age ++; }} 123456789101112131415161718192021222324252627282930313233343536// view中渲染UI并使用状态import 'package:flutter/material.dart';import 'package:get/get.dart';import 'order_logic.dart';class OrderPage extends StatelessWidget { OrderPage({Key? key}) : super(key: key); final logic = Get.put(OrderLogic()); final state = Get.find&lt;OrderLogic&gt;().state; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Order'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Obx(() =&gt; Text('${state.name} - ${state.age}')), ElevatedButton( onPressed: () { logic.increment(); }, child: const Text('age++'), ) ], ), ), ); }} 使用GetX插件可以大幅的提升效率，推荐使用哦","link":"/2024/04/03/GetX%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"title":"JS的EventLoop事件循环","text":"相信前端的小伙伴都或多或少的了解过EventLoop这个概念，但可能很多人并没有去深入学习过这个概念，我也一样。在这次失业找工作的过程中，面试官提出来一个问题是Promise和setTimeout的执行顺序问题，由于之前看到过相关问题所以知道是Promise先执行的，但是当面试官询问其原理时便一无所知了，所以在面试之后查阅了一些资料以及其他前辈的一些博客，对EventLoop有了一些基础的了解，纪录在此，用写给别人看的方式逼迫自己好好理解这个概念，争取做到知其然知其所以然。 翻了翻自己的笔记，找到了以前记录的EventLoop相关概念，翻出来发现完全看不懂了 任务队列中，在每一次事件循环中，macrotask只会提取一个执行，而microtask会一直提取，直到microsoft队列为空为止。 也就是说如果某个microtask任务被推入到执行中，那么当主线程任务执行完成后，会循环调用该队列任务中的下一个任务来执行，直到该任务队列到最后一个任务为止。而事件循环每次只会入栈一个macrotask,主线程执行完成该任务后又会检查microtasks队列并完成里面的所有任务后再执行macrotask的任务。 macrotasks: setTimeout, setInterval, setImmediate, I/O, UI renderingmicrotasks: process.nextTick, Promise, MutationObserver 所以在此将EventLoop的基础概念从头到尾理一遍： 单线程的JS大家都知道JavaScript是单线程的，作为一个浏览器的脚本语言，其主要用途是与用户互动 及 操作 DOM，它的使用场景决定了它只能是单线程的，否则会带来复杂的同步问题，假定JavaScript有两个线程，一个线程在某个DOM节点上添加内容，而另一个线程却删除了这个节点，此时浏览器应该以哪个线程为准呢？所以JavaScript是单线程的，但是为了充分利用多核CPU的计算能力，HTML5提出了Web Worker，允许创建多个线程，但是创建的子线程完全受主线程控制，且不允许子线程操作DOM，所以这个新标准 并没有改变JavaScript是单线程的本质。 关于Web Worker在此不展开描述，只是说明单线程问题。 单线程的代码执行是同步的而且会阻塞，如果只有同步执行肯定是不可以的，大家也都知道JavaScript是有异步函数的，比如setTimeout，而本文要说的Event Loop就是为了解决异步代码和同步代码的执行问题的。 相关术语概念栈栈在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。栈是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。 栈是只能在某一端插入和删除的特殊线性表。 队列队列也是一种数据结构，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。 队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出。 调用栈调用栈本质上还是一个栈，存放的是待执行的函数。 JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。 任务队列简单来说就是一个回调函数的队列，在JavaScript中，任务被分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask）。 宏任务宏任务包含了解析 HTML、生成 DOM、执行主线程 JS 代码和其他事件如 页面加载、输入、网络事件、定时器事件等。从浏览器的角度，宏任务代表的是一些离散的独立的工作。 如：script全部代码、setTimeout、setInterval、setImmediate、I/O、UI Rendering、 requestAnimationFrame。 微任务微任务则是为了完成一些更新应用程序状态的较小的任务，如处理 Promise 的回调和 DOM 的修改，以便让这些任务在浏览器重新渲染之前执行。微任务 应该以异步的方式尽快执行，所以它们的开销比宏任务要小，并且可以使我们在 UI 重新渲染之前执行，避免了不必要的 UI 渲染。 如：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver 执行顺序在文章开头引入的之前笔记写着： 任务队列中，在每一次事件循环中，macrotask只会提取一个执行，而microtask会一直提取，直到microsoft队列为空为止。 其实EventLoop至少需要一个宏任务队列和一个微任务队列。 微任务队列具有更高的优先级，即执行一个宏任务后，就会去执行整个微任务队列，如果此时有新的微任务加入也会被执行，直至微任务队列清空才会再去执行宏任务队列。 贴一张流程图(图源自网络)： 贴一个相关文章给出的最多的代码示例吧 12345678910111213console.log('script start')setTimeout(()=&gt;{ console.log('setTimeout')}, 0)Promise.resolve().then(()=&gt;{ console.log('promise 1')}).then(()=&gt;{ console.log('promsie 2')})console.log('script end') 经过前面的相关描述大家应该能直到执行的具体顺序了。 步骤： 执行开始，整个script脚本作为第一个宏任务进入调用栈开始执行。 输出script start 执行到setTimeout会将其加入宏任务队列进行等待。 执行到Promise会将其加入到微任务队列等待。 输出script end 此时第一个宏任务执行完毕了，不论宏任务队列是否清空，会直接开始执行微任务队列中的任务，从中拿出一个放入调用栈执行 执行Promsie会输出promise 1，返回undefined，第9行的回调会将其加入到微任务队列，此时由于微任务队列并没有清空，会继续执行输出promise 2。 微任务队列清空，执行宏任务队列。 执行setTimeout，输出setTimeout，宏任务队列清空。 程序执行完成。 所以上述代码的执行顺序应该是： 12345script startscript endpromise 1promise 2setTimeout 扩展知识在ES7中提出了Promise的语法糖async/await，其写法更加简便，也更加容易理解。 需要注意的是，async这个函数总是返回一个promise，不论你是否显式的返回了一个Promise。这也就说明async函数是一个异步函数，且由于是对promise的封装，所以其调用也会加入到微任务队列。 而await必须在async函数内部才能使用。","link":"/2021/11/10/JS%E7%9A%84EventLoop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"title":"JavaScript的防抖和节流","text":"在引入防抖和节流之前，给出一个需求，需要我们监视浏览器的滚动事件，返回滚动条与顶部的距离，我们很容易能写出这样的代码： 123456function showTop(){ let scrollTop = document.body.scrollTop || document.documentElement.scrollTop console.log('滚动条距离顶部的距离：' + scroolTop)}// 绑定事件window.onscroll = showTop 但是这样真的可行不？答案是可行但不太合适，因为这个函数的运行频率实在是太高了，只要滚动会一直触发，把浏览器的性能浪费在这里肯定是不合适的。 由此我们引出防抖和节流这两个概念。 防抖 定义： 对于短时间内连续触发的事件，防抖的含义就是当持续触发事件时，一定时间段内没有再次触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。 思路： 在第一次触发事件后，不要立即执行函数，而是给出一个期限值。 假如期限值内没有再次触发事件就执行处理函数 假如期限值内再次触发了该事件，则重新开始计时。 效果： 短时间内大量触发同一时间，那么只会执行一次处理函数 实现： 123456789101112131415161718192021222324// fn: 需要防抖的函数// delay: 期限值，msfunction debounce(fn, delay){ // 借助闭包避免变量全局污染 let timer = null // 这个才是onscroll绑定的函数 return function(){ // 如果已经在计时中，则取消计时并重新开始计时 if(timer){ clearTimeout(timer) timer = setTimeout(fn, delay) // 还未开始计时，则开始计时 }else{ timer = setTimeout(fn, delay) } }}// 需要防抖的函数function showTop(){ let scrollTop = document.body.scrollTop || document.documentElement.scrollTop console.log('滚动条距离顶部的距离：' + scroolTop)}// 绑定事件window.onscroll = debounce(showTop, 1000) 上述防抖函数的内部if条件语句是可以优化一下的： 12345678return function(){ // 不管当前是否开始计时，只要触发了都是要开始计时的 // 只是如果当前已经开始，则需要先停掉正在进行的计时器 if(timer){ clearTimeout(timer) } timer = setTimeout(fn, delay)} 看起来，好像已经实现需求了，也不会一直触发，避免了性能的过渡损耗 但是此时又出现了一个新的问题，假如一直滑动滚轮让浏览器滚动，岂不是函数永远不会触发了？ 节流当持续触发事件时，保证一定时间段内只调用一次事件处理函数。 简单说就是，如果短时间内大量触发同一事件，那么在函数执行一次后，该函数在指定的事件期限内不会再执行，直至过了这段时间才生效。 直接看代码吧，更加容易理解。 123456789101112131415161718192021222324function throttle(fn, delay){ // 设定状态valid表示函数当前是否处于可执行工作的状态 // 记住表示的是当前是否可以工作，不是是否正在工作 let valid = true return function(){ // 如果不可以工作，则直接return if(!valid){ return false } // 如果可以工作，则将其设为不可工作状态，并在等待设定时间之后执行一次处理函数 // 在等待过程中，是不会再执行处理函数的 valid = false setTimeout(()=&gt;{ fn() // 执行处理函数 valid = true // 处理完之后将其设为可工作状态 },delay) }}//要节流的函数function showTop(){ let scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log('滚动条距顶部距离:'+scrollTop)}window.onscroll = throttle(showTop,1000) 当然我们也可以通过时间戳来实现节流操作 12345678910function throttle(fn, delay){ let prev = Date.now() return function(){ let now = Date.now() // now保存本次执行的时间 if(now - prev &gt;= delay){ fn() prev = Date.now() // prev保存执行完的时间 } }}","link":"/2021/11/01/JavaScript%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"},{"title":"LeetCode75学习计划-二分查找","text":"算法解题思路很多会借鉴于题解区，如果侵权请联系删除。 本章节知识点为二分查找。 猜数字大小题目标签： 二分查找 题目难度： Easy 题目描述： 猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）： -1：我选出的数字比你猜的数字小 pick &lt; num 1：我选出的数字比你猜的数字大 pick &gt; num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num 返回我选出的数字 解题思路： 按照正常的二分查找逻辑走即可 代码实现： 12345678910111213func guessNumber(n int) int { left := 1 right := n for left &lt; right { mid := (left + right) / 2 if guess(mid) &lt;= 0 { right = mid } else { left = mid + 1 } } return left} 咒语和药水的成功对数题目标签： 二分查找 数组 题目难度： Medium 题目描述： 给你两个正整数数组 spells 和 potions ，长度分别为 n 和 m ，其中 spells[i] 表示第 i 个咒语的能量强度，potions[j] 表示第 j 瓶药水的能量强度。 同时给你一个整数 success 。一个咒语和药水的能量强度 相乘 如果 大于等于 success ，那么它们视为一对 成功 的组合。 请你返回一个长度为 n 的整数数组 pairs，其中 pairs[i] 是能跟第 i 个咒语成功组合的 药水 数目。 解题思路： 代码实现： 1234567891011func successfulPairs(spells []int, potions []int, success int64) []int { // 药水按照强度排序 sort.Ints(potions) pairs := make([]int, len(spells)) // 循环每一个咒语，依次计算可以成功的组合数目 for i, x := range spells { // 查找不满足结果的数据的下标，然后用总数减去就是满足的 pairs[i] = len(potions) - sort.SearchInts(potions, (int(success)-1)/x + 1) } return pairs} 寻找峰值题目标签： 二分查找 数组 题目难度： Medium 题目描述： 峰值元素是指其值严格大于左右相邻值的元素。 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞ 。 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。 解题思路： 最大值一定是一个峰值元素，所以遍历找最大值即可 代码实现： 12345678910func findPeakElement(nums []int) int { // 最大值一定是一个峰值元素，所以遍历找最大值即可 res := 0 for i, v := range nums { if v &gt; nums[res] { res = i } } return res} 爱吃香蕉的珂珂题目标签： 二分查找 数组 题目难度： Medium 题目描述： 珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。 珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。 返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。 代码实现： 1234567891011121314151617func minEatingSpeed(piles []int, h int) int { // 最大的一堆香蕉的数量 max := 0 for _, pile := range piles { if pile &gt; max { max = pile } } return 1 + sort.Search(max - 1, func(speed int) bool { speed ++ time := 0 for _, pile := range piles { time += (pile + speed - 1) / speed } return time &lt;= h })}","link":"/2024/01/24/LeetCode75%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"title":"Javascript的深浅拷贝","text":"基本数据类型与引用数据类型在讨论深浅拷贝之前，我们需要先说一下基本数据类型和引用数据类型： 基本数据类型：直接存储在栈中的数据 引用数据类型：存储的是该对象在栈中的引用，真实数据存放在堆内存中。 因为基本数据类型每次复制都会在栈中新开辟一块内存存放值，所以基本数据类型并不会涉及到深浅拷贝，接下来关于深浅拷贝到讨论仅针对于像Object和Array这样的引用数据类型。 浅拷贝与深拷贝首先说一下什么是深浅拷贝： 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，对新对象进行操作不会影响到原对象。 简单说就是有一个对象A，还有一个对象B是通过复制A来实现的，如果修改了对象A，对象B也跟着一起发生了变化，这就是浅拷贝；当修改了对象A，但是对象B不受影响，这就是深拷贝。 浅拷贝与赋值赋值： 把一个对象赋值给一个新的变量时，赋的是对象在栈中的地址，而不是堆中的数据，所以两个对象是指向同一个存储空间的。因此无论是哪个对象发生了改变，都会改变存储空间中的数据，另一个对象也会随之发生改变，即两个对象是联动的。 赋值的对象发生任何改动都会对原数据产生影响。 浅拷贝： 浅拷贝是按位拷贝对象，他会创建一个有着原始对象属性值精确拷贝的新对象。如果原始对象是基本数据类型，就会拷贝栈中的值，如果原始对象是引用数据类型，就会拷贝栈中存储的内存地址。 对浅拷贝的对象进行改动，如果原始对象是基本数据类型则不受影响，如果原始对象是引用数据类型则会随着进行变化。 下面说一些常用的深浅拷贝的方法(有些方法来自前辈的文章，如有侵权请联系删除)。 浅拷贝的实现方法Object.assign()方法关于Object.assign()方法，引用MDN的解释： Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。该方法将返回目标对象。 语法：Object.assign(target, ...sources) 该方法拷贝的是可枚举属性值，所以如果源值是一个对象的引用，它仅仅会复制其引用值 123let obj = {a: 1, b: 2}let copyObj = Object.assign({}, obj1)console.log(copyObj) // {a: 1, b: 2} 该方法也可用于实现对象的合并，不过要注意属性会被后续参数中具有相同属性的其他对象覆盖。 关于该方法的更多使用及细节，这里不展开说，有兴趣可以参阅MDN。 Array.prototype.concat()方法 concat()方法用于合并两个或多个数组，此方法不会更改现有的数组，而是返回一个新数组。 不难看出，这个方法仅使用于数组。 1234567let arr = [1, 3, [5]]let copy = arr.concat()console.log(copy) // [ 1, 3, [ 5 ] ]arr[0] = 10console.log(copy) // [ 1, 3, [ 5 ] ] 基本数据类型更改不受影响arr[2][0] = 10console.log(copy) // [ 1, 3, [ 10 ] ] 引用数据类型更改受影响 看到这里大家应该能更加清楚浅拷贝与赋值的区别了吧，咱们在看一下赋值的操作会怎样： 1234567let arr = [1,2,[5]]let copy = arrconsole.log(copy) // [ 1, 2, [ 5 ] ]arr[0] = 10console.log(copy) // [ 10, 2, [ 5 ] ]arr[2][0] = 1console.log(copy) // [ 10, 2, [ 1 ] ] 从这里应该不难看出了吧，回想一下赋值与浅拷贝的定义，我们也能清楚的知道，赋值的引用数据类型，进行任何改动都会互相影响，其存储的是整个源对象的内存地址；而浅拷贝的对象，是对源对象的每个属性值进行精确拷贝，所以对源对象中的基本数据类型进行更改，不会影响到拷贝对象，只有更改引用数据类型才会因为存储了相同的内存地址而互相影响，看一下上面的例子应该比较容易理解了，这也是我当初犯糊涂的一个地方。 Array.prototype.slice()方法 slice()方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 begin与end均为可选值，省略begin则从头开始，省略end则一直提取到数组末尾 在MDN到定义中已经清楚的写出了slice()方法返回的是原数组的浅拷贝，这里不过多赘述。 123let arr = [1, 2, 3]let copy = arr.slice()console.log(copy) // [1, 2, 3] 再次强调concat()与slice()方法 slice()和concat()方法并不会修改原数组，只是返回原数组中的浅拷贝。 原数组中的元素按照下述规则进行拷贝： 如果元素是基本数据类型，会将类型值直接拷贝到新数组，两个数组对于这些元素的改动不会互相影响。 如果元素是引用数据类型，会将该数据的内存地址拷贝到新数组，两个数组对于这些元素的操作会产生互相影响。 深拷贝的实现方法JSON.parse(JSON.stringify())先将源对象转换为json字符串在解析为js对象 12let arr = [1, 2, [5]]let copy = JSON.parse(JSON.stringfy(arr)) 注意：该方法不能用来处理函数 手写递归方法原理是递归遍历源对象的所有引用类型，知道其是基本数据类型再去进行复制。 在进行实现之前先介绍一下toString方法，我们可以通过toString.call()来判断数据类型： 仅限于Object.prototype.toString方法，其他类型的toString方法或多或少进行了重写，所以只有Object原型上的toString方法有这个效果，下边的toString指的是Object.prototype.toString。所以需要使用call方法来获取指定数据的原型。 12345678910toString.call(3) // '[object Number]'toString.call(NaN) // '[object Number]'toString.call('sss') // '[object String]'toString.call(true) // '[object Boolean]'toString.call() // '[object Undefined]'toString.call(null) // '[object Null]'toString.call(function(){}) // '[object Function]'toString.call([2]) // '[object Array]'toString.call({a:1}) // '[object Object]'toString.call(Symbol(1)) // '[object Symbol]' 可以发现，不管是什么类型得到的都是以[object开头，所以我们只需要下标8到-1的部分就可以得到数据的完整类型 下面是深拷贝的实现： 123456789101112131415161718192021222324252627282930313233// 深拷贝的函数实现function deepClone(data){ // 最终克隆的数据 let result; // 要进行拷贝的数据的类型 let dataType = checkDataType(data) if(dataType === 'Object'){ result = {} }else if(dataType === 'Array'){ result = [] }else { // 基本数据类型直接return return data } // 引用类型则遍历数据 for(let i in data){ // 获取每一项的值 let val = data[i] // 判断是否为引用类型 if(checkDataType(val) === 'Object' || checkDataType(val) === 'Array'){ // 是引用类型则对该值进行深拷贝，递归 result[i] = deepClone(val) }else{ // 不是引用类型则直接加入到结果中 result[i] = val } } return result}// 用于检测数据类型的功能函数function checkDataType(currentData){ return Object.prototype.toString.call(currentData).slice(8, -1)}","link":"/2021/10/21/Javascript%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"title":"Javascript的数组去重","text":"数组去重数组去重的方法是面试中的常见问题，下面总结了一些自己用过的以及其他前辈分享的去重方法，如有侵扰烦请联系删除。 ES6提供的set方法1234567// Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例。function unique(arr){ // new Set去重，Array.from创建一个新数组 return Array.from(new Set(arr))}let arr = [1,2,2,3,4,5,5]console.log(unique(arr)) // [1,2,3,4,5] indexOf去重12345678910function unique(arr){ let newArr = []; // 新建一个数组来存放值 for(let i=0,len=arr.length;i&lt;len;i++){ // 如果当前数据不在newArr中就加入newArr，否则不加入。避免重复 if(newArr.indexOf(arr[i]) === -1){ newArr.push(arr[i]) } } return newArr} 双重for循环去重123456789101112function unique(arr){ for (let i=0,len=arr.length;i&lt;len;i++){ for (let j=i+1,len=arr.length;j&lt;len;j++){ if (arr[i] == arr[j]){ arr.splice(j,1) // 如果重复就删除一个 j--;// 删除一个值，则j与len都要减1 len--; } } } return arr;} 利用sort排序对相邻元素去重123456789function unique(arr){ arr = arr.sort(); // 排序 let arr1 = [arr[0]] for (let i=1,len=arr.length;i&lt;len;i++){ // 从1开始 if(arr[i] != arr[i-1]){ //跟前一个对比，如果不重复就加入arr1 arr1.push(arr[i]) } }} 利用filter方法去重1234567function unique(arr){ // filter()方法创建一个新数组，数组元素是所有符合条件的元素 let newArr = arr.filter(function(item,index){ // 如果数组中item从0开始查找的索引值 === index，那就是前面没有相同元素，即不重复 return arr.indexOf(item,0) === index })}","link":"/2021/10/22/Javascript%E6%95%B0%E7%BB%84%E7%9A%84%E5%8E%BB%E9%87%8D/"},{"title":"LeetCode75学习计划-前缀和","text":"算法解题思路很多会借鉴于题解区，如果侵权请联系删除。 本章节知识点为前缀和。 找到最高海拔题目标签： 数组 前缀和 题目难度： Easy 题目描述： 有一个自行车手打算进行一场公路骑行，这条路线总共由 n + 1 个不同海拔的点组成。自行车手从海拔为0 的点 0 开始骑行。 给你一个长度为 n 的整数数组 gain ，其中 gain[i] 是点 i 和点 i + 1 的 净海拔高度差（0 &lt;= i &lt; n）。请你返回 最高点的海拔 。 示例： 输入：gain = [-5,1,5,0,-7]输出：1解释：海拔高度依次为 [0,-5,-4,1,1,-6] 。最高海拔为 1 解题思路： 题目确定是从海拔 0 开始出发的，我们循环 gain， 每一次累加得到的都是当前地点的海拔高度。取最大值即可 代码实现： 1234567891011121314151617func largestAltitude(gain []int) int { current := 0 res := 0 for _, v := range gain { // 当前点的海拔高度 current += v // 更新最终结果 res = max(current, res) } return res}func max (a, b int) int { if a &gt; b { return a } return b} 寻找数组的中心下标题目标签： 数组 前缀和 题目难度： Easy 题目描述： 给你一个整数数组 nums ，请计算数组的 中心下标 。 数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。 如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。 如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。 解题思路： 求数组所有元素的和为 total，中心下标 i 满足 其左侧的和sum = total - sum - nums[i] 代码实现： 12345678910111213141516171819func pivotIndex(nums []int) int { // 计算数组的总和 total := 0 for _, v := range nums { total += v } // 初始sum为0，因为左侧无元素也看作0 sum := 0 for i, v := range nums { // 中心下标的值 + 左侧和 * 2 = 总和 if sum * 2 + v == total { return i } // 更新左侧和 sum += v } // 找不到返回-1 return -1}","link":"/2023/12/09/LeetCode75%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-%E5%89%8D%E7%BC%80%E5%92%8C/"},{"title":"LeetCode75学习计划-二叉搜索树&#x2F;前缀树","text":"算法解题思路很多会借鉴于题解区，如果侵权请联系删除。 本章节知识点为二叉搜索树/前缀树。 二叉搜索树中的搜索题目标签： 树 二叉搜索树 题目难度： Easy 题目描述： 给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。 解题思路： 依据二叉搜索树的特性，递归查找子树即可 代码实现： 123456789101112131415func searchBST(root *TreeNode, val int) *TreeNode { // 为空返回空节点 if root == nil { return nil } // 找到了则返回以当前节点为根节点的子树 if val == root.Val { return root } // 如果val小于root.Val，那么肯定在左子树中，否则在右子树中 if val &lt; root.Val { return searchBST(root.Left, val) } return searchBST(root.Right, val)} 删除二叉搜索树中的节点题目标签： 树 二叉搜索树 题目难度： Medium 题目描述： 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 解题思路： 通过递归的方式来解决 如果 root 为空则返回空，如果 root.Val &gt; key ， 则递归 root.Left,否则递归 root.Right 如果 root.Val = key， root 就是要删除的节点。此时要删除 root 并将他的子树合并成一颗新的树 如果 root 是叶子节点，可以直接删除 如果 root 只有左子树或右子树，可以将左/右子树作为新的子树。 如果 root 有左右子树，那么就要找 root 的右子树中的最小节点作为新的根节点 代码实现： 1234567891011121314151617181920212223242526func deleteNode(root *TreeNode, key int) *TreeNode { switch { case root == nil: return nil case root.Val &gt; key: root.Left = deleteNode(root.Left, key) case root.Val &lt; key: root.Right = deleteNode(root.Right, key) case root.Left == nil || root.Right == nil: if root.Left != nil { return root.Left } return root.Right default: // 寻找右子树的最小节点 successor := root.Right for successor.Left != nil { successor = successor.Left } // 将这个节点作为新的树根节点后从原来的位置删除 successor.Right = deleteNode(root.Right, successor.Val) successor.Left = root.Left return successor } return root} 实现前缀树题目标签： 哈希表 字符串 字典树 题目难度： Medium 题目描述： 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串word的前缀之一为 prefix ，返回 true ；否则，返回 false 。 解题思路： 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940type Trie struct { children [26]*Trie isEnd bool}func Constructor() Trie { return Trie{}}func (t *Trie) Insert(word string) { node := t for _, ch := range word { ch -= 'a' if node.children[ch] == nil { node.children[ch] = &amp;Trie{} } node = node.children[ch] } node.isEnd = true}func (t *Trie) SearchPrefix(prefix string) *Trie { node := t for _, ch := range prefix { ch -= 'a' if node.children[ch] == nil { return nil } node = node.children[ch] } return node}func (t *Trie) Search(word string) bool { node := t.SearchPrefix(word) return node != nil &amp;&amp; node.isEnd}func (t *Trie) StartsWith(prefix string) bool { return t.SearchPrefix(prefix) != nil} 推荐搜索系统题目标签： 数组 字符串 字典树 题目难度： Medium 题目描述： 给你一个产品数组 products 和一个字符串 searchWord ，products 数组中每个产品都是一个字符串。 请你设计一个推荐系统，在依次输入单词 searchWord 的每一个字母后，推荐 products 数组中前缀与 searchWord 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。 请你以二维列表的形式，返回在输入 searchWord 每个字母后相应的推荐产品的列表。 解题思路： 没搞太清楚，有点迷糊，后续补吧，先抄个答案 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152type dirNode struct { child [26]*dirNode indexList []int}func suggestedProducts(products []string, searchWord string) [][]string { var res [][]string sort.SliceStable(products, func(i, j int) bool { return products[i] &lt; products[j] }) var pro func(i, index int, d *dirNode) pro = func(i, index int, d *dirNode) { if i &gt; 0 { d.indexList = append(d.indexList, index) } if i &gt;= len(products[index]) { return } if d.child[products[index][i]-'a'] == nil { d.child[products[index][i]-'a'] = new(dirNode) } pro(i+1, index, d.child[products[index][i]-'a']) } dir := dirNode{} for i := 0; i &lt; len(products); i++ { pro(0, i, &amp;dir) } var sea func(i, max int, d *dirNode) sea = func(i, max int, d *dirNode) { var temp []string if i &gt;= max { for j := 0; j &lt; len(d.indexList) &amp;&amp; j &lt; 3; j++ { temp = append(temp, products[d.indexList[j]]) } res = append(res, temp) return } if d.child[searchWord[i]-'a'] == nil { res = append(res, temp) return } sea(i+1, max, d.child[searchWord[i]-'a']) } for i := 0; i &lt; len(searchWord); i++ { sea(0, i+1, &amp;dir) } return res}","link":"/2023/09/13/LeetCode75%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%E5%89%8D%E7%BC%80%E6%A0%91/"},{"title":"LeetCode75学习计划-动态规划","text":"算法解题思路很多会借鉴于题解区，如果侵权请联系删除。 本章节知识点为动态规划。 第N个斐波那契数题目标签： 动态规划 题目难度： Easy 题目描述： 泰波那契序列 Tn 定义如下： ``T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0的条件下Tn+3 = Tn + Tn+1 + Tn+2` 给你整数 n，请返回第 n 个泰波那契数 Tn 的值。 解题思路： 动态规划方式解 代码实现： 12345678910111213141516func tribonacci(n int) int { if n == 0 { return 0 } if n == 1 || n == 2 { return 1 } dp := make([]int, n+1) dp[0] = 0 dp[1] = 1 dp[2] = 1 for i:=3; i&lt;=n; i++ { dp[i] = dp[i-1] + dp[i-2] + dp[i-3] } return dp[n]} 使用最小花费爬楼梯题目标签： 动态规划 题目难度： Easy 题目描述： 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。 请你计算并返回达到楼梯顶部的最低花费。 解题思路： 动态规划方式解 代码实现： 12345678910111213141516func minCostClimbingStairs(cost []int) int { n := len(cost) dp := make([]int, n+1) dp[0] = 0 dp[1] = 0 for i := 2; i&lt;=n;i++ { dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) } return dp[n]}func min(a, b int) int { if a &lt; b { return a } return b} 打家劫舍题目标签： 动态规划 数组 题目难度： Medium 题目描述： 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 解题思路： 动态规划方式解 代码实现： 1234567891011121314151617181920212223func rob(nums []int) int { n := len(nums) if n == 1 { return nums[0] } if n == 2 { return max(nums[0], nums[1]) } dp := make([]int, n) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i := 2; i &lt; n; i++ { // 不偷当前的 / 偷当前的 dp[i] = max(dp[i-1], dp[i-2] + nums[i]) } return dp[n-1]}func max(a, b int) int { if a &gt; b { return a } return b} 不同路径题目标签： 动态规划 多维数组 题目难度： Medium 题目描述： 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 解题思路： 动态规划方式解 代码实现： 1234567891011121314151617181920func uniquePaths(m int, n int) int { // 二维数组 dp := make([][]int, m) // 初始值 for i := range dp { dp[i] = make([]int, n) dp[i][0] = 1 } for j := 0; j &lt; n; j++ { dp[0][j] = 1 } for i := 1; i &lt; m; i++ { for j := 1; j &lt; n; j++ { // 到达该位置的路径数量为其左边与上边的路径数量和 dp[i][j] = dp[i-1][j] + dp[i][j-1] } } // 返回右下角的路径数量和 return dp[m-1][n-1]} 最长公共子序列题目标签： 动态规划 多维数组 题目难度： Medium 题目描述： 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 解题思路： 二维动态规划求解 代码实现： 12345678910111213141516171819202122232425func longestCommonSubsequence(text1 string, text2 string) int { m := len(text1) n := len(text2) // 初始化dp dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) } for i, c1 := range text1 { for j, c2 := range text2 { if c1 == c2 { dp[i+1][j+1] = dp[i][j] + 1 } else { dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]) } } } return dp[m][n]}func max(a, b int) int { if a &gt; b { return a } return b}","link":"/2023/08/02/LeetCode75%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"LeetCode75学习计划-哈希表&#x2F;哈希集合","text":"算法解题思路很多会借鉴于题解区，如果侵权请联系删除。 本章节知识点为哈希表/哈希集合。 找出两数组的不同题目标签： 数组 哈希表 题目难度： Easy 题目描述： 给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，请你返回一个长度为 2 的列表 answer ，其中： answer[0] 是 nums1 中所有 不 存在于 nums2 中的 不同 整数组成的列表。answer[1] 是 nums2 中所有 不 存在于 nums1 中的 不同 整数组成的列表。注意：列表中的整数可以按 任意 顺序返回。 解题思路： 通过集合来存储每个数组的数据映射，然后比对即可 代码实现： 12345678910111213141516171819202122232425func findDifference(nums1, nums2 []int) [][]int { // 两个集合来存储两个数组中的元素 set1 := map[int]bool{} set2 := map[int]bool{} for _, v := range nums1 { set1[v] = true } for _, v := range nums2 { set2[v] = true } // 结果数组 ans1 := make([]int, 0) ans2 := make([]int, 0) for v := range set1 { if !set2[v] { ans1 = append(ans1, v) } } for v := range set2 { if !set1[v] { ans2 = append(ans2, v) } } return [][]int{ans1, ans2}} 独一无二的出现次数题目标签： 数组 哈希表 题目难度： Easy 题目描述： 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。 如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 解题思路： 可以先统计每个数字出现的次数，最后比对次数是否有重复即可 代码实现： 1234567891011121314151617func uniqueOccurrences(arr []int) bool { // 存储数据映射 hash := map[int]int{} // 存储每个数字出现的次数 for _, v := range arr { hash[v] ++ } // 存储出现次数的映射 set := map[int]bool{} for _, v := range hash { if set[v] { return false } set[v] = true } return true} 确定两个字符串是否亲近题目标签： 字符串 哈希表 排序 题目难度：Medium 题目描述： 如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 接近 ： 操作 1：交换任意两个 现有 字符。例如，abcde -&gt; aecdb操作 2：将一个 现有 字符的每次出现转换为另一个 现有 字符，并对另一个字符执行相同的操作。例如，aacabb -&gt; bbcbaa（所有 a 转化为 b ，而所有的 b 转换为 a ）你可以根据需要对任意一个字符串多次使用这两种操作。 给你两个字符串，word1 和 word2 。如果 word1 和 word2 接近 ，就返回 true ；否则，返回 false 。 解题思路： 满足要求的字符必须满足几个条件 两个字符串的长度相同 两个字符串里的字母的种类相同 两个字符串的字母数量对应，不要求字母一样，但必须是对应的，比如word1有3个a，2个b，1个c, 而word2有 3个c，2个a，1个b，不要求字母一致，但是数量要能对应起来 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041func closeStrings(word1 string, word2 string) bool { // 判断长度是否一致 if len(word1) != len(word2){ return false } // 字符统计 hash1 := make(map[rune]int) hash2 := make(map[rune]int) for _ , v1 := range word1{ hash1[v1] ++ } for _ , v2 := range word2{ hash2[v2] ++ } if len(hash1) != len(hash2){ return false } // 判断字符种类是否相同 for k , _ := range hash1{ if _ , ok := hash2[k] ; !ok { return false } } // 比对数量是否能对应，找到对应的则置为0 for key , _ := range hash1{ for key2 , _ := range hash2{ if hash1[key] == hash2[key2]{ hash2[key2] = 0 break } } } // 有不为0的则表示数量是不能对应的 for _ , v :=range hash2{ if v != 0{ return false } } return true} 相等行列对题目标签： 数组 哈希表 矩阵 题目难度：Medium 题目描述： 给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。 如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。 解题思路： 通过哈希表将每一行放入哈希表中统计该行内容出现的次数 然后循环每一列，找到与之相等的行，然后将次数累加即可 代码实现： 12345678910111213141516171819202122func equalPairs(grid [][]int) int { // 行/列数 n := len(grid) // 哈希表存储每一行内容出现的次数 cnt := map[string]int{} for _, row := range grid { cnt[fmt.Sprint(row)]++ } res := 0 for j := 0; j &lt; n; j++ { // 每一列的内容 var arr []int for i := 0; i &lt; n; i++ { arr = append(arr, grid[i][j]) } // 如果列内容在行中有一样的，统计该行出现的次数 if val, ok := cnt[fmt.Sprint(arr)]; ok { res += val } } return res}","link":"/2023/12/09/LeetCode75%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/"},{"title":"LeetCode75学习计划-数组&#x2F;字符串","text":"感觉自己的算法太过于薄弱了，正好在 LeetCode 上发现了 LeetCode 75 学习计划，准备画一些时间把这些题目看一下，记录一下解题思路。 算法解题思路很多会借鉴于题解区，如果侵权请联系删除。 本章节知识点为数组/字符串。 交替合并字符串题目标签： - 双指针 - 字符串 题目难度： Easy 题目描述： 给你两个字符串 word1 和 word2 。请你从 word1 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。 返回 合并后的字符串 。 解题思路： 循环交替合并即可 代码实现： 12345678910111213141516171819func MergeAlternately(word1 string, word2 string) string { // 取两个字符串的长度 n := len(word1) m := len(word2) // 结果 res := make([]byte, 0, n+m) // 循环交替取字符 for i := 0; i &lt; n || i &lt; m; i++ { // 按照题目要求，从word1开始 if i &lt; n { res = append(res, word1[i]) } if i &lt; m { res = append(res, word2[i]) } } // 返回结果的字符串 return string(res)} 字符串的最大公因子题目标签： 数学 字符串 题目难度： Easy 题目描述： 对于字符串 s 和 t，只有在 s = t + ... + t（t 自身连接 1 次或多次） 时，我们才认定 “t 能除尽 s”。 给定两个字符串 str1 和 str2 。返回 最长字符串 x，要求满足 x 能除尽 str1 且 x 能除尽 str2 。 示例： 输入：str1 = “ABCABC”, str2 = “ABC”输出：”ABC” 解题思路： 公因子肯定是字符串的一个前缀子串 从大到小求公约数，然后判断该字符串是否是公因子 代码实现： 1234567891011121314151617181920212223242526272829303132333435func gcdOfString(str1, str2 string) string { n := len(str1) m := len(str2) minLength := min(n, m) // 求最长的x，所以从大往小循环。这里的i是x的长度 for i := minLength; i &gt; 0; i-- { // 如果i同时被n和m整除，就是一个公约数 if n%i == 0 &amp;&amp; m%i == 0 { // 字符串的公因子肯定是字符串的一个前缀，所以从头开始到i-1的位置判断是不是公因子即可 // 根据n、m和i的数值，判断str1和str2分别是循环了几次公因子 rangeN := n / i rangeM := m / i // 将公因子按循环次数拼接成字符串与原始内容比对，判断是不是公因子 if repeat(str1[:i], rangeN) == str1 &amp;&amp; repeat(str1[:i], rangeM) == str2 { return str1[:i] } } } return &quot;&quot;}func min(a, b int) int { if a &lt; b { return a } return b}// 把一个字符串重复n次后返回func repeat(str string, n int) string { res := &quot;&quot; for i := 0; i &lt; n; i++ { res += str } return res} 拥有最多糖果的孩子题目标签： 数组 题目难度： Easy 题目描述： 给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。 解题思路： 先求出数组中的最大值，即拥有糖果最多的孩子的糖果数 X 循环数组，对每一个元素加上额外的糖果数，判断是否不小于 X 代码实现： 12345678910111213141516171819202122func kidsWithCandies(candies []int, extraCandies int) []bool { // 孩子的数量 n := len(candies) // 求拥有最多糖果的孩子的糖果数量 maxCandies := 0 for i := 0; i &lt; n; i++ { maxCandies = max(maxCandies, candies[i]) } // 存储结果 res := make([]bool, n) for i := 0; i &lt; n; i++ { res[i] = candies[i]+extraCandies &gt;= maxCandies } return res}func max(a, b int) int { if a &gt; b { return a } return b} 种花问题题目标签： 数组 贪心 题目难度： Easy 题目描述： 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false 。 解题思路： 当花坛可种花的位置大于等于 n，则可以实现 假设 i 与 j 位置已经种了花，那么[i+2, j-2] 区域是可以种花的。 [i+2, j-2] 之间的位置数量为 j - i - 3，我们假定其为 m， 假设 m 是奇数，可以种植的位置数为 m+1 / 2，假设是偶数也可以使用该公式，因为偶数 +1 并不会影响结果。 代码实现： 1234567891011121314151617181920212223242526272829303132func canPlaceFlowers(flowerbed []int, n int) bool { // 可种植的数量 count := 0 m := len(flowerbed) prev := -1 for i := 0; i &lt; m; i++ { // 当前位置种花了，判断当前位置与上一个种花的位置中间可以种几棵花 if flowerbed[i] == 1 { if prev &lt; 0 { // 如果前边都没有花，可以种植花的位置为[0, i-2],其位置长度为i-1， 可种植花的数量为i-1+1 / 2,即 i/2 count += i / 2 } else { // prev与i的位置有花，其相邻位置不能有，结果为 (i - prev - 3 + 1) / 2 count += (i - prev - 2) / 2 } // 如果已经满足了则中断程序 if count &gt;= n { return true } prev = i } } if prev &lt; 0 { // 按照公式，m个位置则结果为 m+1 / 2 count += (m + 1) / 2 } else { // prev位置有花，后边都是空位，所以[prev+2, m-1]都是可以种植的，空位数量为m-1-prev-1, 结果就为m-prev-1 / 2 count += (m - prev - 1) / 2 } return count &gt;= n} 反转字符串中的元音字母题目标签： 双指针 字符串 题目难度： Easy 题目描述： 给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。 元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现不止一次。 解题思路： 双指针查找元音、交换位置，有点类似于快排找中值的操作 代码实现： 123456789101112131415161718192021222324func ReverseVowels(s string) string { t := []byte(s) n := len(s) // 双指针 i := 0 j := n - 1 for i &lt; j { // 首指针不是元音则++ for i &lt; n &amp;&amp; !strings.Contains(&quot;aeiouAEIOU&quot;, string(t[i])) { i++ } // 尾指针不是元音则-- for j &gt; 0 &amp;&amp; !strings.Contains(&quot;aeiouAEIOU&quot;, string(t[j])) { j-- } // 交换位置 if i &lt; j { t[i], t[j] = t[j], t[i] i++ j-- } } return string(t)} 反转字符串中的单词题目标签： 双指针 字符串 题目难度： Medium 题目描述： 给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 解题思路： 字符串切割 -&gt; 倒序 -&gt; 合并为字符串 代码实现： 1234567891011func reverseWords(s string) string { // 依据空格进行分割 slice := strings.Fields(s) res := make([]string, len(slice)) for i := range slice { // 循环倒序将元素加到结果上 res[i] = slice[len(slice)-1-i] } // 以空格分割合并为字符串 return strings.Join(res, &quot; &quot;)} 除自身以外数组的乘积题目标签： 数组 前缀和 题目难度： Medium 题目描述： 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums 之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 解题思路： 分别计算每个元素左右两侧的乘积，然后相乘就是要求的值 代码实现： 12345678910111213141516171819202122232425func productExceptSelf(nums []int) []int { n := len(nums) // 左右两侧的乘积列表 L := make([]int, n) R := make([]int, n) // 结果 res := make([]int, n) // 左侧的乘积列表，下标0左侧没元素了，所以设置L[0]为1 L[0] = 1 for i := 1; i &lt; n; i++ { // i位置的数据的左侧乘积 = i-1位置的数据的左侧乘积 * i-1位置的数据 L[i] = L[i-1] * nums[i-1] } // 右侧的乘积列表，下标n-1右侧没元素了，所以设置L[n-1]为1 R[n-1] = 1 for i := n-2; i &gt;= 0; i-- { // 与左侧乘积的计算思想一致 R[i] = R[i+1] * nums[i+1] } // 计算结果 for i := 0; i &lt; n; i ++ { res[i] = L[i] * R[i] } return res} 递增的三元子序列题目标签： 数组 贪心 题目难度： Medium 题目描述： 给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。 如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。 解题思路： 采用贪心算法，我们维护两个值 first 和 second ，始终保持 first 为最小值且 second 大于 first 循环元素，如果大于 second 则找到了满足要求的结果，如果小于 second 但是大于 first 则更新 second 的值为该元素，否则更新 first 的值为该元素。 贪心算法只保证了我们最后的答案是正确的，即是否有满足要求的数据，但是first, second, num三个的值并不一定是满足要求的数据的值。比如传入数据[5, 4, 3, 8, 2, 9]，我们得到的答案是 true， 然而我们的first是2， second是8, 最后返回true的时候的num是9，这几个元素并不是我们的结果数据。 代码实现： 12345678910111213141516171819202122232425func increasingTriplet(nums []int) bool { n := len(nums) // 如果不足3个元素则中断程序返回false if n &lt; 3 { return false } // 贪心算法 // 保证first始终为最小值，second始终大于first first := nums[0] second := math.MaxInt32 for i := 1; i &lt; n; i++ { num := nums[i] // 如果num大于second，那么则找到结果了 if num &gt; second { return true // 如果num小于second，但是num大于first，则second更新为num，因为这样在后边找到大于second的元素的几率更高 } else if num &gt; first { second = num // 如果num小于first，也就是说前边的元素并没有找到满足要求的结果，将first更新为num，更大概率在后边找到满足要求的结果 } else { first = num } } return false} 压缩字符串题目标签： 双指针 字符串 题目难度： Medium 题目描述： 给你一个字符数组 chars ，请使用下述算法压缩： 从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ： 如果这一组长度为 1 ，则将字符追加到 s 中。否则，需要向 s 追加字符，后跟这一组的长度。压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。 请在 修改完输入数组后 ，返回该数组的新长度。 你必须设计并实现一个只使用常量额外空间的算法来解决此问题。 解题思路： 通过三指针的形式来实现 循环读取 chars， 读指针 read 指向读取的元素，写指针 write 指向该写入内容的位置， 还有一个 left 指针指向当前重复字符的最左边的一个的位置。 当读指针读到最后一个元素，或者读指针指向的元素与下一个元素不同了，就意味着当前的重复字符已经读取完了，读指针指向的元素就是这个字符，read - left + 1 就是这个字符出现的数量。然后我们在写指针的位置写入字符和长度，更新指针的位置即可。 对于大于 10 的数字需要额外拆分。 因为是读取 chars 后再写入 chars ，所以没有占用额外的内存空间。 代码实现： 12345678910111213141516171819202122232425262728293031323334func Compress(chars []byte) int { // left 与 write 开始位于0 write := 0 left := 0 for read, ch := range chars { // 如果读指针位于最后一个元素，或者读指针指向的元素于下一个元素不一致 if read == len(chars)-1 || ch != chars[read+1] { // 在写指针的位置写入字符 chars[write] = ch write++ // 记录重复字符的数量 num := read - left + 1 if num &gt; 1 { // num &gt;= 10 要分开存储每一位 anchor := write // 先按照数字从右往左写入到chars for ; num &gt; 0; num /= 10 { chars[write] = '0' + byte(num%10) write++ } // 将写入的数字部分使其倒序 s := chars[anchor:write] for i, n := 0, len(s); i &lt; n/2; i++ { s[i], s[n-1-i] = s[n-1-i], s[i] } } // 更新left指针的位置 left = read + 1 } } // write左边的元素就是结果的内容，所以write的下标就是结果的长度 return write}","link":"/2023/07/05/LeetCode75%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"LeetCode75学习计划-图的DFS&#x2F;BFS","text":"算法解题思路很多会借鉴于题解区，如果侵权请联系删除。 本章节知识点为图的DFS/BFS。 钥匙和房间题目标签： 图 深度优先搜索 广度优先搜索 题目难度： Medium 题目描述： 有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。 当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。 给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回 false。 解题思路： 深度优先访问房间，对访问过的房间进行标记，最后判断是否能访问所有房间 代码实现： 1234567891011121314151617181920212223242526func canVisitAllRooms(rooms [][]int) bool { n := len(rooms) // 记录每个房间是否被访问了 visit := make([]bool, n) // 记录已经访问的房间的数量 num := 0 // dfs算法 var dfs func([][]int, int) dfs = func(s [][]int, x int) { // 将要访问的房间标记为已访问 visit[x] = true // 更新已访问的数量 num ++ for _, room := range s[x] { // 遍历从当前房间能够去往的房间，如果没去过就去 if !visit[room] { dfs(s, room) } } } // 运行dfs算法计算能访问多少房间，如果能访问的房间数与房间总数一致则能全部访问 dfs(rooms, 0) return num == n} 省份数量题目标签： 图 深度优先搜索 广度优先搜索 题目难度： Medium 题目描述： 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。 返回矩阵中 省份 的数量。 解题思路： 与上题类似，dfs加标记节点 代码实现： 1234567891011121314151617181920212223func findCircleNum(isConnected [][]int) int { res := 0 // 标记是否是省份 visit := make([]bool, len(isConnected)) var dfs func(int) dfs = func(from int) { visit[from] = true for to, conn := range isConnected[from] { // 如果conn=1则可以到达该省份 // 如果还没有从该省份出发，则从该省份出发计算 if conn == 1 &amp;&amp; !visit[to] { dfs(to) } } } for i, v := range visit { if !v { res ++ dfs(i) } } return res} 迷宫中离入口最近的出口题目标签： 数组 矩阵 广度优先搜索 题目难度： Medium 题目描述： 给你一个 m x n 的迷宫矩阵 maze （下标从 0 开始），矩阵中有空格子（用 '.' 表示）和墙（用 '+' 表示）。同时给你迷宫的入口 entrance ，用 entrance = [entrancerow, entrancecol] 表示你一开始所在格子的行和列。 每一步操作，你可以往 上，下，左 或者 右 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 entrance 最近 的出口。出口 的含义是 maze 边界 上的 空格子。entrance 格子 不算 出口。 请你返回从 entrance 到最近出口的最短路径的 步数 ，如果不存在这样的路径，请你返回 -1 。 解题思路： 从起点开始，广度遍历找出口，最近的一个出口返回 代码实现： 12345678910111213141516171819202122232425262728293031323334353637func nearestExit(maze [][]byte, entrance []int) int { // 行 m := len(maze) // 列 n := len(maze[0]) // 上下左右四个相邻坐标对应的行列变化量 dx := []int{1, 0, -1, 0} dy := []int{0, 1, 0, -1} // 队列 queue := [][]int{} // 入口加入到队列并修改为墙 queue = append(queue, []int{entrance[0], entrance[1], 0}) maze[entrance[0]][entrance[1]] = '+' for len(queue) &gt; 0 { // 队列的第一个元素，就是队列中离起点最近的元素 temp := queue[:1] queue = queue[1:] // 元素的位置和距离开始节点的距离 cx, cy, d := temp[0][0], temp[0][1], temp[0][2] // 遍历四个方向的点 for i := 0; i &lt; 4; i++ { nx := cx + dx[i] ny := cy + dy[i] // 合法且不是墙 if 0 &lt;= nx &amp;&amp; nx &lt; m &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; n &amp;&amp; maze[nx][ny] == '.' { // 找到出口了 if nx == 0 || nx == m - 1 || ny == 0 || ny == n-1 { return d + 1 } // 没找到出口，当前点设置为墙，继续找 maze[nx][ny] = '+' queue = append(queue, []int{nx, ny, d+1}) } } } return -1} 腐烂的橘子题目标签： 数组 矩阵 广度优先搜索 题目难度： Medium 题目描述： 在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一： 值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。 返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。 解题思路： 与上题类似，还是一层层遍历即可 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func orangesRotting(grid [][]int) int { // 行列 m := len(grid) n := len(grid[0]) // 新鲜橘子的数量 fresh := m * n // 队列 queue := [][]int{} // 找出初始的腐烂橘子加入队列 for i, valX := range grid { for j, valY := range valX { // 如果是腐烂的加入到队列中,并减少新鲜橘子的数量 if valY == 2 { queue = append(queue, []int{i, j, 0}) fresh -= 1 // 空格子减少新鲜橘子的数量 } else if valY == 0 { fresh -= 1 } } } // 上下左右四个相邻坐标对应的行列变化量 dx := []int{1, 0, -1, 0} dy := []int{0, 1, 0, -1} // 全部腐烂需要的时间，bfs每执行一次需要1分钟，最后一层执行完就是时间 d := 0 for len(queue) &gt; 0 { temp := queue[:1] queue = queue[1:] x := temp[0][0] y := temp[0][1] d = temp[0][2] // 遍历四个方向的点 for i := 0; i &lt; 4; i++ { nx := x + dx[i] ny := y + dy[i] // 还是新鲜的橘子 if 0 &lt;= nx &amp;&amp; nx &lt; m &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == 1 { grid[nx][ny] = 2 queue = append(queue, []int{nx, ny, d+1}) fresh -= 1 } } } if fresh &gt; 0 { return -1 } return d}","link":"/2023/10/14/LeetCode75%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-%E5%9B%BE%E7%9A%84DFS-BFS/"},{"title":"LeetCode75学习计划-栈&#x2F;队列","text":"算法解题思路很多会借鉴于题解区，如果侵权请联系删除。 本章节知识点为栈/队列。 从字符串中移除星号题目标签： 栈 字符串 题目难度： Medium 题目描述： 给你一个包含若干星号 * 的字符串 s 。 在一步操作中，你可以： 选中 s 中的一个星号。移除星号 左侧 最近的那个 非星号 字符，并移除该星号自身。返回移除 所有 星号之后的字符串。 注意： 生成的输入保证总是可以执行题面中描述的操作。可以证明结果字符串是唯一的。 解题思路： 遍历字符串，非星号则入栈，遇到星号则将栈顶元素移除。 代码实现： 1234567891011func removeStars(s string) string { stack := make([]byte, 0) for i, _ := range s { if s[i] != '*' { stack = append(stack, s[i]) } else { stack = stack[:len(stack)-1] } } return string(stack)} 行星碰撞题目标签： 栈 数组 题目难度： Medium 题目描述： 给定一个整数数组 asteroids，表示在同一行的行星。 对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。 找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞 解题思路： 从左往右遍历数组，当遍历到行星 a时，此时该行星存在。判断栈顶元素是否与当前行星互相向对方移动，如果是则至少有一个会爆炸，如果当前行星未爆炸则继续判断栈顶元素，直到栈内无其他行星或移动方向相同，此时将该行星加入到栈中。 代码实现： 123456789101112131415161718192021func asteroidCollision(asteroids []int) []int { stack := []int{} for _, aster := range asteroids { // 行星初始状态是未爆炸的 alive := true // 行星未爆炸 且 向左移动 且 栈内有行星 且 栈顶的行星向右移动 for alive &amp;&amp; aster &lt; 0 &amp;&amp; len(stack) &gt; 0 &amp;&amp; stack[len(stack) - 1] &gt; 0 { // 栈顶元素比当前小，则行星依然存在 alive = stack[len(stack) - 1] &lt; -aster // 如果栈顶元素比当前小或者相同大小，那么栈顶元素都会爆炸 if stack[len(stack) - 1] &lt;= -aster { stack = stack[:len(stack) - 1] } } // 如果当前行星仍然存活则加入到栈中 if alive { stack = append(stack, aster) } } return stack} 字符串解码题目标签： 栈 递归 字符串 题目难度： Medium 题目描述： 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 解题思路： 遍历字符串，碰到数字、字母、[直接进栈，碰到]开始出栈，知道[出栈，中间弹出的内容就是要重复的字符串，此时栈顶的数字，就是其该重复的次数，构造新的字符串后再进栈，知道遍历完整个字符串 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859func decodeString(s string) string { stack := []string{} ptr := 0 for ptr &lt; len(s) { // 当前元素 cur := s[ptr] // 处理数字 if cur &gt;= '0' &amp;&amp; cur &lt;= '9' { // 取出完整的数字 digits := getDigits(s, &amp;ptr) stack = append(stack, digits) // 处理字母和左括号 } else if (cur &gt;= 'a' &amp;&amp; cur &lt;= 'z' || cur &gt;= 'A' &amp;&amp; cur &lt;= 'Z') || cur == '[' { stack = append(stack, string(cur)) ptr++ } else { // 右括号 ptr++ // 因为括号可以嵌套，我们处理当前部分的字符串 sub := []string{} // 取出字母的部分 for stack[len(stack) - 1] != &quot;[&quot; { sub = append(sub, stack[len(stack) - 1]) stack = stack[:len(stack) - 1] } // 取出的字母顺序是反的，需要调换reverse一下 for i := 0; i &lt; len(sub)/2; i++ { sub[i], sub[len(sub) - i - 1] = sub[len(sub) - i - 1], sub[i] } // 取出左括号 stack = stack[:len(stack) - 1] // 重复次数 repeatTime, _ := strconv.Atoi(stack[len(stack) - 1]) stack = stack[:len(stack) - 1] // 计算重复后的字符串 t := strings.Repeat(getString(sub), repeatTime) // 加入到栈中 stack = append(stack, t) } } // 返回最终的结果 return getString(stack)}// 取出完整数字func getDigits(s string, ptr *int) string { res := &quot;&quot; for ; s[*ptr] &gt;= '0' &amp;&amp; s[*ptr] &lt;= '9'; *ptr ++ { res += string(s[*ptr]) } return res}// []string =&gt; stringfunc getString(v []string) string { res := &quot;&quot; for _, s := range v { res += s } return res} 最近的请求次数题目标签： 队列 设计 数据流 题目难度： Easy 题目描述： 写一个 RecentCounter 类来计算特定时间范围内最近的请求。 请你实现 RecentCounter 类： RecentCounter() 初始化计数器，请求数为 0 。int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。保证 每次对 ping 的调用都使用比之前更大的 t 值。 解题思路： 遍历字符串，碰到数字、字母、[直接进栈，碰到]开始出栈，知道[出栈，中间弹出的内容就是要重复的字符串，此时栈顶的数字，就是其该重复的次数，构造新的字符串后再进栈，知道遍历完整个字符串 代码实现： 123456789101112131415type RecentCounter struct { requests []int;}func Constructor() RecentCounter { return RecentCounter{}}func (this *RecentCounter) Ping(t int) int { // 只保留[t-3000, t]之间的请求 for len(this.requests) &gt; 0 &amp;&amp; this.requests[0] &lt; t - 3000 { this.requests = this.requests[1:] } this.requests = append(this.requests, t) return len(this.requests)} Dota2 参议院题目标签： 队列 贪心 字符串 题目难度： Medium 题目描述： Dota2 的世界里有两个阵营：Radiant（天辉）和 Dire（夜魇） Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 一 项： 禁止一名参议员的权利：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 所有的权利 。 宣布胜利：如果参议员发现有权利投票的参议员都是 同一个阵营的 ，他可以宣布胜利并决定在游戏中的有关变化。 给你一个字符串 senate 代表每个参议员的阵营。字母 'R' 和 'D'分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。 以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。 假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 &quot;Radiant&quot; 或 &quot;Dire&quot; 。 解题思路： 如果当前的所有议员都是同一方的，那么可以直接宣布胜利，否则应该让另一方第一个行使权力的议员失去权力才是最有效的方式 我们维护两个队列，分别是两方的议员，按照行使权力的顺序存入队列中，所以可以存储其下标。 假设天辉阵容的议员先行使权利，那么将夜魇队首的元素从队列中移除，然后将天辉阵容队首议员的下标增加议员数量的值后移动到队尾，依次可以实现一个轮的循环。 代码实现： 12345678910111213141516171819202122232425262728func predictPartyVictory(senate string) string { radiant := []int{} dire := []int{} for i := 0; i &lt; len(senate); i ++ { if senate[i] == 'R' { radiant = append(radiant, i) } else { dire = append(dire, i) } } // 开始按顺序行使权力 for len(radiant) &gt; 0 &amp;&amp; len(dire) &gt; 0 { // 天辉阵容行使权力 if (radiant[0] &lt; dire[0]) { radiant = append(radiant, radiant[0]+len(senate)) // 夜魇阵容行使权利 } else { dire = append(dire, dire[0] + len(senate)) } // 两阵容队首的元素移除 radiant = radiant[1:] dire = dire[1:] } if len(radiant) &gt; 0 { return &quot;Radiant&quot; } return &quot;Dire&quot;}","link":"/2023/07/09/LeetCode75%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-%E6%A0%88-%E9%98%9F%E5%88%97/"},{"title":"LeetCode75学习计划-树的DFS&#x2F;BFS","text":"算法解题思路很多会借鉴于题解区，如果侵权请联系删除。 本章节知识点为树的DFS/BFS。 二叉树的最大深度题目标签： 树 深度优先搜索 广度优先搜索 题目难度： Easy 题目描述： 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 解题思路： 递归肯定是最简单易懂的实现方式，也就是采用深度优先的思路 每一个节点的深度 = 1 + max(左子树的最大深度， 右子树的最大深度) 代码实现： 1234567891011121314151617181920type TreeNode struct { Val int Left *TreeNode Right *TreeNode}func maxDepth(root *TreeNode) int { // 如果节点不存在则深度为0 if root == nil { return 0 } // 1 + max(左子树的最大深度, 右子树的最大深度) return max(maxDepth(root.Left), maxDepth(root.Right)) + 1}func max(a, b int) int { if a &gt; b { return a } return b} 叶子相似的树题目标签： 树 深度优先搜索 二叉搜索树 题目难度： Easy 题目描述： 请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。 解题思路： 我们可以采用深度优先搜索，在搜索的时候总是先搜索左子节点，再搜索右子节点，这样就能得到一棵树的叶值序列 以此方式得到两棵树的叶值序列比对即可 代码实现： 123456789101112131415161718192021222324252627282930313233343536func leafSimilar(root1, root2 *TreeNode) bool { vals := []int{} // 深度优先算法 var dfs func(*TreeNode) dfs = func(node *TreeNode) { if node == nil { return } // 如果左右节点都没有，那么这个就是叶子节点，记录这个值 if node.Left == nil &amp;&amp; node.Right == nil { vals = append(vals, node.Val) return } // 先递归左子树，再递归右子树 dfs(node.Left) dfs(node.Right) } // 先计算root1的叶值序列 dfs(root1) vals1 := append([]int(nil), vals...) // 重置vals的值 vals = []int{} // 计算root2的叶值序列 dfs(root2) // 长度不一致则叶值序列一定不一致 if len(vals) != len(vals1) { return false } // 比对两个叶值序列 for i,v := range vals1 { if v != vals[i] { return false } } return true} 统计二叉树中的好节点题目标签： 树 深度优先搜索 广度优先搜索 题目难度： Medium 题目描述： 给你一棵根为 root 的二叉树，请你返回二叉树中好节点的数目。 「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值 解题思路： 采用深度优先的方式，统计好节点的数量。在深度优先过程中，记录根节点到当前节点到最大值（不包括当前节点），如果当前节点大于那个最大值，那么这个节点就是好节点 代码实现： 123456789101112131415161718192021222324func goodNodes(root *TreeNode) int { // 好节点的数量 goodNum := 0 // dfs算法 var dfs func(*TreeNode, int) dfs = func(node *TreeNode, max int) { if node == nil { return } // 如果当前节点大于路径上的最大值，则为好节点，并更新最大值后递归子节点 if node.Val &gt;= max { goodNum ++ max = node.Val } dfs(node.Left, max) dfs(node.Right, max) } if root == nil { return goodNum } dfs(root, root.Val) return goodNum} 路径总和 III题目标签： 树 深度优先搜索 题目难度： Medium 题目描述： 给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。 路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 解题思路： 穷举，计算每一个节点开始向下查找的路径有多少种 代码实现： 12345678910111213141516171819202122232425func pathSum(root *TreeNode, targetSum int) int { if root == nil { return 0 } // 通过递归调用的方式，计算以每一个节点作为开始的路径有多少种然后累加 res := 0 // 以自身为开始节点 res += rootSum(root, targetSum) // 递归调用,以左右子节点作为开始节点 res += pathSum(root.Left, targetSum) res += pathSum(root.Right, targetSum) return res}func rootSum(root *TreeNode, targetSum int) int { res := 0 if root == nil { return res } if root.Val == targetSum { res ++ } res += rootSum(root.Left, targetSum - root.Val) res += rootSum(root.Right, targetSum - root.Val) return res} 二叉树中的最长交错路径题目标签： 树 深度优先搜索 题目难度： Medium 题目描述： 给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下： 选择二叉树中 任意 节点和一个方向（左或者右）。 如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。 改变前进方向：左变右或者右变左。 重复第二步和第三步，直到你在树中无法继续移动。 交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。 请你返回给定树中最长 交错路径 的长度。 解题思路： 代码实现： 123456789101112131415161718192021222324252627func longestZigZag(root *TreeNode) int { res := 0 var dfs func(*TreeNode, int, int) dfs = func(node *TreeNode, direction int, length int) { if node == nil { return } res = max(res, length) if direction == 0 { dfs(node.Left, 1, length + 1) dfs(node.Right, 0, 1) } else { dfs(node.Right, 0, length + 1) dfs(node.Left, 1, 1) } } dfs(root, 0, 0) dfs(root, 1, 0) return res}func max(a, b int) int { if a &gt; b { return a } return b} 二叉树的最近公共祖先题目标签： 树 深度优先搜索 题目难度： Medium 题目描述： 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 解题思路： 递归调用，分别查找两侧的子树 代码实现： 12345678910111213141516171819202122func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } // 如果root.Val 等于 p.Val 或者 q.Val那么root就是公共祖先 if root.Val == p.Val || root.Val == q.Val { return root } // 递归调用子树，如果p和q分别在左右子树上，那么left和right都会返回其对应的树节点 // 如果p和q在同一侧的子树上，那么层级更浅的会作为树节点返回，另一侧的子树会返回nil left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) // 分别在两侧的子树上，那么root就是公共祖先 if left != nil &amp;&amp; right != nil { return root } // 在同一侧的子树上，则返回其树节点 if left == nil { return right } return left} 二叉树的右视图题目标签： 树 广度优先搜索 题目难度： Medium 题目描述： 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 解题思路： 对于树的每一层，最右侧的一个节点就是我们能看到的节点，所以可以使用广度优先的算法 代码实现： 12345678910111213141516171819202122232425func rightSideView(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) &gt; 0 { // 最后一个节点的值就是最右侧的一个 res = append(res, queue[len(queue) - 1].Val) // 复制一份queue，然后将queue清空 // 循环复制的queue的内容，将其子节点从左到右加入到queue中，这样queue中的最后一个节点是下一层的最右侧节点，直到最后一层 help := queue queue = nil for _, v := range help { if v.Left != nil { queue = append(queue, v.Left) } if v.Right != nil { queue = append(queue, v.Right) } } } return res} 最大层内元素和题目标签： 树 广度优先搜索 题目难度： Medium 题目描述： 给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。 请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。 解题思路： 与上一题的解题思路类似， 还是广度优先遍历，计算每一层的元素和即可 依然采用一个队列，不断的入队、出队，计算完每一层 我们在统计一层节点的元素和的时候，可以将下一层的内容加入到队列中 代码实现： 123456789101112131415161718192021222324252627282930func maxLevelSum(root *TreeNode) int { // 初始化结果和最大和 res := 1 maxSum := root.Val // 采用一个队列, 不断的入队出队，计算每一层的和 queue := []*TreeNode{root} for level := 1; len(queue) &gt; 0; level ++ { // 当前队列中是同一层的内容，先出队进行求和 temp := queue queue = nil sum := 0 for _, node := range temp { // 累加当前层的和 sum += node.Val // 将下一层的节点加入到队列中 if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } // 如果当前层的和大于之前计算的最大和，则当前层作为结果 if sum &gt; maxSum { maxSum = sum res = level } } return res}","link":"/2023/10/10/LeetCode75%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-%E6%A0%91%E7%9A%84DFS-BFS/"},{"title":"LeetCode75学习计划-链表","text":"算法解题思路很多会借鉴于题解区，如果侵权请联系删除。 本章节知识点为链表。 反转链表题目标签： 链表 递归 题目难度： Easy 题目描述： 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 解题思路： 遍历链表时，将当前节点的 next指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用 代码实现： 1234567891011121314151617type ListNode struct { Val int Next *ListNode}func reverseList(head *ListNode) *ListNode { // prev，current，next三个节点流转实现反转 var prev *ListNode current := head for current != nil { next := current.Next current.Next = prev prev = current current = next } return prev} 删除链表的中间节点题目标签： 链表 双指针 题目难度： Medium 题目描述： 给你一个链表的头节点 head 。删除 链表的 中间节点 ，并返回修改后的链表的头节点 head 。 长度为 ``n 链表的中间节点是从头数起第 ⌊n / 2⌋个节点（下标从0开始），其中⌊x⌋表示小于或等于x` 的最大整数。 对于 n = 1、2、3、4 和 5 的情况，中间节点的下标分别是 0、1、1、2 和 2 。 解题思路： 这里用快慢指针的思路即可，快指针遍历完整个链表之后，慢指针指向的节点就是中间节点 因为要删除中间节点，所以要有一个额外的前导指针指向慢指针的前一个节点 代码实现： 123456789101112131415161718192021type ListNode struct { Val int Next *ListNode}func deleteMiddle(head *ListNode) *ListNode { if head.Next == nil { return nil } // 指针 slow := head fast := head var prev *ListNode for fast != nil &amp;&amp; fast.Next != nil { fast = fast.Next.Next prev = slow slow = slow.Next } prev.Next = slow.Next return head} 奇偶链表题目标签： 链表 题目难度： Medium 题目描述： 给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。 第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。 请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。 你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。 解题思路： 可以先把链表按照奇偶数分为两个链表，最后组合起来 代码实现： 123456789101112131415161718192021func oddEvenList(head *ListNode) *ListNode { // 如果头节点不存在直接返回 if head == nil { return head } // head作为奇数链表的头节点，evenHead作为偶数链表的头节点 evenHead := head.Next // odd和even分别指向奇偶节点 odd := head even := evenHead // 循环链表，分离出奇偶链表 for even != nil &amp;&amp; even.Next != nil { odd.Next = even.Next odd = odd.Next even.Next = odd.Next even = even.Next } // 奇数链表的最后拼接上偶数链表 odd.Next = evenHead return head} 链表最大孪生和题目标签： 链表 栈 双指针 题目难度： Medium 题目描述： 在一个大小为n 且 n 为 偶数 的链表中，对于 0 &lt;= i &lt;= (n / 2) - 1 的 i ，第 i 个节点（下标从 0 开始）的孪生节点为第 (n-1-i) 个节点 。 比方说，n = 4 那么节点 0 是节点 3 的孪生节点，节点 1 是节点 2 的孪生节点。这是长度为 n = 4 的链表中所有的孪生节点。 孪生和 定义为一个节点和它孪生节点两者值之和。 给你一个长度为偶数的链表的头节点 head ，请你返回链表的 最大孪生和 。 解题思路： 采用快慢指针的思路，快指针走完链表之后，慢指针走完了一半的链表，在这个过程中将慢指针走过的值加入到栈中 之后慢指针继续向后移动，指向的每一个节点都与栈顶弹出的元素相加，计算该节点的孪生和，最后求的一个最大的孪生和 代码实现： 1234567891011121314151617181920212223242526272829303132func pairSum(head *ListNode) int { // 快慢指针 slow := head fast := head // 栈存储满指针走过的值 stack := []int{} // 当快指针走完链表之后，慢指针走完了一半的链表 // 在这个过程中将慢指针走过的值加入栈中 for fast != nil { stack = append(stack, slow.Val) slow = slow.Next fast = fast.Next.Next } // 此时慢指针可以继续往前走，没走一个就从栈顶弹出一个元素 // 他们两个就是孪生节点 maxValue := 0 for slow != nil { maxValue = max(maxValue, slow.Val + stack[len(stack) - 1]) // 更新慢指针位置 slow = slow.Next // 弹出栈顶元素 stack = stack[:len(stack)-1] } return maxValue}func max(a, b int) int { if a &gt; b { return a } return b}","link":"/2023/11/10/LeetCode75%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-%E9%93%BE%E8%A1%A8/"},{"title":"LeetCode75学习计划-滑动窗口","text":"算法解题思路很多会借鉴于题解区，如果侵权请联系删除。 本章节知识点为滑动窗口。 子数组最大平均数 I题目标签： 数组 滑动窗口 题目难度： Easy 题目描述： 给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。 请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。 任何误差小于 10-5 的答案都将被视为正确答案。 示例： 输入：nums = [1,12,-5,-6,50,3], k = 4输出：12.75 解题思路： 题目要求长度为 k 的连续子数组，我们只要维护一个长度为 k 的滑动窗口去计算即可 代码实现： 1234567891011121314151617181920212223func findMaxAverage(nums []int, k int) float64 { // 我们来维护一个最大的子数组的和，而不是直接维护平均值 // 这样只需要在最后进行一次计算即可 sum := 0 for _, v := range nums[:k] { sum += v } maxSum := sum for i := k; i &lt; len(nums); i++ { // 减去第一个数再加上当前的数就是当前的滑动窗口的和 sum = sum - nums[i-k] + nums[i] maxSum = max(maxSum, sum) } // 返回平均数 return float64(maxSum) / float64(k)}func max(a, b int) int { if a &gt; b { return a } return b} 定长子串中元音的最大数目题目标签： 字符串 滑动窗口 题目难度：Medium 题目描述： 给你字符串 s 和整数 k 。 请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。 英文中的 元音字母 为（a, e, i, o, u）。 解题思路： 与上一个题目的思路一致，定长的窗口计算数量即可 代码实现： 12345678910111213141516171819202122232425262728293031func maxVowels(s string, k int) int { // count统计每一个窗口的元音数量 count := 0 for i := 0; i &lt; k; i ++ { if isVowel(s[i]) { count ++ } } // ans 作为结果 ans := count for i := k; i &lt; len(s); i ++ { // 统计下一个窗口的元音数量并更新最大的元音数量 if (isVowel(s[i-k])) { count -- } if (isVowel(s[i])) { count ++ } ans = max(ans, count) } return ans}func isVowel(s byte) bool { return s == 'a' || s == 'e' || s == 'i' || s == 'o' || s == 'u'}func max(a, b int) int { if a &gt; b { return a } return b} 最大连续 1 的个数 III题目标签： 数组 滑动窗口 二分查找 前缀和 题目难度：Medium 题目描述： 给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。 示例： 输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2输出：6解释：[1,1,1,0,0,1,1,1,1,1,1]粗体数字从 0 翻转到 1，最长的子数组长度为 6。 解题思路： 题目要求的是求反转最多k 个0得到的仅包含1的最长子数组，换言之，就是找一个最长子数组内最多允许有k个0。 两个指针指向滑动窗口的左右边界，右指针主动右移，如果右指针指向了 0 说明滑动窗口内增加了一个 0, 判断窗口内0 的个数，如果超过了 k， 则左指针要被迫右移，直接窗口内 0 的个数小于等于 k 才行。 在这个求滑动窗口的过程中，滑动窗口长度的最大值就是我们要求的值 代码实现： 12345678910111213141516171819202122232425262728293031323334func longestOnes(nums []int, k int) int { n := len(nums) // 滑动窗口的最大长度 res := 0 // 指针 left, right := 0, 0 // 0的数量 zeros := 0 // 主动移动右指针 for right &lt; n { if nums[right] == 0 { zeros ++ } // 如果0的数量大于k，则移动左指针 for zeros &gt; k { if nums[left] == 0 { zeros -- } left ++ } // 更新窗口的最大值 res = max(res, right - left + 1) // 更新右指针 right ++ } return res}func max(a, b int) int { if a &gt; b { return a } return b} 删掉一个元素以后全为 1 的最长子数组题目标签： 数组 滑动窗口 题目难度：Medium 题目描述： 给你一个二进制数组 nums ，你需要从中删掉一个元素。 请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。 如果不存在这样的子数组，请返回 0 。 示例： 输入：nums = [1,1,0,1]输出：3解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。 解题思路： 本题与上一题可以说是一样的题目，只是上题的 k 固定为1了，还有本题是删除而不是替换 代码实现： 1234567891011121314151617181920212223242526272829303132333435func longestSubarray(nums []int) int { n := len(nums) // 滑动窗口的最大长度 res := 0 // 指针 left, right := 0, 0 // 0的数量 zeros := 0 // 主动移动右指针 for right &lt; n { if nums[right] == 0 { zeros ++ } // 如果0的数量大于1，则移动左指针 for zeros &gt; 1 { if nums[left] == 0 { zeros -- } left ++ } // 更新窗口的最大值 res = max(res, right - left + 1) // 更新右指针 right ++ } // 必须删掉一个元素 return res - 1}func max(a, b int) int { if a &gt; b { return a } return b}","link":"/2023/11/08/LeetCode75%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"title":"NestJs项目搭建","text":"作为一个前端开发人员，不免也想去窥探一下后端的世界。后端技术广袤无边，语言反而感觉不那么重要了。前端肯定最熟悉JavaScript，在不切换语言的情况下去学习后端，可以降低一些学习成本。所以准备通过学习NodeJs后端开发来更好的了解后端，而NestJs又是最火热的后端框架之一，学它不会有错的。 使用Nest CLI创建项目： 12npm i -g @nestjs/clinest new project-name 项目核心文件： 123456src ├── app.controller.spec.ts ├── app.controller.ts ├── app.module.ts ├── app.service.ts └── main.ts 以下是这些核心文件的简要概述： app.controller.ts 带有单个路由的基本控制器示例。 app.controller.spec.ts 对于基本控制器的单元测试样例 app.module.ts 应用程序的根模块。 app.service.ts 带有单个方法的基本服务 main.ts 应用程序入口文件。它使用 NestFactory 用来创建 Nest 应用实例 main.ts包含一个异步函数，负责引导应用程序 12345678import { NestFactory } from '@nestjs/core'import { AppModule } from './app.module'async function bootstrap() { const app = await NestFactory.create(AppModule) await app.listen(3000)}bootstrap() 运行应用程序 1npm run start 注意： NestJs对于代码规范做了很多约束，比如单引号、数组最后一个元素加逗号等。可以根据自己团队规范去修改，通过prettier插件在保存的时候去格式化代码，不过自己能直接写规范就更好了。","link":"/2022/09/16/NestJs%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"title":"LeetCode75学习计划-双指针","text":"算法解题思路很多会借鉴于题解区，如果侵权请联系删除。 本章节知识点为双指针。 移动零题目标签： 数组 双指针 题目难度： Easy 题目描述： 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例： 输入：nums = [0,1,0,3,12]输出：[1,3,12,0,0] 解题思路1： 采用双指针的思路，保证左指针左边是非零的数据，即左指针指向非零序列的结束位置，右指针一直向右移动，碰到非零的值与左指针指向的值交换，更新指针位置，知道所有的零值放到最后 在双指针移动过程中，如果前边的值都是非零值，会有很多无意义的交换 代码实现： 12345678910111213141516func moveZeroes(nums []int) { // 左右指针位置初始化 left := 0 right := 0 n := len(nums) for right &lt; n { // 右指针非零值则与左指针交换位置 if nums[right] != 0 { nums[left], nums[right] = nums[right], nums[left] // 交换后更新左指针的位置 left++ } // 更新右指针的位置 right++ }} 解题思路2: 不使用双指针来解题了，直接循环并计算零值的数量，如果该值不是零值则根据前边零值的数量与前边的值交换一下位置即可 代码实现2: 123456789101112131415func moveZeroes(nums []int) { count := 0 for i,v := range nums { // 如果为0则统计 if v == 0 { count ++ } else { // 如果不为0且前边有0，则根指定位置交换 // 因为后边的都是0，所以直接补0了 if count &gt; 0 { nums[i-count], nums[i] = v, 0 } } }} 判断子序列题目标签： 字符串 动态规划 双指针 题目难度： Easy 题目描述： 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。 解题思路： 指针 i 指向s， 指针 j 指向 t， 如果字符一致则两个指针同时后移，否则则移动 j，遍历完字符串t 之后判断i指针的位置，如果遍历完了字符串 s，则是子序列 代码实现： 12345678910111213141516func isSubsequence(s string, t string) bool { n := len(s) m := len(t) i := 0 j := 0 for i &lt; n &amp;&amp; j &lt; m { // 匹配成功则i指针后移 if s[i] == t[j] { i ++ } // j指针后移 j ++ } // i==n则遍历完了字符串s return i == n} 盛水最多的容器题目标签： 贪心 数组 双指针 题目难度： Medium 题目描述： 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 解题思路： 盛水的多少是由短板决定的 双指针指向数组的两侧，盛水量 = 两指针距离 * 短边的高度 移动指针的时候移动短板侧的指针，指针收缩后两指针的距离肯定会变小，移动短板的指针才有可能获得最大的盛水量 代码实现： 123456789101112131415161718192021222324func maxArea(height []int) int { // 双指针 left := 0 right := len(height) - 1 // 存储容量 maxV := 0 // 两指针之间必须有距离 for left &lt; right { if height[left] &lt; height[right] { maxV = max(maxV, (right - left) * height[left]) left ++ } else { maxV = max(maxV, (right-left) * height[right]) right -- } } return maxV}func max(a, b int) int { if a &gt; b { return a } return b} K和数对的最大数目题目标签： 哈希表 数组 双指针 题目难度： Medium 题目描述： 给你一个整数数组 nums 和一个整数 k 。 每一步操作中，你需要从数组中选出和为 k 的两个整数，并将它们移出数组。 返回你可以对数组执行的最大操作数。 解题思路： 可以将数组先进行排序，然后采用双指针方法解题最清晰 双指针指向数组首尾，如果两个值加起来为 k， 就记录一次，如果小于 k， 则移动首指针，否则移动尾指针 代码实现： 12345678910111213141516171819202122func maxOperations(nums []int, k int) int { // 排序 sort.Ints(nums) count := 0 left := 0 right := len(nums) - 1 for left &lt; right { // == k 统计一次，更新指针位置 if nums[left] + nums[right] == k { count ++ left ++ right -- // &lt; k 更新左指针 } else if nums[left] + nums[right] &lt; k { left ++ // &gt; k 更新右指针 } else { right -- } } return count}","link":"/2024/02/08/LeetCode75%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"title":"Nestjs的中间件使用","text":"中间件函数可以访问请求和响应对象，以及应用程序请求响应周期中的 next() 中间件函数。 中间件函数可以执行以下任务: 执行任何代码。 对请求和响应对象进行更改。 结束请求-响应周期。 调用堆栈中的下一个中间件函数。 如果当前的中间件函数没有结束请求-响应周期, 它必须调用 next() 将控制传递给下一个中间件函数。否则, 请求将被挂起。 搭建简单中间件Nest中间件的要求: 函数或具有 @Injectable() 装饰器的类 类应该实现 NestMiddleware 接口, 而函数没有特殊的要求 比如我们使用类的方式实现一个logger中间件logger.middleware.ts，在请求之前打印Request... NestMiddleware接口要求我们实现use方法，其类型定义为 123export interface NestMiddleware&lt;TRequest = any, TResponse = any&gt; { use(req: TRequest, res: TResponse, next: (error?: Error | any) =&gt; void): any;} 1234567891011// logger.middleware.tsimport { Injectable, NestMiddleware } from '@nestjs/common';import { Request, Response, NextFunction } from 'express';@Injectable()export class LoggerMiddleware implements NestMiddleware { use(req: Request, res: Response, next: NextFunction) { console.log('Request...'); next(); }} 中间件不能在 @Module() 装饰器中列出。我们必须使用模块类的 configure() 方法来设置它们。包含中间件的模块必须实现 NestModule 接口。 现在我们在app.module.ts设置中间件 为了方便后边的演示，我们继续使用之前创建的cats模块。演示过程我们只会传递一个name字段 123456789101112131415// app.module.tsimport { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';import { LoggerMiddleware } from './common/middleware/logger.middleware';import { CatsModule } from './cats/cats.module';@Module({ imports: [CatsModule],})export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LoggerMiddleware) .forRoutes('cats'); }} 在这里，我们在配置中间件时将包含路由路径的对象和请求方法传递给forRoutes()方法。 中间件还可以限制请求方法 1forRoutes({ path: 'cats', method: RequestMethod.GET }) 直接把一个控制器扔进去也是可以的 1forRoutes(CatsController) 也可以同时使用多个中间件，不论是自定义中间件还是第三方中间件： 1consumer.apply(cors(), helmet(), logger).forRoutes(CatsController); 测试中间件我们对logger.middleware.ts进行一些修改，看一下在中间件中我们能获得什么 123456789101112// logger.middleware.tsimport { Injectable, NestMiddleware } from '@nestjs/common'import { Request, Response, NextFunction } from 'express'@Injectable()export class LoggerMiddleware implements NestMiddleware { use(req: Request, res: Response, next: NextFunction) { console.log('Request...', req.body) next() }} 此时我们通过postman调试接口： 1234// localhost:3000/nest/cats/create{ &quot;name&quot;: &quot;cat&quot;} 可以看到控制台打印了如下内容： 1Request... { name: 'cat' } 那么我们能不能在中间件对请求数据进行修改呢？答案是可以。 123456789101112// logger.middleware.tsimport { Injectable, NestMiddleware } from '@nestjs/common'import { Request, Response, NextFunction } from 'express'@Injectable()export class LoggerMiddleware implements NestMiddleware { use(req: Request, res: Response, next: NextFunction) { console.log('Request...', req.body)+ req.body.name = 'named by middleware' next() }} 在cats.controller.ts中，我们也打印一下请求体 12345678910111213141516// cats.controller.tsimport { Controller, Get, Post, Body, Param } from '@nestjs/common'import { CatsService } from './cats.service'import { CreateCatDto } from './dto/create-cat.dto'import { UpdateCatDto } from './dto/update-cat.dto'@Controller('cats')export class CatsController { constructor(private readonly catsService: CatsService) {} @Post('create') createCat(@Body() createCatDto: CreateCatDto) { console.log('controller:', createCatDto) return this.catsService.createCat(createCatDto) }} 再次通过postman调试接口，可以在控制台看到如下内容： 1controller: { name: 'named by middleware' } 前边说到中间件可以对请求和响应对象进行更改，现在我们已经看到了对请求对象的修改，那么响应对象呢？ 12345678910111213// logger.middleware.tsimport { Injectable, NestMiddleware } from '@nestjs/common'import { Request, Response, NextFunction } from 'express'@Injectable()export class LoggerMiddleware implements NestMiddleware { use(req: Request, res: Response, next: NextFunction) { console.log('Request...', req.body)+ req.body.name = 'named by middleware' next() res.send('cats接口返回的内容') }} 再次通过postman调试接口，可以看到接口返回内容变成了： 1cats接口返回的内容 看到这里，是不是有人想到了通过中间件来统一返回内容的格式呢？ 实不相瞒，我最开始也是想的通过中间件来实现在nestjs中的统一格式响应，但是这个方向是错误的哦 在Nestjs中： 对于错误请求，可以使用过滤器来统一格式返回 对于成功请求，可以使用拦截器来统一格式返回 关于过滤器和拦截器的内容，放到后边讲呗。 函数中间件前边说过中间件还有函数形式呢，我们最初的那个logger中间件变成函数式是什么样子呢？ 12345// logger.middleware.tsexport function logger(req, res, next) { console.log(`Request...`); next();}; 对，没看错，就是这么简单。中间件没有任何依赖关系时，我们可以考虑使用函数式中间件。 在这里顺便说一下全局中间件吧 想一次性将中间件绑定到每个注册路由，我们可以使用由INestApplication实例提供的 use()方法，在main.ts中注册。 1234// main.tsconst app = await NestFactory.create(AppModule);app.use(logger);await app.listen(3000); 特别注意 在全局中间件访问DI容器是不可能的，所以全局中间件需要使用函数式中间件 全局中间件也可以指定多个哦","link":"/2023/02/19/Nestjs%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"title":"Nestjs基于Mongodb的简单CRUD搭建","text":"前边我们用mysql和typeorm搭建了一个基本的CRUD结构，考虑到有些朋友是使用mongodb开发的，所以我们本次用mongoose配合nestjs搭建一个基本的CRUD。 nestjs的一些基础操作在mysql那一节已经说过了，这里就直接跳过了哦 引入mongoose安装依赖： 1npm i @nestjs/mongoose mongoose 在app.module.ts引入： 123456789101112131415// app.module.tsimport { Module } from '@nestjs/common';import { MongooseModule } from '@nestjs/mongoose';@Module({ imports: [ MongooseModule.forRoot( 'mongodb://username:password@HOST:PORT', { dbName: 'db_name', }, ), ],})export class AppModule {} 不知道为何，数据库名拼接在URI上总是连不上，通过options配置就能连接了。 这次我们不用上次的books目录了，通过nest g res cats创建一个新的模块进行开发。 创建schema 1234567891011121314151617181920212223// cat.schema.tsimport { Prop, Schema, SchemaFactory } from '@nestjs/mongoose'import { HydratedDocument } from 'mongoose'export type CatDocument = HydratedDocument&lt;Cat&gt;@Schema() // @Schema标记类为一个Schemaexport class Cat { @Prop({ required: true }) name: string @Prop() age: number @Prop() breed: string @Prop([String]) // 复杂类型无法自动推断则需要指定 tags: string[]}export const CatSchema = SchemaFactory.createForClass(Cat) 在cats.module.ts中引入： 12345678910111213// cats.module.tsimport { Module } from '@nestjs/common'import { MongooseModule } from '@nestjs/mongoose'import { CatsService } from './cats.service'import { CatsController } from './cats.controller'import { Cat, CatSchema } from './schemas/cat.schema'@Module({ imports: [MongooseModule.forFeature([{ name: Cat.name, schema: CatSchema }])], controllers: [CatsController], providers: [CatsService],})export class CatsModule {} 现在就可以在cats.service.ts中注册使用了 123456789101112// cats.service.tsimport { Injectable } from '@nestjs/common'import { CreateCatDto } from './dto/create-cat.dto'import { UpdateCatDto } from './dto/update-cat.dto'import { InjectModel } from '@nestjs/mongoose'import { Cat, CatDocument } from './schemas/cat.schema'import { Model } from 'mongoose'@Injectable()export class CatsService { constructor(@InjectModel(Cat.name) private catModel: Model&lt;CatDocument&gt;) {}} CRUD实现 这里直接放代码了，与mysql的差不多，真正的差异也是typeorm和mongoose，不在这里讲这个。 dto的代码不放了，大家自己创建即可 12345678910111213141516171819202122232425262728293031323334353637// cats.controller.tsimport { Controller, Get, Post, Body, Param } from '@nestjs/common'import { CatsService } from './cats.service'import { CreateCatDto } from './dto/create-cat.dto'import { UpdateCatDto } from './dto/update-cat.dto'@Controller('cats')export class CatsController { constructor(private readonly catsService: CatsService) {} @Post('create') createCat(@Body() createCatDto: CreateCatDto) { return this.catsService.createCat(createCatDto) } @Post('update') updateCat(@Body() updateCatDto: UpdateCatDto) { return this.catsService.updateCat(updateCatDto) } @Get('findAll') findAllCat() { return this.catsService.findAllCat() } @Get('findOne/:id') findOneCat(@Param('id') id: string) { return this.catsService.findOneCat(id) } @Get('delete/:id') deleteCat(@Param('id') id: string) { return this.catsService.deleteCat(id) }} 12345678910111213141516171819202122232425262728293031323334353637383940// cats.service.tsimport { Injectable } from '@nestjs/common'import { CreateCatDto } from './dto/create-cat.dto'import { UpdateCatDto } from './dto/update-cat.dto'import { InjectModel } from '@nestjs/mongoose'import { Cat, CatDocument } from './schemas/cat.schema'import { Model } from 'mongoose'@Injectable()export class CatsService { constructor(@InjectModel(Cat.name) private catModel: Model&lt;CatDocument&gt;) {} createCat(createCatDto: CreateCatDto): Promise&lt;Cat&gt; { const createdCat = new this.catModel(createCatDto) return createdCat.save() } async updateCat(updateCatDto: UpdateCatDto): Promise&lt;Cat&gt; { const updatedRes = await this.catModel.findByIdAndUpdate(updateCatDto.id, { $set: { name: updateCatDto.name, age: updateCatDto.age }, }) return updatedRes } async findAllCat(): Promise&lt;Cat[]&gt; { const res = await this.catModel.find().exec() return res } async findOneCat(id: string): Promise&lt;Cat&gt; { const res = await this.catModel.findById(id).exec() return res } async deleteCat(id: string) { const res = await this.catModel.findByIdAndDelete(id) return res }}","link":"/2023/02/18/Nestjs%E5%9F%BA%E4%BA%8EMongodb%E7%9A%84%E7%AE%80%E5%8D%95CRUD%E6%90%AD%E5%BB%BA/"},{"title":"Nestjs的守卫和拦截器","text":"这一节本来是想说守卫和权限(RBAC)的，但是我们还没做登录和验证(JWT)，直接说权限感觉顺序有点错乱了，但是验证这里呢又用到了守卫，所以这一节先说一下守卫和拦截器，他们放到一起因为都用到了同一个上下文ExecutionContext。下一节我们在说一下上下文的相关内容，然后再讲JWT和RBAC吧。 守卫守卫是一个使用 @Injectable() 装饰器的类。 守卫应该实现 CanActivate 接口。 守卫是用来根据运行时出现的某些条件来确定给定的请求是否由路由处理程序处理 守卫在每个中间件之后执行，但在任何拦截器或管道之前执行。 CanActivate接口定义： 1234567891011export interface CanActivate { /** * @param context Current execution context. Provides access to details about * the current request pipeline. * * @returns Value indicating whether or not the current request is allowed to * proceed. */ canActivate(context: ExecutionContext): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt;;} 必须实现一个canActivate方法，接收一个上下文，然后同步或异步的返回一个布尔值。如果为true则路由处理程序会处理用户调用，否则将忽略当前请求。 ExecutionContext是ArgumentHost的扩展，在这里不展开讲。 因为咱们还没有做登录鉴权，所以咱们通过模拟数据来演示一下守卫的用法 先创建roles.guard.ts： 123456789101112131415161718192021// roles.guard.tsimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'import { Reflector } from '@nestjs/core'@Injectable()export class RolesGuard implements CanActivate { constructor(private reflector: Reflector) {} canActivate(context: ExecutionContext): boolean { // 读取元数据 const roles = this.reflector.get&lt;string[]&gt;('roles', context.getHandler()) if (!roles) { return true } const request = context.switchToHttp().getRequest() // 从请求头中获取role属性 const user = request.headers.role // 判断是否符合我们要求的角色 return roles.includes(user) }} 将守卫绑定到控制器phones.controller.ts： 12345678910111213141516171819202122232425// phones.controller.tsimport { Controller, Get, Post, Body, UseGuards, SetMetadata,} from '@nestjs/common'import { PhonesService } from './phones.service'import { CreatePhoneDto } from './dto/create-phone.dto'import { RolesGuard } from './roles.guard'@Controller('phones')@UseGuards(RolesGuard) // 绑定守卫export class PhonesController { constructor(private readonly phonesService: PhonesService) {} @Post('create') @SetMetadata('roles', ['admin']) // 设置路由元数据 createPhone(@Body() createPhoneDto: CreatePhoneDto) { return 'success' }} 守卫与过滤器等类似，可以通过@UseGuards装饰器绑定到一个控制器或者一个处理程序，也可以通过useGlobalGuards绑定到全局。 我们在调试接口到时候往请求头塞入一个role属性 1234// localhost:3000/nest/phones/create&quot;headers&quot;: { &quot;role&quot;: &quot;root&quot;} 接收到的响应为： 12345{ &quot;statusCode&quot;: 403, &quot;message&quot;: &quot;Forbidden resource&quot;, &quot;error&quot;: &quot;Forbidden&quot;} 我们将role设置为admin再次尝试： 1234// localhost:3000/nest/phones/create&quot;headers&quot;: { &quot;role&quot;: &quot;admin&quot;} 响应为： 1success 这样一来，我们能大概知道守卫的作用与用法了，当然真是的授权守卫要麻烦的多，我们放到后边RBAC的部分再说。 拦截器拦截器是使用 @Injectable() 装饰器注解的类。拦截器应该实现 NestInterceptor 接口。可以实现： 在函数执行之前/之后绑定额外的逻辑 转换从函数返回的结果 转换从函数抛出的异常 扩展基本函数行为 根据所选条件完全重写函数 (例如, 缓存目的) 1234567891011export interface NestInterceptor&lt;T = any, R = any&gt; { /** * Method to implement a custom interceptor. * * @param context an `ExecutionContext` object providing methods to access the * route handler and class about to be invoked. * @param next a reference to the `CallHandler`, which provides access to an * `Observable` representing the response stream from the route handler. */ intercept(context: ExecutionContext, next: CallHandler&lt;T&gt;): Observable&lt;R&gt; | Promise&lt;Observable&lt;R&gt;&gt;;} 自定义拦截器我们创建一个response.interceptor.ts: 123456789101112131415161718// response.interceptor.tsimport { Injectable, NestInterceptor, ExecutionContext, CallHandler,} from '@nestjs/common'import { Observable } from 'rxjs'import { tap } from 'rxjs/operators'@Injectable()export class ResponseInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; { console.log('路由处理程序运行之前') return next.handle().pipe(tap(() =&gt; console.log(`路由处理程序运行之后`))) }} 目前只是具备打印功能，让我们以此来看一下执行流程 pipe(), tap()这些操作符需要查阅rxjs来学习哦。 在phones.controller.ts中绑定拦截器 1234567891011121314151617181920212223// import { Controller, Get, Post, Body, UseInterceptors,} from '@nestjs/common'import { PhonesService } from './phones.service'import { CreatePhoneDto } from './dto/create-phone.dto'import { ResponseInterceptor } from './res.interceptor'@Controller('phones')export class PhonesController { constructor(private readonly phonesService: PhonesService) {} @Post('create') @UseInterceptors(ResponseInterceptor) createPhone(@Body() createPhoneDto: CreatePhoneDto) { console.log('路由处理程序运行') return 'success' }} 此时我们调用接口localhost:3000/nest/phones/create，查看控制台打印内容： 123路由处理程序运行之前路由处理程序运行路由处理程序运行之后 至此，拦截器的执行顺序应该能理解了。 在处理函数执行前后添加额外操作我们对拦截器进行改造，将传入数据的body中的name进行修改，并对响应内容进行了格式化。 12345678910111213141516171819202122232425262728// response.interceptor.tsimport { Injectable, NestInterceptor, ExecutionContext, CallHandler,} from '@nestjs/common'import { Observable } from 'rxjs'import { map } from 'rxjs/operators'@Injectable()export class ResponseInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; { // 拿到请求体进行修改 const request = context.switchToHttp().getRequest() const reqBody = request.body reqBody.name = 'named by interceptor' return next.handle().pipe( // 将响应内容格式化 map(data =&gt; ({ success: true, code: 200, data, })), ) }} 在phones.controller.ts中也进行一些修改，直接将接收到的数据返回： 123456// phones.controller.ts@Post('create')@UseInterceptors(ResponseInterceptor)createPhone(@Body() createPhoneDto: CreatePhoneDto) { return createPhoneDto} 此时我们访问接口并传入数据： 123456// localhost:3000/nest/phones/create{ &quot;name&quot;: &quot;Iphone14&quot;, &quot;brand&quot;: &quot;Apple&quot;, &quot;ram&quot;: 4} 响应结果为： 123456789{ &quot;success&quot;: true, &quot;code&quot;: 200, &quot;data&quot;: { &quot;name&quot;: &quot;named by interceptor&quot;, &quot;brand&quot;: &quot;Apple&quot;, &quot;ram&quot;: 4 }} 到这里大家应该知道怎么通过拦截器来统一格式化返回内容了。 拦截器也一样，有控制器范围、方法范围和全局范围生效的。 map()方法也是rxjs内容，需要自行学习哦，本人暂时对于rxjs没有太多接触，不敢乱说。如果后续对rxjs的学习有一些新的也会进行分享。","link":"/2023/02/24/Nestjs%E7%9A%84%E5%AE%88%E5%8D%AB%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"title":"Nestjs的过滤器使用","text":"在前边的中间件章节我们说到过，异常的统一格式处理是通过异常过滤器来实现的，这一节我们就看看异常过滤器的内容。 异常层负责处理整个应用程序中的所有抛出的异常。当捕获到未处理的异常时，最终用户将收到友好的响应。 异常初始HttpException基础异常类Nest提供了一个内置的 HttpException 类，我们新建一个模块courses，在这里硬编码抛出一个异常试一下： courses模块无实际内容，只是拿一个controller来演示过滤器，无需关注太多 123456789101112131415161718// courses.controller.tsimport { Controller, Get, HttpException, HttpStatus,} from '@nestjs/common'import { CoursesService } from './courses.service'@Controller('courses')export class CoursesController { constructor(private readonly coursesService: CoursesService) {} @Get('findAll') findAll(): string { throw new HttpException('Bad Request', HttpStatus.BAD_REQUEST) }} HttpStatus是一个Nest内置的枚举，我们通过他来指定状态码。 我们访问这个接口会得到如下内容： 12345// localhost:3000/nest/courses/findAll{ &quot;statusCode&quot;: 400, &quot;message&quot;: &quot;Bad Request&quot;} 我们对HttpException构造函数传递了两个参数，第二个参数是一个状态码，很好理解，来看一下第一个参数吧： 第一个参数可以是一个字符串或者一个对象 第一个参数如果是一个字符串，那么会使用HttpException的默认格式返回，就是上边的这种 如果是一个对象的话nest会将其序列化作为json返回 假如我们传入的是一个对象： 1234567891011121314151617181920212223// courses.controller.tsimport { Controller, Get, HttpException, HttpStatus,} from '@nestjs/common'import { CoursesService } from './courses.service'@Controller('courses')export class CoursesController { constructor(private readonly coursesService: CoursesService) {} @Get('findAll') findAll(): string { throw new HttpException( { message: 'bad request', error: 'BAD_REQUEST', }, HttpStatus.BAD_REQUEST, ) }} 此时访问该接口： 12345// localhost:3000/nest/courses/findAll{ &quot;message&quot;: &quot;bad request&quot;, &quot;error&quot;: &quot;BAD_REQUEST&quot;} 可以发现，这次返回结果就是我们传入的对象，而不是其默认格式了。 自定义异常前边说了异常基础类HttpException，基于此，我们可以创建自己的自定义异常 12345678910111213// bad-request.exception.tsimport { HttpException, HttpStatus } from '@nestjs/common'export class DiyBadRequestException extends HttpException { constructor() { super( { message: 'bad request', error: 'BAD_REQUEST', }, HttpStatus.BAD_REQUEST, ) }} 我们在courses.controller.ts中使用这个自定义异常： 1234567891011121314151617181920212223// courses.controller.tsimport { Controller, Get,} from '@nestjs/common'import { CoursesService } from './courses.service'import { DiyBadRequestException } from './bad-request.exception'@Controller('courses')export class CoursesController { constructor(private readonly coursesService: CoursesService) {} @Get('findAll') findAll(): string { // throw new HttpException( // { // message: 'bad request', // error: 'BAD_REQUEST', // }, // HttpStatus.BAD_REQUEST, // ) throw new DiyBadRequestException() }} 此时访问接口，我们发现可以得到相同的响应内容 内置HTTP异常Nest 提供了一系列继承自核心异常 HttpException 的内置HTTP异常 其中包括： BadRequestException UnauthorizedException NotFoundException ForbiddenException NotAcceptableException RequestTimeoutException ConflictException GoneException PayloadTooLargeException UnsupportedMediaTypeException UnprocessableException InternalServerErrorException NotImplementedException BadGatewayException ServiceUnavailableException GatewayTimeoutException 所以HTTP异常，我们就没必要再去自定义了，比如： 1234567891011121314151617181920// courses.controller.tsimport { Controller, Get, BadRequestException,} from '@nestjs/common'import { CoursesService } from './courses.service'@Controller('courses')export class CoursesController { constructor(private readonly coursesService: CoursesService) {} @Get('findAll') findAll(): string { throw new BadRequestException({ message: 'bad request', error: 'BAD_REQUEST', }) }} 访问接口，我们依然能得到相同的响应。 异常过滤器前边我们说的通过过滤器来统一返回错误内容，接下来就看一下吧。 HTTP异常过滤器我们先来创建一个过滤器，统一处理HTTP异常的返回内容。 1234567891011121314151617181920212223242526// http-exception.filter.tsimport { ExceptionFilter, Catch, ArgumentsHost, HttpException,} from '@nestjs/common'import { Request, Response } from 'express'@Catch(HttpException)export class HttpExceptionFilter implements ExceptionFilter { catch(exception: HttpException, host: ArgumentsHost) { const ctx = host.switchToHttp() const response = ctx.getResponse&lt;Response&gt;() const request = ctx.getRequest&lt;Request&gt;() const status = exception.getStatus() // controller抛出的异常内容 const exceptionRes = exception.getResponse() response.status(status).json({ timestamp: new Date().toLocaleString(), path: request.url, ...(&lt;any&gt;exceptionRes), }) }} 所有异常过滤器都应该实现通用的 ExceptionFilter&lt;T&gt; 接口。它需要你使用有效签名提供 catch(exception: T, host: ArgumentsHost)方法。T 表示异常的类型。 @Catch() 装饰器绑定所需的元数据到异常过滤器上。它告诉 Nest这个特定的过滤器正在寻找 HttpException 而不是其他的。在实践中，@Catch() 可以传递多个参数，所以你可以通过逗号分隔来为多个类型的异常设置过滤器。 ArgumentsHost是一个应用上下文，还有一个基于ArgumentsHost扩展出来的执行上下文ExecutionContext，后者在守卫、拦截器中常用，在这里不展开讲，只看一下其基础用法即可。 在异常过滤器中，我们可以通过exception.getResponse()来拿到我们抛出的异常中的响应内容，然后通过response来格式化返回。 接下来让我们将 HttpExceptionFilter 绑定到CoursesController中使用。 12345678910111213141516171819202122// courses.controller.tsimport { Controller, Get, UseFilters, BadRequestException,} from '@nestjs/common'import { CoursesService } from './courses.service'import { HttpExceptionFilter } from '../http-exception.filter'@Controller('courses')export class CoursesController { constructor(private readonly coursesService: CoursesService) {} @Get('findAll') @UseFilters(HttpExceptionFilter) findAll(): string { throw new BadRequestException({ message: 'bad request', error: 'BAD_REQUEST', }) }} 通过UseFilters绑定过滤器，可以绑定多个。 此时访问接口： 1234567// localhost:3000/nest/courses/findAll{ &quot;timestamp&quot;: &quot;2023/2/20 15:21:30&quot;, &quot;path&quot;: &quot;/nest/courses/findAll&quot;, &quot;message&quot;: &quot;bad request&quot;, &quot;error&quot;: &quot;BAD_REQUEST&quot;} 可以看到，已经将响应内容处理成我们想要的样子了。 在前边的例子中，我们将过滤器绑定到单个路由，其实过滤器也可以绑定到一个控制器： 12345// courses.controller.ts@Controller('courses')@UserFilters(HttpExceptionFilter)export class CoursesController {} 相信大家已经猜到了，过滤器也可以绑定到全局，实现全局处理： 1234567// main.tsasync function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalFilters(new HttpExceptionFilter()); await app.listen(3000);}bootstrap(); 捕获任意异常将 @Catch() 装饰器的参数列表设为空，可以捕获任意未处理的异常。 1234567891011121314151617181920212223242526// all-exception.filter.tsimport { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus,} from '@nestjs/common';@Catch()export class AllExceptionsFilter implements ExceptionFilter { catch(exception: unknown, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse(); const request = ctx.getRequest(); // 如果是HttpException，我们可以获取到状态码，否则500 const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR; response.status(status).json({ timestamp: new Date().toISOString(), path: request.url, }); }","link":"/2023/02/20/Nestjs%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BD%BF%E7%94%A8/"},{"title":"Nestjs的管道与DTO验证","text":"在之前的搭建CRUD代码内容中，我们提到过管道配合class-validator做验证，这一节我们来看一下什么是管道，以及验证的一个流程。 我们先通过nest g res phones --no-spec生成一个新的模块并将其controller与service中的预置内容清空掉，至于entity与dto暂时先不关注，我们先通过简单示例来说一下管道。 初始代码内容如下： 123456789101112131415161718// phones.controller.tsimport { Controller, Get, Post, Body, Patch, Param, Delete,} from '@nestjs/common'import { PhonesService } from './phones.service'import { CreatePhoneDto } from './dto/create-phone.dto'import { UpdatePhoneDto } from './dto/update-phone.dto'@Controller('phones')export class PhonesController { constructor(private readonly phonesService: PhonesService) {}} 1234567// phones.service.tsimport { Injectable } from '@nestjs/common'import { CreatePhoneDto } from './dto/create-phone.dto'import { UpdatePhoneDto } from './dto/update-phone.dto'@Injectable()export class PhonesService {} 管道管道有两个典型的应用场景: 转换：管道将输入数据转换为所需的数据输出(例如，将字符串转换为整数) 验证：对输入数据进行验证，如果验证成功继续传递; 验证失败则抛出异常 Nest 自带九个开箱即用的管道，即 ValidationPipe ParseIntPipe ParseFloatPipe ParseBoolPipe ParseArrayPipe ParseUUIDPipe ParseEnumPipe DefaultValuePipe ParseFilePipe 转换管道ParseIntPipe先来看一个用法简单的管道ParseIntPipe，我们如果想要在方法参数级别绑定管道，实现管道与特定的路由处理程序方法相关联，并确保它在该方法被调用之前运行，可以通过如下方式： 1234567891011121314151617181920212223242526// phones.controller.tsimport { Controller, Get, Post, Body, Patch, Param, Delete, ParseIntPipe,} from '@nestjs/common'import { PhonesService } from './phones.service'import { CreatePhoneDto } from './dto/create-phone.dto'import { UpdatePhoneDto } from './dto/update-phone.dto'@Controller('phones')export class PhonesController { constructor(private readonly phonesService: PhonesService) {} @Get('findBy/:ram') findByRam(@Param('ram', ParseIntPipe) ram: number) { return { ram, ramType: typeof ram, } }} 接下来调试接口： 12345// localhost:3000/nest/phones/findBy/8{ &quot;ram&quot;: 8, &quot;ramType&quot;: &quot;number&quot;} 我们传递了一个param参数，毫无疑问ram参数是一个字符串，但我们得到的结果，ram参数是一个number，这就是ParseIntPie的能力。 如果不能转换为数值会怎么样呢？ 123456// localhost:3000/nest/phones/findBy/abc{ &quot;statusCode&quot;: 400, &quot;message&quot;: &quot;Validation failed (numeric string is expected)&quot;, &quot;error&quot;: &quot;Bad Request&quot;} 答案是会抛出一个错误，将abc转换为数值本就不可能的。截一段ParseIntPipe的源码，内部transform的实现： 123456async transform(value, metadata) { if (!this.isNumeric(value)) { throw this.exceptionFactory('Validation failed (numeric string is expected)'); } return parseInt(value, 10);} 现在肯定有人有疑问，我们之前绑定内容都是用的@UserXXXX装饰器，为什么管道不是这样呢？其实管道绑定也有一个@UserPipes装饰器，我们后边会说，这里这么用因为比较方便，可以看一下@Param的类型声明就懂了： 12// @Paramexport declare function Param(property: string, ...pipes: (Type&lt;PipeTransform&gt; | PipeTransform)[]): ParameterDecorator; 其他的一些转换管道其实是查不多的，我们来大概看一下。 ParseFloatPipecontroller实现： 12345678// phones.controller.ts@Get('parseFloat/:n')parseFloat(@Param('n', ParseFloatPipe) n: number) { return { n, dataType: typeof n, }} 调试接口测试： 12345// localhost:3000/nest/phones/parseFloat/1.2345{ &quot;n&quot;: 1.2345, &quot;dataType&quot;: &quot;number&quot;} ParseBoolPipecontroller实现： pipe不仅可以应用于param，query和body装饰器也是可以的 12345678// phones.controller.ts@Get('parseBool')parseBool(@Query('flag', ParseBoolPipe) flag: boolean) { return { flag, dataType: typeof flag, }} 调试接口： 12345// localhost:3000/nest/phones/parseBool?flag=false{ &quot;flag&quot;: false, &quot;dataType&quot;: &quot;boolean&quot;} ParseArrayPipecontroller实现： 12345678// phones.controller.ts@Get('parseArray')parseArray(@Query('array', ParseArrayPipe) array: string[]) { return { array, dataType: typeof array, }} 调试接口： 1234567891011// localhost:3000/nest/phones/parseArray?array=a,b,c,d,e{ &quot;array&quot;: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ], &quot;dataType&quot;: &quot;object&quot;} 不难发现，ParseArrayPipe默认是以,分割字符串实现的。 可以以其他字符来分割吗？当然可以，看一下其声明文件就能发现了，我们可以传入配置项，不过这样的话我们就要注入一个实例，而不是一个类了。 12345678910// phones.controller.ts@Get('parseArray')parseArray( @Query('array', new ParseArrayPipe({ separator: '.' })) array: string[], ) { return { array, dataType: typeof array, } } 以.分割字符调试接口： 1234567891011// localhost:3000/nest/phones/parseArray?array=a.b.c.d.e{ &quot;array&quot;: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ], &quot;dataType&quot;: &quot;object&quot;} 能得到同样的响应内容。 ParseUUIDPipeParseUUIDPipe应该算是转换管道还是验证管道呢？看一下其transform方法实现能发现，如果参数不是uuid会抛出错误，如果是uuid则将这个值返回，看起来好像是一个验证管道哦。不过既然命名为ParseXXXXPipe应该还是转换管道的。是否可以理解为，将字符串转换为uuid，失败则抛出错误。 1234567// ParseUUIDPipe的transform实现async transform(value, metadata) { if (!this.isUUID(value, this.version)) { throw this.exceptionFactory(`Validation failed (uuid${this.version ? ` v ${this.version}` : ''} is expected)`); } return value;} 很简单，就不演示了吧。 ParseEnumPipeparseEnumPipe用来判断你传入的参数是否是一个枚举值，我们先创建一个枚举： 12345enum Brand { APPLE = 'apple', HUAWEI = 'huawei', SAMSUNG = 'samsung',} controller实现： 1234567@Get('parseEnum')parseEnum(@Query('brand', new ParseEnumPipe(Brand)) brand: string) { return { brand, dataType: typeof brand, }} 调试接口： 12345// localhost:3000/nest/phones/parseEnum?brand=samsung{ &quot;brand&quot;: &quot;samsung&quot;, &quot;dataType&quot;: &quot;string&quot;} samsung确实是我们的一个枚举值，如果我们传入一个错误的值呢？ 123456// localhost:3000/nest/phones/parseEnum?brand=xiaomi{ &quot;statusCode&quot;: 400, &quot;message&quot;: &quot;Validation failed (enum string is expected)&quot;, &quot;error&quot;: &quot;Bad Request&quot;} 这就是ParseEnumPipe的用途。 自定义管道每个管道必须要实现的泛型接口PipeTransform&lt;T, R&gt;，泛型 T 表明输入的 value 的类型，R 表明 transfrom() 方法的返回类型。 12345678910// PipeTransform接口export interface PipeTransform&lt;T = any, R = any&gt; { /** * Method to implement a custom pipe. Called with two parameters * * @param value argument before it is received by route handler method * @param metadata contains metadata about the value */ transform(value: T, metadata: ArgumentMetadata): R;} 不难发现每个管道都要实现transform方法，该方法接受两个参数： value：当前处理的方法参数 metadata：当前处理的方法参数的元数据 什么是元数据呢？可以看一下ArgumentMetadata的类型声明： 1234567891011121314151617// ArgumentMetadataexport interface ArgumentMetadata { /** * 告诉我们参数是一个 body @Body()，query @Query()，param @Param() 还是自定义参数 */ readonly type: Paramtype; /** * 参数的元类型，例如 String。 * 如果在函数签名中省略类型声明，或者使用原生 JavaScript，则为 undefined。 */ readonly metatype?: Type&lt;any&gt; | undefined; /** * 传递给装饰器的字符串，例如 @Body('string') * 如果您将括号留空，则为 undefined。 */ readonly data?: string | undefined;} 上边的内容可能看起来不太容易懂，来一个小demo看一下就好了 我们新建double.pipe.ts来创建一个管道： 12345678910111213// double.pipe.tsimport { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common'@Injectable()export class DoublePipe implements PipeTransform { transform(value: any, metadata: ArgumentMetadata) { console.log('value:', value) console.log('type:', metadata.type) console.log('metatype:', metadata.metatype) console.log('data:', metadata.data) return value }} 在phones.controller.ts中应用这个管道： 12345// phones.controller.ts@Get('diyPipe')diyPipe(@Query('num', DoublePipe) num: string) { return 'success'} 现在我们访问接口http://localhost:3000/nest/phones/diyPipe?num=1234。此时我们看一下控制台的打印内容： 1234value: 1234type: querymetatype: [Function: String]data: num 我们依次来看： value：就是我们通过query传递的实际内容 type：因为我们使用`@Query装饰器，所以type是query data：我们给@Query装饰器传入了'num'，所以data是num metatype：为什么是[Function: String]，以为我们在controller给num参数声明类型为string。 现在我们知道参数都是什么了，那我们让这个管道，实现将传入内容乘以2的效果： 我们这里没有考虑各种条件，而是直接乘以2返回了，如果想做好，可以参考ParseIntPipe的实现 12345678910// double.pipe.tsimport { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common'@Injectable()export class DoublePipe implements PipeTransform { transform(value: any, metadata: ArgumentMetadata) { // 不考虑各种条件，默认传入的是一个数值或字符串类型的数值 return parseInt(value, 10) * 2 }} 在controller中应用： 1234567// phones.controller.ts@Get('diyPipe')diyPipe(@Query('num', DoublePipe) num: string) { return { double: num, }} 现在调试接口： 1234// localhost:3000/nest/phones/diyPipe?num=1234{ &quot;double&quot;: 2468} 验证管道在之前的使用MySql搭建CRUD代码的文章中我们在最后提了一嘴dto验证，现在我们学过了管道的知识再来看一下验证管道的内容。 在之前我们是实现了一个自定义管道，其实Nestjs有内置的ValidationPipe，这一次我们就使用内置管道来实现验证功能。 由于此管道使用了 class-validator 和 class-transformer 库，所以需要先安装依赖： 1$ npm i --save class-validator class-transformer ValidationPipe的构造函数接受一个可选的配置项： 1234567891011export interface ValidationPipeOptions extends ValidatorOptions { transform?: boolean; disableErrorMessages?: boolean; transformOptions?: ClassTransformOptions; errorHttpStatusCode?: ErrorHttpStatusCode; exceptionFactory?: (errors: ValidationError[]) =&gt; any; validateCustomDecorators?: boolean; expectedType?: Type&lt;any&gt;; validatorPackage?: ValidatorPackage; transformerPackage?: TransformerPackage;} 继承自ValidatorOptions的配置项还有很多，声明的是class-validator可用选项，关于那些请查看class-validator文档。 我们将管道绑定到全局，这样方便我们演示： 1234567// main.tsasync function bootstrap() { const app = await NestFactory.create(ApplicationModule); app.useGlobalPipes(new ValidationPipe()); await app.listen(3000);}bootstrap(); 验证Body我们创建create-phone.dto.ts： 1234567891011121314151617181920212223242526// create-phone.dto.tsimport { IsString, IsNotEmpty, IsOptional, IsNumber, IsBoolean,} from 'class-validator'export class CreatePhoneDto { @IsNotEmpty({ message: '不能为空' }) @IsString({ message: 'name为string类型' }) name: string @IsNotEmpty({ message: '不能为空' }) @IsString({ message: 'name为string类型' }) brand: string @IsOptional() @IsNumber({ allowNaN: false }, { message: 'ram为number' }) ram: number @IsOptional() @IsNumber({ allowNaN: false }, { message: 'ram为number' }) rom: number @IsOptional() @IsBoolean({ message: 'isActive是boolean类型' }) isActive: boolean} 在controller中创建一个路由程序处理请求： 12345// phones.controller.ts@Post('create')createPhone(@Body() createPhoneDto: CreatePhoneDto) { return createPhoneDto} 我们先通过一个不合规的数据请求接口： 12345// localhost:3000/nest/phones/create{ &quot;brand&quot;: &quot;Apple&quot;, &quot;ram&quot;: 4} 得到响应如下： 12345678{ &quot;statusCode&quot;: 400, &quot;message&quot;: [ &quot;name为string类型&quot;, &quot;不能为空&quot; ], &quot;error&quot;: &quot;Bad Request&quot;} 这样我们就实现一个简单的dto验证了。 验证ParamValidationPipe不仅能对Body进行验证，其他请求数据也是可以的： 我们新建一个find-phone.dto.ts： 123456// find-phone.dto.tsimport { IsNumberString } from 'class-validator'export class FindPhoneDto { @IsNumberString() id: string} 在controller中应用： 12345// phones.controller.ts@Get('find/:id')findById(@Param() findPhoneDto: FindPhoneDto) { return findPhoneDto} 剥离属性 ValidationPipe 还可以过滤掉方法处理程序不应该接收的属性。在这种情况下，我们可以对可接受的属性进行白名单，白名单中不包含的任何属性都会自动从结果对象中删除。 先来看一下不使用白名单的情况来调用创建接口： 1234567// localhost:3000/nest/phones/create{ &quot;name&quot;: &quot;Iphone14&quot;, &quot;brand&quot;: &quot;Apple&quot;, &quot;ram&quot;: 4, &quot;remark&quot;: &quot;color pink&quot;} 由于我们的处理程序直接将接收到的内容返回了，所以响应如下： 123456{ &quot;name&quot;: &quot;Iphone14&quot;, &quot;brand&quot;: &quot;Apple&quot;, &quot;ram&quot;: 4, &quot;remark&quot;: &quot;color pink&quot;} 现在我们开启白名单功能： 1234567891011// main.tsasync function bootstrap() { const app = await NestFactory.create(AppModule) app.setGlobalPrefix('nest') app.useGlobalPipes( new ValidationPipe({+ whitelist: true, }), ) await app.listen(3000)} 此时同样发送请求得到的响应为： 12345{ &quot;name&quot;: &quot;Iphone14&quot;, &quot;brand&quot;: &quot;Apple&quot;, &quot;ram&quot;: 4} 可以发现，开启白名单之后，只会接收dto中定义的属性，其余无关属性会过滤掉。 映射类型我们有了创建实例的dto，可能还会有一个用于更新的dto。在更新的时候我们可以复用create-phone.dto.ts中的内容，且更新过程中可能所有字段都是可选的，Nest 提供了 PartialType() 函数来让这个任务变得简单。 我们创建一个update-phone.dto.ts： 12345678910// update-phone.dto.tsimport { PartialType } from '@nestjs/mapped-types'import { IsNotEmpty } from 'class-validator'import { CreatePhoneDto } from './create-phone.dto'export class UpdatePhoneDto extends PartialType(CreatePhoneDto) { @IsNotEmpty({ message: '请传入phone的id' }) id: string} 现在我们执行更新操作时，传入的body必须有一个id属性，还可以拥有任何create-phone.dto.ts中定义的属性。 除了PartialType函数，Nest还提供了几个函数方便构建dto格式： PickType()：通过挑出输入类型的一组属性构造一个新的类型 OmitType() ：通过挑出输入类型中的全部属性，然后移除一组特定的属性构造一个类型 IntersectionType() ：将两个类型合并成一个类型 映射类型函数是可以组合使用的。","link":"/2023/02/22/Nestjs%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8EDTO%E9%AA%8C%E8%AF%81/"},{"title":"Nestjs使用MySql的基本CRUD搭建","text":"前边我们已经搭建了一个Nest项目，现在我们来看一下怎么写一个CRUD的项目。 NestJs基础使用我们通过运行npm run start:dev将搭建好的NestJs项目运行起来，然后看一下main.ts的内容： 123456789// main.tsimport { NestFactory } from '@nestjs/core'import { AppModule } from './app.module'async function bootstrap() { const app = await NestFactory.create(AppModule) await app.listen(3000)}bootstrap() 其他内容看不懂可以不关注，只看一行await app.listen(3000)我们可以知道服务是运行在3000端口上的，此时我们通过postman访问localhost:3000看一下： 1Hello World! 服务返回了一句字符串Hello World!，我们看一下app.controller.ts和app.service.ts，可以知道这个请求被app.controller.ts处理的，在内部调用了app.service.ts中的方法获得内容，这是一个解耦的做法，所以在后边我们也一样在controller中处理请求，在service中来处理逻辑。 我们的接口的路径肯定不能都是/，所以需要定义，在app.controller.ts中进行如下修改： 12345678910111213// app.controller.tsimport { Controller, Get } from '@nestjs/common'import { AppService } from './app.service'@Controller('app')export class AppController { constructor(private readonly appService: AppService) {} @Get('hello') getHello(): string { return this.appService.getHello() }} 可以发现我们在@Controller和@Get两个装饰器中添加了内容： @Controller('app')： 这个Controller下的所有请求都有app这个前缀 @Get('hello')： 这个请求接口的路径是hello 所以现在我们要访问这个接口应该访问的路径是http://localhost:3000/app/hello 现在我们只是控制了整个Controller的前缀，假如我们要对整个项目添加一个公共前缀比如nest怎么做呢？ 全局的操作需要在main.ts中进行处理了： 1234567891011// main.tsimport { NestFactory } from '@nestjs/core'import { AppModule } from './app.module'async function bootstrap() { const app = await NestFactory.create(AppModule)+ app.setGlobalPrefix('nest') await app.listen(3000)}bootstrap() 现在我们就需要通过http://localhost:3000/nest/app/hello来访问之前的那个接口了。 搭建CRUD代码结构我们可以通过nest g res 模块名快速生成REST CRUD代码。生成的内容默认是有测试文件的，可以添加--no-spec参数来忽略测试文件，避免文件太多干扰我这里就不生成测试文件了，在项目根目录执行nest g res books --no-spec命令，选择REST API和生成entity，我们会看到在src目录下生成了一个books目录，其内容如下： 123456789books| -- books.module.ts| -- books.controller.ts| -- books.service.ts| -- dto| | -- create-book.dto.ts| | -- update-book.dto.ts| -- entities| | -- book.entity.ts 而且我们此时去查看app.module.ts的内容，发现我们新建的books模块已经自动引入了： 123456789101112// app.module.tsimport { Module } from '@nestjs/common'import { AppController } from './app.controller'import { AppService } from './app.service'import { BooksModule } from './books/books.module'@Module({ imports: [BooksModule], controllers: [AppController], providers: [AppService],})export class AppModule {} 目前books.controller.ts与books.service.ts都已经有一些预置内容了，Nestjs帮我们生成了REST API，但是在这里为了后续的内容讲解并不准备用REST API，而是只用GET和POST请求来实现逻辑，所以我们将这两个文件的内容做一些删减变成如下模样，后边我们自己来实现CRUD接口： 12345678910// books.controller.tsimport { Controller, Get, Post, Body } from '@nestjs/common'import { BooksService } from './books.service'import { CreateBookDto } from './dto/create-book.dto'import { UpdateBookDto } from './dto/update-book.dto'@Controller('books')export class BooksController { constructor(private readonly booksService: BooksService) {}} 1234567// books.service.tsimport { Injectable } from '@nestjs/common'import { CreateBookDto } from './dto/create-book.dto'import { UpdateBookDto } from './dto/update-book.dto'@Injectable()export class BooksService {} 12345678910// books.module.tsimport { Module } from '@nestjs/common'import { BooksService } from './books.service'import { BooksController } from './books.controller'@Module({ controllers: [BooksController], providers: [BooksService],})export class BooksModule {} 如果你想使用REST API，那么在这个生成代码的基础上直接扩展是更方便的 Mysql和Typeorm引入接下来我们先不急于去实现我们的CRUD接口，后端总是要操作数据库，所以我们先来引入数据库的配置。这里用到了Mysql和Typeorm Typeorm后续只会有一些简单的应用，不必担心无法理解。 如果想全面了解Typeorm内容，请访问其官方文档进行学习。 安装所需依赖： 1npm install --save @nestjs/typeorm typeorm mysql2 接下来在app.module.ts中配置TypeOrmModule 12345678910111213141516171819202122232425262728// app.module.tsimport { Module } from '@nestjs/common'import { TypeOrmModule } from '@nestjs/typeorm'import { AppController } from './app.controller'import { AppService } from './app.service'import { BooksModule } from './books/books.module'// 引入entityimport { Book } from './books/entities/book.entity'@Module({ imports: [ TypeOrmModule.forRoot({ type: 'mysql', host: '你的ip', port: 3306, username: 'username', password: 'password', database: 'dbName', // 注册实体 entities: [Book], synchronize: true, }), BooksModule, ], controllers: [AppController], providers: [AppService],})export class AppModule {} 现在我们还没有定义实体内容，等entity定义完成之后运行项目，会自动在数据库中创建book这个表。如果表不存在会自动创建，如果字段进行了修改也会自动同步 现在我们来定义实体： 1234567891011121314151617181920212223// book.entity.tsimport { Entity, Column, PrimaryGeneratedColumn } from 'typeorm'@Entity()export class Book { @PrimaryGeneratedColumn('uuid') id: string @Column() title: string @Column() anchor: string @Column({ nullable: true, default: null, }) pageSize: number @Column({ default: true }) isActive: boolean} 通过@Entity()装饰器声明这是一个实体，@Column()用于声明列，@PrimaryGeneratedColumn('uuid')用于声明这是一个自动生成的主键且由uuid填充。 此时等待项目运行，我们查看数据库的book这个表desc book;： 12345678910+----------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+-------+| id | varchar(36) | NO | PRI | NULL | || title | varchar(255) | NO | | NULL | || anchor | varchar(255) | NO | | NULL | || pageSize | int | YES | | NULL | || isActive | tinyint | NO | | 1 | |+----------+--------------+------+-----+---------+-------+5 rows in set (0.00 sec) 此时表已经成功创建出来了。我们知道Typeorm可以通过实体来获取对应的存储库，通过这个存储库来进行数据库操作，我们在books.module.ts定义用注册的存储库： 123456789101112// books.module.tsimport { Module } from '@nestjs/common'import { BooksService } from './books.service'import { BooksController } from './books.controller'+import { TypeOrmModule } from '@nestjs/typeorm'+import { Book } from './entities/book.entity'@Module({+ imports: [TypeOrmModule.forFeature([Book])], controllers: [BooksController], providers: [BooksService],})export class BooksModule {} 接下来我们可以通过@InjectRepository()装饰器将存储库注入到service中，这样我们就可以在service中进行数据库操作了。 1234567891011121314// books.service.tsimport { Injectable } from '@nestjs/common'+import { InjectRepository } from '@nestjs/typeorm'+import { Repository } from 'typeorm'import { CreateBookDto } from './dto/create-book.dto'import { UpdateBookDto } from './dto/update-book.dto'+import { Book } from './entities/book.entity'@Injectable()export class BooksService {+ constructor(+ @InjectRepository(Book)+ private booksRepository: Repository&lt;Book&gt;,+ ) {}} CRUD操作 写在最前边，这里我们不考虑各种校验等内容，只是把CRUD操作完成 新增数据在新增之前我们实现一下create-book.dto.ts 123456789// create-book.dto.tsexport class CreateBookDto { title: string anchor: string pageSize: number isActive: boolean} 在books.controller.ts中添加接口 123456789101112131415// books.controller.tsimport { Controller, Get, Post, Body } from '@nestjs/common'import { BooksService } from './books.service'import { CreateBookDto } from './dto/create-book.dto'import { UpdateBookDto } from './dto/update-book.dto'@Controller('books')export class BooksController { constructor(private readonly booksService: BooksService) {}+ @Post('create')+ createBook(@Body() createBookDto: CreateBookDto) {+ return this.booksService.createBook(createBookDto)+ }} 在books.service.ts进行处理： typeorm可以通过save()创建数据 12345678910111213141516171819// books.service.tsimport { Injectable } from '@nestjs/common'import { InjectRepository } from '@nestjs/typeorm'import { Repository } from 'typeorm'import { CreateBookDto } from './dto/create-book.dto'import { UpdateBookDto } from './dto/update-book.dto'import { Book } from './entities/book.entity'@Injectable()export class BooksService { constructor( @InjectRepository(Book) private booksRepository: Repository&lt;Book&gt;, ) {}+ createBook(createBookDto: CreateBookDto) {+ return this.booksRepository.save(createBookDto)+ }} 此时我们使用postman访问http://localhost:3000/nest/books/create接口发送POST请求，请求体如下： 123456{ &quot;title&quot;: &quot;三国演义&quot;, &quot;anchor&quot;: &quot;罗贯中&quot;, &quot;pageSize&quot;: 30, &quot;isActive&quot;: true} 响应结果为: 1234567{ &quot;title&quot;: &quot;三国演义&quot;, &quot;anchor&quot;: &quot;罗贯中&quot;, &quot;pageSize&quot;: 30, &quot;isActive&quot;: true, &quot;id&quot;: &quot;096dd811-770d-49bb-a160-be11813e6942&quot;} 此时我们去数据库进行查询 1234567mysql&gt; select * from book;+--------------------------------------+--------------+-----------+----------+----------+| id | title | anchor | pageSize | isActive |+--------------------------------------+--------------+-----------+----------+----------+| 096dd811-770d-49bb-a160-be11813e6942 | 三国演义 | 罗贯中 | 30 | 1 |+--------------------------------------+--------------+-----------+----------+----------+1 row in set (0.00 sec) 查询数据在进行查询之前，我们往数据库又添加了几条数据： 12345678+--------------------------------------+--------------+-----------+----------+----------+| id | title | anchor | pageSize | isActive |+--------------------------------------+--------------+-----------+----------+----------+| 096dd811-770d-49bb-a160-be11813e6942 | 三国演义 | 罗贯中 | 30 | 1 || 5176c094-7c78-4aaf-ba16-488965583d09 | 西游记 | 吴承恩 | 300 | 1 || 95a5143d-f521-42ae-88cc-e5b09943db34 | 红楼梦 | 曹雪芹 | 300 | 1 || 9617e315-1f6f-48f9-b9b0-2ad9baec26ba | 水浒传 | 施耐庵 | 300 | 1 |+--------------------------------------+--------------+-----------+----------+----------+ 在books.controller.ts添加接口： 12345678910111213141516171819202122232425// books.controller.tsimport { Controller, Get, Post, Body, Param } from '@nestjs/common'import { BooksService } from './books.service'import { CreateBookDto } from './dto/create-book.dto'import { UpdateBookDto } from './dto/update-book.dto'@Controller('books')export class BooksController { constructor(private readonly booksService: BooksService) {} @Post('create') createBook(@Body() createBookDto: CreateBookDto) { return this.booksService.createBook(createBookDto) }+ @Get('findAll')+ findAllBook() {+ return this.booksService.findAllBook()+ }+ @Get('findOne/:id')+ findOneBook(@Param('id') id: string) {+ return this.booksService.findOneBook(id)+ }} 我们通过@Param装饰器来接收Param参数，如果有多个可以分开定义： @Get(‘findOne/:id/:name’) findOneBook(@Param(‘id’) id: string, @Param(‘name’) name: string) {} @Param接收两个参数，第一个参数是字段名，第二个是可选字段，用来传递管道 在books.service.ts添加处理逻辑 1234567891011121314151617181920212223242526272829// books.service.tsimport { Injectable } from '@nestjs/common'import { InjectRepository } from '@nestjs/typeorm'import { Repository } from 'typeorm'import { CreateBookDto } from './dto/create-book.dto'import { UpdateBookDto } from './dto/update-book.dto'import { Book } from './entities/book.entity'@Injectable()export class BooksService { constructor( @InjectRepository(Book) private booksRepository: Repository&lt;Book&gt;, ) {} createBook(createBookDto: CreateBookDto) { return this.booksRepository.save(createBookDto) }+ findAllBook() {+ return this.booksRepository.find()+ }+ findOneBook(id: string) {+ return this.booksRepository.findOneBy({+ id,+ })+ }} 调用http://localhost:3000/nest/books/findAll接口可得： 123456789101112131415161718192021222324252627282930[ { &quot;id&quot;: &quot;096dd811-770d-49bb-a160-be11813e6942&quot;, &quot;title&quot;: &quot;三国演义&quot;, &quot;anchor&quot;: &quot;罗贯中&quot;, &quot;pageSize&quot;: 30, &quot;isActive&quot;: true }, { &quot;id&quot;: &quot;5176c094-7c78-4aaf-ba16-488965583d09&quot;, &quot;title&quot;: &quot;西游记&quot;, &quot;anchor&quot;: &quot;吴承恩&quot;, &quot;pageSize&quot;: 300, &quot;isActive&quot;: true }, { &quot;id&quot;: &quot;95a5143d-f521-42ae-88cc-e5b09943db34&quot;, &quot;title&quot;: &quot;红楼梦&quot;, &quot;anchor&quot;: &quot;曹雪芹&quot;, &quot;pageSize&quot;: 300, &quot;isActive&quot;: true }, { &quot;id&quot;: &quot;9617e315-1f6f-48f9-b9b0-2ad9baec26ba&quot;, &quot;title&quot;: &quot;水浒传&quot;, &quot;anchor&quot;: &quot;施耐庵&quot;, &quot;pageSize&quot;: 300, &quot;isActive&quot;: true }] 调用http://localhost:3000/nest/books/findOne/5176c094-7c78-4aaf-ba16-488965583d09接口可得： 1234567{ &quot;id&quot;: &quot;5176c094-7c78-4aaf-ba16-488965583d09&quot;, &quot;title&quot;: &quot;西游记&quot;, &quot;anchor&quot;: &quot;吴承恩&quot;, &quot;pageSize&quot;: 300, &quot;isActive&quot;: true} 没有实现分页操作，分页可以通过findBy传入分页条件进行查询 更新数据在更新操作之前也完善一下update-book.dto.ts 123456789// update-book.dto.tsimport { PartialType } from '@nestjs/mapped-types'import { CreateBookDto } from './create-book.dto'export class UpdateBookDto extends PartialType(CreateBookDto) { id: string} 在books.controller.ts增加接口 12345678910111213141516171819// books.controller.tsimport { Controller, Get, Post, Body, Param } from '@nestjs/common'import { BooksService } from './books.service'import { CreateBookDto } from './dto/create-book.dto'import { UpdateBookDto } from './dto/update-book.dto'@Controller('books')export class BooksController { constructor(private readonly booksService: BooksService) {} // ...+ @Post('update')+ updateBook(@Body() updateBookDto: UpdateBookDto) {+ return this.booksService.updateBook(updateBookDto)+ }} 在books.service.ts中操作数据库 12345678910111213141516171819202122// books.service.tsimport { Injectable } from '@nestjs/common'import { InjectRepository } from '@nestjs/typeorm'import { Repository } from 'typeorm'import { CreateBookDto } from './dto/create-book.dto'import { UpdateBookDto } from './dto/update-book.dto'import { Book } from './entities/book.entity'@Injectable()export class BooksService { constructor( @InjectRepository(Book) private booksRepository: Repository&lt;Book&gt;, ) {} // ...+ updateBook(updateBookDto: UpdateBookDto) {+ return this.booksRepository.save(updateBookDto)+ }} 我们访问http://localhost:3000/nest/books/update并传入数据: 1234567{ &quot;id&quot;: &quot;5176c094-7c78-4aaf-ba16-488965583d09&quot;, &quot;title&quot;: &quot;道德经&quot;, &quot;anchor&quot;: &quot;老子&quot;, &quot;pageSize&quot;: 300, &quot;isActive&quot;: true} 此时我们查询数据库内容： 12345678910mysql&gt; select * from book;+--------------------------------------+--------------+-----------+----------+----------+| id | title | anchor | pageSize | isActive |+--------------------------------------+--------------+-----------+----------+----------+| 096dd811-770d-49bb-a160-be11813e6942 | 三国演义 | 罗贯中 | 30 | 1 || 5176c094-7c78-4aaf-ba16-488965583d09 | 道德经 | 老子 | 300 | 1 || 95a5143d-f521-42ae-88cc-e5b09943db34 | 红楼梦 | 曹雪芹 | 300 | 1 || 9617e315-1f6f-48f9-b9b0-2ad9baec26ba | 水浒传 | 施耐庵 | 300 | 1 |+--------------------------------------+--------------+-----------+----------+----------+4 rows in set (0.00 sec) 这里我们update的时候传递的是全量数据，所以直接save就可以了。 如果我们update只传递了几个字段，那么就需要通过id找到数据库中的数据，再把对应的字段进行修改，然后将修改后的数据进行save 删除数据在books.controller.ts增加接口 12345678910111213141516171819// books.controller.tsimport { Controller, Get, Post, Body, Param } from '@nestjs/common'import { BooksService } from './books.service'import { CreateBookDto } from './dto/create-book.dto'import { UpdateBookDto } from './dto/update-book.dto'@Controller('books')export class BooksController { constructor(private readonly booksService: BooksService) {} // ...+ @Get('delete/:id')+ deleteBook(@Param('id') id: string) {+ return this.booksService.deleteBook(id)+ }} 在books.service.ts添加逻辑 12345678910111213141516171819202122// books.service.tsimport { Injectable } from '@nestjs/common'import { InjectRepository } from '@nestjs/typeorm'import { Repository } from 'typeorm'import { CreateBookDto } from './dto/create-book.dto'import { UpdateBookDto } from './dto/update-book.dto'import { Book } from './entities/book.entity'@Injectable()export class BooksService { constructor( @InjectRepository(Book) private booksRepository: Repository&lt;Book&gt;, ) {} // ...+ deleteBook(id: string) {+ return this.booksRepository.delete(id)+ }} 我们请求http://localhost:3000/nest/books/delete/5176c094-7c78-4aaf-ba16-488965583d09来删除名为道德经的数据，此时查询数据库： 123456789mysql&gt; select * from book;+--------------------------------------+--------------+-----------+----------+----------+| id | title | anchor | pageSize | isActive |+--------------------------------------+--------------+-----------+----------+----------+| 096dd811-770d-49bb-a160-be11813e6942 | 三国演义 | 罗贯中 | 30 | 1 || 95a5143d-f521-42ae-88cc-e5b09943db34 | 红楼梦 | 曹雪芹 | 300 | 1 || 9617e315-1f6f-48f9-b9b0-2ad9baec26ba | 水浒传 | 施耐庵 | 300 | 1 |+--------------------------------------+--------------+-----------+----------+----------+3 rows in set (0.00 sec) 这里用的是真删除，实际生产中请考虑需求，一般来说都是做逻辑删除的 在上边的CRUD示例中，展示了几个常用的typeorm操作，其实还有很多api，在使用过程中自己查询文档吧。 字段验证前边的C和U操作，请求体我们并没有进行校验，这里我们简单提一下，Nestjs的管道操作配合class-validator可以很好的帮我们实现校验功能 安装依赖： 1npm i --save class-validator class-transformer 我们对create-book.dto.ts中进行字段约束 123456789101112// create-book.dto.ts+import { IsNotEmpty, IsString, IsOptional } from 'class-validator'export class CreateBookDto {+ @IsString({ message: '标题必须是字符串' })+ @IsNotEmpty({ message: '标题不能为空' }) title: string+ @IsOptional()+ @IsString({ message: '作者名是字符串' }) anchor: string pageSize: number isActive: boolean} 注意我们有一个IsOptional()装饰器，该装饰器可以把这个字段标记为可选的，即anchor===null或者anchor===undefined的话，就会忽略其他的验证规则，如果anchor有值则必须为string类型 我们不能通过anchor?: string这种方式来标记可选字段 然后我们在当前目录下新建一个管道validate.pipe.ts 关于管道的内容这里不展开说，留到后边再讲，这里主要是对dto的字段校验 12345678910111213141516171819202122232425262728293031323334353637// validate.pipe.tsimport { PipeTransform, Injectable, ArgumentMetadata, BadRequestException,} from '@nestjs/common'import { validate } from 'class-validator'import { plainToInstance } from 'class-transformer'@Injectable()export class ValidationPipe implements PipeTransform&lt;any&gt; { async transform(value: any, { metatype }: ArgumentMetadata) { if (!metatype || !this.toValidate(metatype)) { return value } const object = plainToInstance(metatype, value) // 验证字段，如果有错误会抛出错误，错误内容可自定义，BadRequestException是一个nestjs内置异常 const errors = await validate(object) if (errors.length &gt; 0) { // console.log('errors:', errors) const message = errors[0].constraints const info = message[Object.keys(message)[0]] // console.log('message:', info) throw new BadRequestException(info ? info : 'Validation failed') } return value } private toValidate(metatype: any): boolean { const types: any[] = [String, Boolean, Number, Array, Object] return !types.includes(metatype) }} 这里我们是使用官方提供的示例自定义管道，其实Nestjs内置了一个ValidationPipe管道，功能很强大，放到后边管道章节说(验证的内容挺多的，也可能单独拿出来说) 在books.controller.ts中引入这个验证管道并应用于新增接口 123456789101112131415161718// books.controller.tsimport { Controller, Get, Post, Body, Param } from '@nestjs/common'import { BooksService } from './books.service'import { CreateBookDto } from './dto/create-book.dto'import { UpdateBookDto } from './dto/update-book.dto'+import { ValidationPipe } from './validate.pipe'@Controller('books')export class BooksController { constructor(private readonly booksService: BooksService) {} @Post('create')+ createBook(@Body(new ValidationPipe()) createBookDto: CreateBookDto) { return this.booksService.createBook(createBookDto) } // ...} 此时我们访问新增接口不传递title字段： 1234{ &quot;anchor&quot;: &quot;张三&quot;, &quot;pageSize&quot;: 300} 得到的返回结果是： 12345{ &quot;statusCode&quot;: 400, &quot;message&quot;: &quot;标题不能为空&quot;, &quot;error&quot;: &quot;Bad Request&quot;} 我们也可以传递一个不是字符串类型的title字段进行测试： 12345{ &quot;title&quot;: 123, &quot;anchor&quot;: &quot;张三&quot;, &quot;pageSize&quot;: 300} 得到的结果是： 12345{ &quot;statusCode&quot;: 400, &quot;message&quot;: &quot;标题必须是字符串&quot;, &quot;error&quot;: &quot;Bad Request&quot;} 这样一来，我们就有了一个简单的字段必填和字段类型校验。 基本的CRUD功能已经搭建完成了，但Nestjs的能力还要强悍的多，咱们下次再见","link":"/2023/02/17/Nestjs%E4%BD%BF%E7%94%A8Mysql%E7%9A%84%E5%9F%BA%E6%9C%ACCRUD%E6%90%AD%E5%BB%BA/"},{"title":"Nestjs的上下文","text":"Nest提供了一些应用类来简化在不同应用上下文之间编写应用。这些应用可以用于创建通用的守卫，过滤器和拦截器，可以工作在控制器，方法和应用上下文中。 这一章节就说一下我们之前看过的ArgumentsHost和ExecutionContext两个类. ArgumentsHost类ArgumentsHost类提供了获取传递给处理程序的参数。它允许选择合适的上下文(例如HTTP，RPC(微服务)或者Websockets)来从框架中获取参数。框架提供了ArgumentsHost的实例，作为host参数提供给需要获取的地方 ArgumentsHost简单地抽象为处理程序参数。例如，在HTTP应用中(使用@nestjs/platform-express时),host对象封装了Express的[request, response, next] 数组,request是一个request对象，response是一个response对象，next是控制应用的请求响应循环的函数。此外，在GraphQL应用中，host包含[root, args, context, info]数组。 当构建通用的守卫，过滤器和拦截器时，意味着要跨应用上下文运行，我们需要在当前运行时定义应用类型。可以使用 ArgumentsHost的getType()方法。 12345678if (host.getType() === 'http') { // do something that is only important in the context of regular HTTP requests (REST)} else if (host.getType() === 'rpc') { // do something that is only important in the context of Microservice requests} else if (host.getType&lt;GqlContextType&gt;() === 'graphql') { // do something that is only important in the context of GraphQL requests} 要获取传递给处理程序的参数数组，使用host对象的getArgs()方法。 1const [req, res, next] = host.getArgs();Copy to clipboardErrorCopied 可以使用getArgByIndex()根据索引获取指定参数: 12const request = host.getArgByIndex(0);const response = host.getArgByIndex(1);Copy to clipboardErrorCopied 在这些例子中我们通过索引来获取请求响应对象，这并不推荐，因为它将应用和特定上下文耦合 为了使代码更健壮，更可复用，你可以在程序中使用host对象的应用方法来切换合适的应用上下文 123456789101112/** * Switch context to RPC. */switchToRpc(): RpcArgumentsHost;/** * Switch context to HTTP. */switchToHttp(): HttpArgumentsHost;/** * Switch context to WebSockets. */switchToWs(): WsArgumentsHost; 使用 switchToHttp() 方法重写前面的例子， host.switchToHttp()帮助方法调用一个HTTP应用的HttpArgumentsHost对象. HttpArgumentsHost对象有两个有用的方法，我们可以用来提取期望的对象。我们也可以使用Express类型的断言来返回原生的Express类型对象： 123const ctx = host.switchToHttp();const request = ctx.getRequest&lt;Request&gt;();const response = ctx.getResponse&lt;Response&gt;(); 类似地，WsArgumentsHost和RpcArgumentsHost有返回微服务和WebSockets上下文的方法，以下是WsArgumentsHost的方法: 12345678910export interface WsArgumentsHost { /** * Returns the data object. */ getData&lt;T&gt;(): T; /** * Returns the client object. */ getClient&lt;T&gt;(): T;}Copy to clipboardErrorCopied 以下是RpcArgumentsHost的方法: 1234567891011export interface RpcArgumentsHost { /** * Returns the data object. */ getData&lt;T&gt;(): T; /** * Returns the context object. */ getContext&lt;T&gt;(): T;} ExecutionContext类ExecutionContext扩展了ArgumentsHost,提供额外的当前运行线程信息。和ArgumentsHost类似,Nest在需要的时候提供了一个ExecutionContext的实例， 例如守卫的canActivate()方法和拦截器的intercept()方法，它提供以下方法： 1234567891011export interface ExecutionContext extends ArgumentsHost { /** * Returns the type of the controller class which the current handler belongs to. */ getClass&lt;T&gt;(): Type&lt;T&gt;; /** * Returns a reference to the handler (method) that will be invoked next in the * request pipeline. */ getHandler(): Function;} getHandler()方法返回要调用的处理程序的引用。getClass()方法返回一个特定处理程序所属的控制器类。例如，一个HTTP上下文，如果当前处理的是一个POST请求，在CatsController中绑定create()方法。getHandler()返回create()方法和getClass()方法所在的CatsController类的引用(不是实例)。 12const methodKey = ctx.getHandler().name; // &quot;create&quot;const className = ctx.getClass().name; // &quot;CatsController&quot;Copy to clipboardErrorCopied 能同时获取当前类和处理方法的引用的能力提供了极大的灵活性。最重要的是，它给我们提供了通过@SetMetadata()装饰器来操作守卫或拦截器元数据的方法(在守卫一节用到过)。 这一节确实没想到能说什么，所以只是把官方文档的内容摘录了一下，没有相关的示例。 之所以有这一节，主要是因为前边守卫、拦截器等都用到了上下文，所以来说一下。","link":"/2023/02/24/Nestjs%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"title":"Scss语法二@Rules和指令","text":"续接上回。 @-Rules和指令Sass 支持所有的 CSS3 @-Rules，以及 Sass 特有的 “指令”（directives） @importSass 拓展了 @import 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。 导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式： 12$family: unquote(&quot;Droid+Sans&quot;);@import url(&quot;http://fonts.googleapis.com/css?family=\\#{$family}&quot;); 嵌套@import大多数情况下，一般在文件的最外层（不在嵌套规则内）使用 @import，其实，也可以将 @import 嵌套进 CSS 样式或者 @media 中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。 假设 example.scss 文件包含以下样式： 123.example { color: red;} 然后导入到 #main 样式内 123#main { @import &quot;example&quot;;} 将会被编译为 123#main .example { color: red;} 不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import。 @mediaSass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 @media 嵌套在 CSS 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。 123456.sidebar { width: 300px; @media screen and (orientation: landscape) { width: 500px; }} 编译为 1234567.sidebar { width: 300px; } @media screen and (orientation: landscape) { .sidebar { width: 500px; } } @extend在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。通常会在 HTML 中给元素定义两个 class，一个通用样式，一个特殊样式。假设现在要设计一个普通错误样式与一个严重错误样式，一般会这样写： 123&lt;div class=&quot;error seriousError&quot;&gt; Oh no! You've been hacked!&lt;/div&gt; 样式如下 1234567.error { border: 1px #f00; background-color: #fdd;}.seriousError { border-width: 3px;} 麻烦的是，这样做必须时刻记住使用 .seriousError 时需要参考 .error 的样式，带来了很多不变：智能比如加重维护负担，导致 bug，或者给 HTML 添加无语意的样式。使用 @extend 可以避免上述情况，告诉 Sass 将一个选择器下的所有样式继承给另一个选择器。 12345678.error { border: 1px #f00; background-color: #fdd;}.seriousError { @extend .error; border-width: 3px;} 上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。 当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个，例如： 12345678910111213141516.error { border: 1px #f00; background-color: #fdd;}.seriousError { @extend .error; border-width: 3px;}.criticalError { @extend .seriousError; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%;} 现在，每个 .seriousError 选择器将包含 .error 的样式，而 .criticalError 不仅包含 .seriousError 的样式也会同时包含 .error 的所有样式，上面的代码编译为： 12345678910111213.error, .seriousError, .criticalError { border: 1px #f00; background-color: #fdd; }.seriousError, .criticalError { border-width: 3px; }.criticalError { position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%; } @extend-Only选择器配合占位符选择器使用，前边已做标记。可以翻看占位符选择器部分。 @at-root@at-root指令可以使一个或多个规则被限定输出在文档的根层级上，而不是被嵌套在其父选择器下。 下面就通过scss代码实例介绍一下它的作用: 没有使用@at-root命令的默认情况。 1234567.parent{ color:red; .child { width:200px; height:50px; }} 编译成css代码如下: 1234567.parent { color: red; }.parent .child { width: 200px; height: 50px; } 使用@at-root命令的scss代码 1234567.parent{ color:red; @at-root .child { width:200px; height:50px; }} 编译后的css代码如下： 1234567.parent { color: red;}.child { width: 200px; height: 50px; } 由于使用@at-root命令，那么.child就不参与嵌套，直接跳出嵌套。 在默认情况下，@at-root只会跳出选择器嵌套，而不会跳出指令 scss实例如下： 12345678@media print { @at-root{ .foo { color: green; color: gray; } }} 编译后的css代码如下： 123456@media print { .foo { color: green; color: gray; }} 默认 @at-root 只会跳出选择器嵌套，而不能跳出 @media 或 @support，如果要跳出这两种，则需使用 @at-root(without: media)，@at-root(without: support)。这个语法的关键词有四个：all（表示所有）, rule（表示常规）, media（表示 media），support（表示 support ）。我们默认的 @at-root 其实就是 @at-root( without: rule )。如果指定的不是all，则只会跳出指定的嵌套，可以指定多个如@at-root(without: media rule) 控制指令SassScript 提供了一些基础的控制指令，比如在满足一定条件时引用样式，或者设定范围重复输出格式。控制指令是一种高级功能，日常编写过程中并不常用到，主要与混合指令 (mixin) 配合使用，尤其是用在 Compass 等样式库中。 @if当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码： 12345p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 &lt; 3 { border: 2px dotted; } @if null { border: 3px double; }} 编译为 12p { border: 1px solid; } @if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。如果 @if 声明失败，Sass 将逐条执行 @else if 声明，如果全部失败，最后执行 @else 声明，例如： 123456789101112$type: monster;p { @if $type == ocean { color: blue; } @else if $type == matador { color: red; } @else if $type == monster { color: green; } @else { color: black; }} 编译为 123p { color: green; } @for@for 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。这个指令包含两种格式：@for $var from &lt;start&gt; through &lt;end&gt;，或者 @for $var from &lt;start&gt; to &lt;end&gt;，区别在于 through 与 to 的含义：当使用 through 时，条件范围包含 &lt;start&gt; 与 &lt;end&gt; 的值，而使用 to 时条件范围只包含 &lt;start&gt; 的值不包含 &lt;end&gt; 的值。另外，$var 可以是任何变量，比如 $i；&lt;start&gt; 和 &lt;end&gt; 必须是整数值。 123@for $i from 1 through 3 { .item-#{$i} { width: 2em * $i; }} 编译为 123456.item-1 { width: 2em; }.item-2 { width: 4em; }.item-3 { width: 6em; } @while@while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到。例如： 12345678910111213$i: 6;@while $i &gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2;}.item-6 { width: 12em; }.item-4 { width: 8em; }.item-2 { width: 4em; }","link":"/2022/06/30/Scss%E8%AF%AD%E6%B3%95%E4%BA%8C-Rules%E5%92%8C%E6%8C%87%E4%BB%A4/"},{"title":"Nodejs日志库log4js快速入门","text":"在NodeJs项目中，log4js一般会作为日志库的首选，本篇来快速入门一下log4js的一些配置和使用规则。 本文只介绍常用内容，具体细节请查看log4js官方文档 本文基于log4js@6.9.x 演示过程中使用esmodule规范，在package.json中指定type为module即可在nodejs中使用esmodule规范。 安装log4js输出第一条日志直接通过npm进行安装即可： 1npm install log4js 我们新建index.js并引入log4js测试一下： 123456// index.jsimport log4js from 'log4js'const logger = log4js.getLogger()logger.info('abcdefg') 此时我们执行node index.js可以发现控制台并没有任何输出，刚开始就跳坑了吗？ 查看官方文档我们可以知道必须要对log4js进行配置，先不关注配置项的规则，我们先写几条试一下： 1234567891011121314151617181920212223242526// index.jsimport log4js from 'log4js'// 必须配置，否则log不能输出log4js.configure({ // 追加器 appenders: { // 追加器的名字自己取，不限制 console: { type: 'console' } }, // 类别 categories: { default: { // 应用哪些追加器 appenders: ['console'], // 日志级别 level: 'all' }, }})const logger = log4js.getLogger()logger.info('abcdefg') 此时再通过nodejs运行这个文件就能在控制台看到输出我们的第一条日志了： log4js的一些概念前边我们看到了一些如追加器、类别、日志级别等概念，这一节就先说一下这些概念，不然后边容易看不懂。 追加器appenders追加器负责日志事件的输出。他们可以将事件写入文件、发送电子邮件、将它们存储在数据库中或任何内容。大多数追加程序使用布局将事件序列化为字符串以进行输出。 追加器主要是自定义命名追加器 对 默认追加器对象的映射。是一个对象。 说人话就是我们自己可以定义一个名字作为追加器的key，其value是一个对象，这个对象指向一个log4js定义的追加器。所以这个value必须有一个type属性，type是一个字符串描述使用哪一种追加器，是否需要其他字段取决于type使用哪种追加器。 比如 1234567appenders: { // 这个是我们定义的追加器的名字，用来给类别使用 console: { // type的值是log4js提供的追加器类型，有些类型需要配置额外字段 type: 'console' }} 这里没想到怎么去翻译，所以自定义的key也称为追加器名称了。 这个自定义追加器名称 就是 对log4js某个追加器的自定义配置 类别categories用于对日志事件进行分组的标签。类别的配置方式与追加器是类似的，也是我们自定义一个类别名称，然后指定这个类别使用哪些追加器以及日志级别等。而且必须要定义一个名为default的类别。类别配置接收三个字段： appenders： 要使用的追加器，是一个字符串数组，这里配置的就是我们自定义的追加器名称。 level： 日志级别，很重要，后边会说。这里是对于logger的最低级别限制，如果用了该category的logger以低于该级别输出日志是不会输出的 enableCallStack： 可选字段，是一个布尔值，默认为false。 日志级别level日志级别是日志事件（调试、信息等）的严重性或优先级。追加者是否会看到事件取决于类别的级别。如果此值小于或等于事件的级别，则会将其发送到类别的追加器。 将日志分为不同等级对日志进行分类，优先级由低到高为： ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; MARK &lt; OFF。 注意，off是用来关闭日志，而不是作为日志级别 也就是说我们永远不会用logger.off()来输出日志 日志对象logger这是你的代码与log4js的主界面。记录器实例可能具有在创建实例时定义的可选类别。 我们通过log4js.getLogger()得到logger对象 getLogger([category])接收一个可选参数category，类型为字符串。如果不传递就会使用default，这就是我们前边说的必须要定义一个default类别的原因。 logger对象上有一个常用属性level，我们可以对其进行修改，后边会做演示。 日志事件比如logger.info, logger.error, logger.debug等都是触发日志事件 logger.info, logger.error等事件是表示以指定日志级别输出日志，当然如果日志级别低于category设置的级别是被忽略的。 布局layout用于将日志事件转换为字符串表示的函数。有些抽象，后边具体说吧。 configure配置使用log4js的第一步就是要配置configure。 配置项先过一下configure的所有配置项吧： levels： 可选参数，定义日志级别。 appenders： 追加器 categories: 类别 pm2: 可选参数，布尔值，如果使用pm2运行应用需要设置为true pm2InstanceVar: 可选参数，如果未更改pm2的默认配置，一般来说不需要设置 disableClustering： 可选参数，布尔值，关于集群配置的，不太懂就不说了。 因为关于追加器、类别等还是有很多可自定义配置的，要放到后边来说，所以我们接下来结合前边说的内容做一些简单的配置演示。 多类别应用我们运用前边的知识，创建多个appender和category来测试 123456789101112131415161718192021222324252627282930313233343536import log4js from 'log4js'log4js.configure({ appenders: { console: { type: 'console' }, out: { type: 'stdout' } }, categories: { default: { appenders: ['console'], level: 'all' }, out: { appenders: ['out'], level: 'all' }, all: { appenders: ['console', 'out'], level: 'all' }, }})// 使用type=console的appenderconst logger = log4js.getLogger()logger.info('这是default类别日志输出')// 使用type=stdout的appenderconst outLogger = log4js.getLogger('out')outLogger.info('这是out类别输出日志')// 同时使用console和stdout的appendconst allLogger = log4js.getLogger('all')allLogger.info('这是all类别输出日志') 运行该文件，可以看到控制台输出： 可以看到，使用category为all的logger输出了2条日志 日志级别控制123456789101112131415161718192021222324252627import log4js from 'log4js'log4js.configure({ appenders: { console: { type: 'console' } }, categories: { default: { appenders: ['console'], // 注意level设置为error level: 'error' } }})// logger受用default这个category，所以最低level设置为errorconst logger = log4js.getLogger()// 由于info级别低于error，所以会被忽略logger.info('info输出')// 降低levellogger.level = 'info'// info级别等于info，所以可以输出logger.info('降低level后再次以info输出')// error级别高于info，也可以输出logger.error('error输出') 执行可以看到控制台输出结果： 由此可见，低于指定level的日志输出会被忽略 追加器appenders在前边，我们只用到了console和stdout这两个appender，也是最简单的两个，在项目中这肯定是不够的，所以这里我们介绍一些常用的appender。 consoleconsole使用NodeJs的console.log来输出日志到控制台，比较简单，就不再多做演示了。 可配置项： type： console layout： 布局放到后边说 注意！ 将大量日志输出到控制台可能会导致内存占用上升，尽量不要在生产环境中启用。 可以使用stdout作为appender来代码console以减少内存占用 console总是使用console.log，即便logger.error()输出日志也并不会使用console.error。 stdoutstdout是log4js的默认appender，将所有日志事件写入标准输出流。 可配置项： type： stdout layout： 布局放到后边说 stderr与stdout有些相似，不过是将所有日志事件写入标准错误流 可配置项： type： stderr layout： 布局放到后边说 logLevelFilter这个appender很有意思，我们前边是在category设置的level，其实在appender中也可以进行一些限制，就是用到logLevelFilter 可配置项： type: logLevelFilter appender: 真正要用的追加器，比如stdout level： 允许通过追加器的最低日志级别限制 maxLevel: 可选参数，允许通过追加器的最大日志级别限制，默认为fatal 如果事件的级别大于或等于level且小于或等于 maxLevel，则它将被发送到追加器。 代码如下： 1234567891011121314151617181920212223242526import log4js from 'log4js'log4js.configure({ appenders: { console: { type: 'console' }, logLevelFilter: { type: 'logLevelFilter', appender: 'console', level: 'error' } }, categories: { default: { appenders: ['console', 'logLevelFilter'], level: 'info' } }})const logger = log4js.getLogger()// category设置level为info，所以不会被该类别忽略，但是logLevelFIlter appender设置level为error，所以会被该appender忽略，而console appender正常执行logger.info('以info输出')// 以error执行则不会被忽略logger.error('以error输出') 执行该文件的结果如下： 总结： 如果日志事件的级别 低于 类别定义的级别， 该事件会被忽略 如果日志事件的级别 不低于 类别定义的级别，那么该事件会生效，但是如果该类别中应用到了logLevelFilter追加器，需要不低于该追加器定义的级别才会应用该追加器，其他追加器不受影响 file将日志写入到文件是基础的需求，我们来看一下file appender。 将日志事件写入文件。它支持可选的最大文件大小，并将保留可配置数量的备份。 可配置项： type： file filename: 要写入日志的文件的路径 maxLogSize: 可选参数，日志的最大大小(以字节为单位)。如果指定为0或不指定，则不会发生日志滚动 backups： 可选参数，默认5，日志滚动期间要保留的旧日志文件数 layout： 布局放到后边说 在应用程序终止时调用 log4js.shutdown，以确保任何剩余的异步写入都已完成 不限制日志大小示例1234567891011121314151617181920import log4js from 'log4js'log4js.configure({ appenders: { file: { type: 'file', filename: 'app-log.log' } }, categories: { default: { appenders: ['file'], level: 'all' } }})const logger = log4js.getLogger()logger.info('这是一行日志输出内容')log4js.shutdown() 此时多次执行这个文件，会发现在同级目录创建了一个文件app-log.log，内容如下： 限制日志文件大小代码如下： 1234567891011121314151617181920212223242526import log4js from 'log4js'log4js.configure({ appenders: { file: { type: 'file', filename: 'app-log.log', // 10kb maxLogSize: 1024 * 10, backups: 3, } }, categories: { default: { appenders: ['file'], level: 'all' } }})const logger = log4js.getLogger()// 循环输出，查看压缩效果for(let i = 0; i &lt; 100; i ++) { logger.info('这是一行日志输出内容')}log4js.shutdown() 执行一次代码，可以发现app-log.log文件已经被创建了，大小为7kb，写入内容如下： 我们在次执行代码，可以发现创建了一个新的文件app-log.log.1存储旧的日志，而超过大小限制无法写入的内容写入到了app-log.log中。 不难发现，在写入到139行之后超过了10kb的限制，所以将这些内容备份到app-log.log.1中，将未写入到61行日志写入到了app-log.log中 注意： 由于我们限制了备份到日志数量，所以当达到最大限制后，新的日志会覆盖旧的日志。 file appender还可以配置compress为true，如果这样配置的话会将备份文件进行gzip压缩，也就是缓存文件会被压缩为app-log.log.1.gz，其他的行为是一致的就不演示了。 fileSync用法与file基本是一致的，就不演示了，主要区别如下： fileSync写入文件是同步的，而file是异步的 fileSync不支持配置compress将日志文件进行gzip压缩 还有multiFile可以动态写入多个文件，有兴趣可以自行学习一下，这里不说了。 dataFile更常用的追加器来了，dataFile也是一个文件追加器，它根据可配置的时间（而不是文件大小）滚动日志文件。 基础配置项： type: dataFile filename: 要写入的文件路径 pattern: 可选字符串，默认为yyyy-MM-dd,用来确定怎么分割滚动日志 先根据这几个基础的字段来看一下用法，由于默认是以天分割，不方便演示，所以我这边设置pattern为分钟。 代码示例： 12345678910111213141516171819202122import log4js from 'log4js'log4js.configure({ appenders: { dateFile: { type: 'dateFile', filename: 'app-log.log', pattern: 'yyyy-MM-dd-hh:mm' } }, categories: { default: { appenders: ['dateFile'], level: 'info' } }})const logger = log4js.getLogger()logger.info('这是一条日志')log4js.shutdown() 执行代码可发现生成了日志文件 过了一分钟，我们再次执行代码观察日志文件： 可以得出我们写入日志时，会生成app-log.log文件。一分钟后的再次写入发生时，会将app-log.log重命名为app-log.log.yyyy-MM-dd-hh-mm然后创建一个新的app-log.log文件写入内容。 文件命名与时间分割都由pattern决定。默认是以天分割。 还有一些其他的配置项，比较容易看懂，就不做代码示例了： compress ： 是否使用gzip压缩,默认为false keepFileExt: 布尔值，默认为false, 如果为true，则备份的日志文件将被命名为app-log.yyyy-MM-dd.log，而不是app-log.log.yyyy-MM-dd fileNameSep: 备份文件命名的切割符，默认是. numBackups: 保存旧文件的数量，默认是1 file和dateFile等文件写入的appender，都可以配置mode、 encodeing、 flags等，一般情况下默认值即可。默认值是0o600 、 utf-8、'a'。也就是读写权限，utf8编码，追加模式 关于appenders的内容就到这里了，还有更多tcp等appender去文档查看吧。 类别categories类别是日志事件的组，至少要定义一个类别。 类别可以说的不多，前边的示例中演示过了，只说一个比较特别的功能类别继承 以官方的代码示例： 12345678910111213141516171819202122232425import log4js from 'log4js'log4js.configure({ appenders: { console: { type: &quot;console&quot; }, app: { type: &quot;file&quot;, filename: &quot;application.log&quot; }, }, categories: { default: { appenders: [&quot;console&quot;], level: &quot;trace&quot; }, catA: { appenders: [&quot;console&quot;], level: &quot;error&quot; }, &quot;catA.catB&quot;: { appenders: [&quot;app&quot;], level: &quot;trace&quot; }, },});const loggerA = log4js.getLogger(&quot;catA&quot;);loggerA.error(&quot;以error等级输出日志到控制台&quot;);// catA的level为error，这个事件会被忽略loggerA.trace(&quot;不会有日志输出&quot;);const loggerAB = log4js.getLogger(&quot;catA.catB&quot;);loggerAB.error( &quot;日志以error级别同时输出到控制台并写入文件&quot;);loggerAB.trace( &quot;日志以trace级别同时输出到控制台并写入文件&quot;); 可以发现，loggerAB使用的类别为catA.catB，即便catA的级别为error，loggerAB.trace同样可以同时应用两种appender 布局layout前边关于布局layout的内容，我们都省略掉了，其实是有原因的，log4js给各种appender默认添加了合适的布局，所以一般来说我们是不需要额外定义布局的。 布局的配置方式根appender是比较像的，log4js内置了几种layout，根据type指定layout，根据不同layout可能还有不同的配置项。 做一个简单的演示： 123456789101112131415161718192021222324252627282930import log4js from 'log4js'log4js.configure({ appenders: { out: { type: 'stdout' }, outWithLayout: { type: 'stdout', layout: { type: 'basic' } } }, categories: { default: { appenders: ['out'], level:'all' }, layout: { appenders: ['outWithLayout'], level: 'all' } }})const logger = log4js.getLogger()logger.info('默认stdout输出日志')const layoutLogger = log4js.getLogger('layout')layoutLogger.info('使用basic布局的日志输出') 输出内容： 可以发现，basic布局是没有颜色的。输出内容是时间戳、级别、类别，后跟格式化的日志事件数据。而我们默认的布局是有颜色的，用到的是colored 由于我们一般不需要对布局进行修改，所以这里仅仅列一下log4js的内置布局： basic colored或coloured messagePassThrough dummy pattern 可以自定义布局，如果有这个需求可以查看文档学习","link":"/2023/04/19/Nodejs%E6%97%A5%E5%BF%97%E5%BA%93log4js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"title":"TypeScript中的装饰器语法","text":"装饰器语法虽然还处于提案阶段，但是确实能够在实际应用中方便的解决一些问题，近期看了一下TypeScript中装饰器的一些基本用法，做了一些笔记如下. 类装饰器装饰器配置装饰器是一个函数 装饰器属于一个新特性，需要在tsconfig.json中进行配置才能正常使用： 123// 需要将如下两个配置项设置为true才能启用装饰器experimentalDecorators: true,emitDecoratorMetadata: true 装饰器的种类有很多，比如类装饰器ClassDecorator、方法装饰器MethodDecorator、属性装饰器PropertyDecorator,参数装饰器ParameterDecorator等 装饰器的定义1234567891011121314151617181920212223242526// ClassDecorator表明类型是 类的装饰器// 装饰器接受一个参数，就是要装饰的内容,编译后拿到的是类的构造函数，所以此处参数类型定义为函数// toString.call(Tank) 类的类型就是Function// '[object Function]'const moveDecorator: ClassDecorator = function(target: Function){ console.log(target) // 在装饰内容的原型上添加getPosition方法 target.prototype.getPosition = ():{x:number, y: number} =&gt; { return {x: 100, y: 200} }}// 在class Tank前添加装饰器，就代表装饰的是Tank这个类，装饰器中接收的target就是这个类@moveDecoratorclass Tank { // 声明该方法，不然实例无法调用 public getPosition(){}}const t = new Tank()t.getPosition()@moveDecoratorclass Player { public getPosition(){}}const p = new Player()p.getPosition() 装饰器的@decorator是一个语法糖,下边的两种方法得到的结果是等价的 只是语法糖看起来更加明了，知道修饰的是什么，而不用去查找函数的调用 这是类装饰器的原理，其他装饰器不是的，比如方法装饰器是Object.defineProperty() 123456function decorator(target: object){}// 使用语法糖@decoratorclass Tank{}// 不使用语法糖decorator(Tanke) 装饰器叠加1234567891011121314151617181920212223242526272829// ClassDecorator表明类型是 类的装饰器// 装饰器接受一个参数，就是要装饰的内容,编译后拿到的是类的构造函数，所以此处参数类型定义为函数const moveDecorator: ClassDecorator = function(target: Function){ console.log(target) // 在装饰内容的原型上添加getPosition方法 target.prototype.getPosition = ():{x:number, y: number} =&gt; { return {x: 100, y: 200} }}const musicDecorator: ClassDecorator = function(target: Function){ target.prototype.playMusic = (): void =&gt; { console.log('播放音乐') }}// 在class Tank前添加装饰器，就代表装饰的是Tank这个类，装饰器中接收的target就是这个类// 可以叠加多个装饰器@moveDecorator@musicDecoratorclass Tank { // 声明方法，不然实例无法调用 public getPosition(){} public playMusic(){}}const t = new Tank()console.log(t.getPosition())t.playMusic()// { x: 100, y: 200 }// 播放音乐 装饰器实现统一的消息响应12345678910111213141516// 统一的消息响应装饰器const MessageDecorator = function(target: Function){ target.prototype.message = (content: string) =&gt; { console.log(content) }}@MessageDecoratorclass LoginController { public message(content:string){} public login(){ console.log('开始登录业务处理') this.message('登录成功啦') }}new LoginController().login() 装饰器工厂函数12345678910111213141516171819202122232425262728293031323334353637383940// 装饰器的工厂函数，用于生成装饰器const musicDecoratorFactory = (type: string): ClassDecorator =&gt; { switch(type){ case 'Tank': return (target: Function) =&gt; { target.prototype.playMusic = (): void =&gt; { console.log('坦克播放音乐') } } break; case 'Player': return (target: Function) =&gt; { target.prototype.playGame = (): void =&gt; { console.log('玩家玩游戏') } } break; default: return (target: Function) =&gt; { target.prototype.playMusic = (): void =&gt; { console.log('默认播放音乐') } } } }@musicDecoratorFactory('Tank')class Tank { playMusic(){}}const T = new Tank()T.playMusic()@musicDecoratorFactory('Player')class Player { playGame(){}}const P = new Player()P.playGame() 方法装饰器装饰器只能用来装饰类和类的方法，因为函数存在函数提升的问题，所以不能用来装饰普通函数 修饰普通方法则target拿到原型对象 修饰静态方法则target拿到构造函数 方法装饰器是通过Object.defineProperty()实现的 12345678910111213141516// 方法装饰器const showDecorator: MethodDecorator = (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) =&gt; { // 第一个是修饰的函数，根据修改的函数的类型不同会有不同的结果 // 第二个是函数名 // 第三个是defineProperty的属性，value,writable,enumerable,configurable // value就是修饰的函数的内容 // 如果ts目标版本低于es5，则descriptor为undefind console.log(target, propertyKey, descriptor)}class User { @showDecorator public show(){ console.log('hhhh') }} 静态方法12345678910111213141516171819202122232425const Decorator: MethodDecorator = function(target: object, propertyKey: string | symbol, descriptor: PropertyDescriptor){ console.log(target) console.log(propertyKey) console.log(descriptor) // 打印结果: // [Function: User] { show: [Function (anonymous)] } // show // { // value: [Function (anonymous)], // writable: true, // enumerable: true, // configurable: true // } // 设置为只读 descriptor.writable = false}class User { // 静态方法装饰器 @Decorator public static show(){ console.log('hhh') }}User.show() 对方法的返回内容进行修饰1234567891011121314const highlightDecorator: MethodDecorator = function(target: object, propertyKey: string | symbol, descriptor: PropertyDescriptor){ const method = descriptor.value descriptor.value = () =&gt; { return `&lt;span style=&quot;color:red;&quot;&gt;${method()}&lt;/span&gt;` }}class User { // 静态方法装饰器 @highlightDecorator public response(){ return 'hhh.xxx.yyy' }}console.log(new User().response()) 处理抛出错误123456789101112131415161718const ErrorDecorator: MethodDecorator = (target: object, propertyKey: string | symbol, descriptor: PropertyDescriptor) =&gt; { const method = descriptor.value descriptor.value = () =&gt; { try{ method() }catch(error){ console.log(`我抛出了一个错误，错误内容是${error}`) } }}class People { @ErrorDecorator public find(){ throw new Error('error') }}new People().find() 属性装饰器与参数装饰器属性装饰器根据修饰的属性是普通属性还是静态属性，分别能得到原型对象和构造函数 参数装饰器根据参数所在的方法是普通方法和静态方法，分别能得到方法的原型对象和构造函数 参数装饰器会比方法装饰器更先一步执行 12345678910111213141516171819202122232425// 属性装饰器const propDecorator: PropertyDecorator = (target: Object, propertyKey: string | symbol) =&gt; { // target如果是普通属性得到的是原型对象，如果是静态属性得到的是构造函数 console.log(target) // {} [Function: HD] console.log(propertyKey) // 属性名称 // name age}// 参数装饰器const paramsDecorator: ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) =&gt; { // 如果参数所在的方法是普通方法则得到原型对象 { say: [Function (anonymous)] } // 如果参数所在的方法是静态方法则得到构造函数 [Function: HD] { say: [Function (anonymous)] } console.log(target) console.log(propertyKey) // 参数所在的方法名 say console.log(parameterIndex) // 参数的下标 1}class HD { @propDecorator public name: string | undefined @propDecorator public static age: number public say(id: number, @paramsDecorator content: string){} // public static say(id: number, @paramsDecorator content: string){}} 属性装饰器动态转换对象属性12345678910111213141516171819202122// 使用属性装饰器将属性值转换为小写const propDecorator: PropertyDecorator = (target: Object, propertyKey: string | symbol) =&gt; { let value: string // 使用访问器对属性进行操作,使其返回小写 Object.defineProperty(target, propertyKey, { get: () =&gt; { return value.toLowerCase() }, set: (v) =&gt; { value = v } })}class HD { @propDecorator public title: string | undefined}const obj = new HD()obj.title = &quot;HELLO WORLD&quot;console.log(obj.title) // hello world 元数据元数据用于给对象的属性添加额外的描述信息 ts默认不支持元数据，需要引入reflect-metadata这个npm包才行 Reflect.defindMetadata用于设置元数据，接收四个参数： ​ [元数据属性名， 元数据属性值， 要设置的对象， 要设置的对象的属性] Reflect.getMetadata用于查询元数据，接收三个参数： ​ [元数据的属性名， 对象名， 对象的属性名] 12345678import 'reflect-metadata'const hd = { name: 'alin'}// 设置元数据Reflect.defineMetadata('desc',{title:'hhh'}, hd, 'name')// 读取元数据console.log(Reflect.getMetadata('desc', hd, 'name')) 对参数做必传校验12345678910111213141516171819202122232425262728293031import 'reflect-metadata'// 属性装饰器const requiredDecorator: ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) =&gt; { let requiredParams: number[] = [] requiredParams.push(parameterIndex) // 将需要必传的参数的下标存入元数据 Reflect.defineMetadata('required', requiredParams, target, propertyKey)}const validateDecorator: MethodDecorator = (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) =&gt; { const method = descriptor.value descriptor.value = function(){ // 拿到需要必传的参数的下标 const requiredParams: number[] = Reflect.getMetadata('required', target, propertyKey) || [] // 如果必传参数没有传递则抛出错误 requiredParams.forEach( function(index){ if(index &gt; arguments.length || arguments[index] === undefined){ throw new Error('请传递必要的参数') } }) // 验证通过则执行原来的方法 return method.apply(this, arguments) }}class HD { @validateDecorator public find(name: string, @requiredDecorator id: number){ console.log(id) }}","link":"/2022/03/23/TypeScript%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%AD%E6%B3%95/"},{"title":"Scss语法三混入和函数","text":"续接上回。 混合指令mixin混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 .float-left。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。 定义混合指令混合指令的用法是在 @mixin 后添加名称与样式，比如名为 large-text 的混合通过下面的代码定义： 12345678@mixin large-text { font: { family: Arial; size: 20px; weight: bold; } color: #ff0000;} 混合也需要包含选择器和属性，甚至可以用 &amp; 引用父选择器： 1234567891011@mixin clearfix { display: inline-block; &amp;:after { content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden; } * html &amp; { height: 1px }} 引用混合指令使用 @include 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）： 12345.page-title { @include large-text; padding: 4px; margin-top: 10px;} 编译为 1234567.page-title { font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; } 也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器。 1234567@mixin silly-links { a { color: blue; background-color: red; }}@include silly-links; 编译为 1234a { color: blue; background-color: red; } 参数参数用于给混合指令中的样式设定变量，并且赋值使用。在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号里。引用指令时，按照参数的顺序，再将所赋的值对应写进括号： 12345678@mixin sexy-border($color, $width) { border: { color: $color; width: $width; style: dashed; }}p { @include sexy-border(blue, 1in); } 编译为 1234p { border-color: blue; border-width: 1in; border-style: dashed; } 混合指令也可以使用给变量赋值的方法给参数设定默认值，然后，当这个指令被引用的时候，如果没有给参数赋值，则自动使用默认值： 123456789@mixin sexy-border($color, $width: 1in) { border: { color: $color; width: $width; style: dashed; }}p { @include sexy-border(blue); }h1 { @include sexy-border(blue, 2in); } 编译为 1234567891011p { border-color: blue; border-width: 1in; border-style: dashed; }h1 { border-color: blue; border-width: 2in; border-style: dashed; } 混合指令也可以使用关键词参数，上面的例子也可以写成： 12p { @include sexy-border($color: blue); }h1 { @include sexy-border($color: blue, $width: 2in); } 向混合样式中导入内容在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方： 12345678910@mixin apply-to-ie6-only { * html { @content; }}@include apply-to-ie6-only { #logo { background-image: url(/logo.gif); }} 编译为 123* html #logo { background-image: url(/logo.gif);} 使用插值语句123456@mixin firefox-message($selector) { body.firefox #{$selector}:before { content: &quot;Hi, Firefox users!&quot;; }}@include firefox-message(&quot;.header&quot;); 编译为 123body.firefox .header:before { content: &quot;Hi, Firefox users!&quot;; } 为便于书写，@mixin 可以用 = 表示，而 @include 可以用 + 表示，但是一般不会使用简写形式。 函数指令Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用： 12345678$grid-width: 40px;$gutter-width: 10px;@function grid-width($n) { @return $n * $grid-width + ($n - 1) * $gutter-width;}#sidebar { width: grid-width(5); } 编译为 12#sidebar { width: 240px; } 与 mixin 相同，也可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用 @return 输出结果。 自定义的函数也可以使用关键词参数，上面的例子还可以这样写： 1#sidebar { width: grid-width($n: 5); } 建议在自定义函数前添加前缀避免命名冲突，其他人阅读代码时也会知道这不是 Sass 或者 CSS 的自带功能。 自定义函数与 mixin 相同，都支持 variable arguments","link":"/2022/06/30/Scss%E8%AF%AD%E6%B3%95%E4%B8%89%E6%B7%B7%E5%85%A5%E5%92%8C%E5%87%BD%E6%95%B0/"},{"title":"Scss语法一嵌套语法和SassScript","text":"最近在看Element UI的源码，发现源码中写的很多样式都用到了Scss的各种语法，虽然可读性不高但是看着是真帅啊。为了方便阅读Element的源码，花点时间把Scss文档上的常用语法大概过一遍吧。 嵌套规则1234567// 嵌套规则#main{ width: 100%; .box{ width: 100%; }} 父选择器&amp;1234567// 嵌套规则#main{ width: 100%; &amp;:hover{ cursor: pointer; }} 属性嵌套1234567.text-box{ // 属性嵌套 font: { family: &quot;fantasy&quot;; size: 30px; }} 编译为： 1234.text-box{ font-family: &quot;fantasy&quot;; font-size: 30px;} 占位符选择器%fooSass 额外提供了一种特殊类型的选择器：占位符选择器 (placeholder selector)。与常用的 id 与 class 选择器写法相似，只是 # 或 . 替换成了 %。必须通过 @extend指令调用 当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中 有时，需要定义一套样式并不是给某个元素用，而是只通过 @extend 指令使用，尤其是在制作 Sass 样式库的时候，希望 Sass 能够忽略用不到的样式。 如果使用普通的 CSS 规则，最后会编译出很多用不到的样式，也容易与其他样式名冲突，所以，Sass 引入了“占位符选择器” (placeholder selectors)，看起来很像普通的 id 或 class 选择器，只是 # 或 . 被替换成了 %。可以像 class 或者 id 选择器那样使用，当它们单独使用时，不会被编译到 CSS 文件中。 123456// 单独使用不会被编译#context a%extreme { color: blue; font-weight: bold; font-size: 2em;} 占位符选择器需要通过延伸指令使用，用法与 class 或者 id 选择器一样，被延伸后，占位符选择器本身不会被编译。 123.notice { @extend %extreme;} 编译为 12345#context a.notice { color: blue; font-weight: bold; font-size: 2em; } SassScript在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。 通过 interpolation，SassScript 甚至可以生成选择器或属性名，这一点对编写 mixin 有很大帮助。 变量$SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样： 1$width: 5em; 直接使用即调用变量： 123#main { width: $width;} 变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明： 12345678#main { $width: 5em !global; width: $width;}#sidebar { width: $width;} 编译为 1234567#main { width: 5em;}#sidebar { width: 5em;} 圆括号圆括号可以用来影响运算的顺序： 123p { width: 1em + (2em * 3);} 编译为 123p { width: 7em; } 插值语句#{}通过 #{} 插值语句可以在选择器或属性名中使用变量： 12345$name: foo;$attr: border;p.#{$name} { #{$attr}-color: blue;} 编译为 123p.foo { border-color: blue; } #{} 插值语句也可以在属性值中插入 SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。 12345p { $font-size: 12px; $line-height: 30px; font: #{$font-size}/#{$line-height};} 编译为 12p { font: 12px/30px; } 插值语句在mixin中根据参数来动态的给标签设置样式会更常用，该用法在mixin中在标注。","link":"/2022/06/30/Scss%E8%AF%AD%E6%B3%95%E4%B8%80%E5%B5%8C%E5%A5%97%E8%AF%AD%E6%B3%95%E5%92%8CSassScript/"},{"title":"Vue-Router清空路由","text":"最近项目中发现一个小bug，登录账号添加路由到vue-router后，登录新账号没有清空之前到路由。本来想到退出登录过程中通过location.reload()清空，但是公司框架将/login路由设置为白名单，所以用户可以不退出登录直接跳转到login页面登录新路由，所以最终在获取路由之前将路由清空。 查看Vue Router的官方文档，发现提供了removeRoute这个方法，由于路由全是动态获取，得先把所有路由拿到再依次去remove掉太过麻烦且效率低，而且在remove之后使用过程中出现了点小问题，就没有使用该方法，去网络上搜索Vue Router清空路由的方式，得到了如下答案： 123456789101112export function resetRouter (router) { const createRouter = () =&gt; new Router({ mode: 'history', base: process.env.BASE_URL, scrollBehavior: () =&gt; ({ y: 0 }), // 初始路由列表 routes: constantRouterMap }) // 用初始化的matcher替换当前router的matcher router.matcher = createRouter().matcher } 我们将当前的router传入resetRouter函数通过matcher重新赋值的方式将router重新初始化一边，就可以清空动态加入的一些路由，只保留最初始的路由了。","link":"/2022/08/02/Vue-Router%E6%B8%85%E7%A9%BA%E8%B7%AF%E7%94%B1/"},{"title":"Vue2中使用keep-alive缓存组件","text":"在Vue项目中，有些组件需要缓存状态，不需要重复渲染，在这个时候keep-alive就派上用场了，在这家公司已经快五个月了，从来没用上过这个功能，本来就不是特别了解现在更模糊不清了，突然想起来这个功能就翻了翻官方文档，顺便做个笔记，水一期博客。 缓存动态组件keep-alive最基础的功能就是用来缓存组件，这样在你切换组件之后重新打开缓存的组件并不会重新渲染，体验较好且能保留状态。 12345678910&lt;keep-alive&gt; &lt;component :is=&quot;curComponent&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;script&gt;data(){ return { curComponent: TestComponent // 这里是组件 }}&lt;/script&gt; 当然仅仅只是这样用来缓存组件的用法其实并不多，大多时候都是拿来配置&lt;router-view&gt;使用的 配合router-view使用我们在做项目的时候经常需要将一整个路由页面缓存下来，尤其是后台管理项目，标签页感觉都已经是标配了。我们通常会把路由组件是否需要缓存配置在路由的meta元信息中，比如： 12345678910111213141516171819// router.jsconst routes = [ { name: 'A', path: '/a', component: A, meta: { keepAlive: true } }, { name: 'B', path: '/b', component: B, meta: { keepAlive: false } }] 然后我们可以根据元信息进行判断是否需要缓存 1234&lt;keep-alive&gt; &lt;router-view v-if=&quot;$router.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$router.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 这样子就可以根据元信息来缓存路由组件了，不过确实是不太优雅，所以vue在后续版本中也为keep-alive加入了新属性 keep-alive新属性Keep-alive在几次更新中加入了三个新属性： include: 要缓存的路由组件 exclude: 不需要缓存的路由组件 max: 缓存组件的最大数 max接收一个数字表示最多可以缓存多少个组件实例，如果这个数字达到了，在新实例创建之前，已缓存组件中最久没有被访问的实例会被销毁。 123&lt;keep-alive :max=&quot;10&quot;&gt; &lt;component :is=&quot;&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; include和exclude的用法是一样的，都可以接收三种类型的数据： 字符串，可以用逗号分隔 12&lt;keep-alive include=&quot;a, b&quot;&gt;&lt;/keep-alive&gt; 正则表达式 12&lt;keep-alive :include=&quot;/a|b/&quot;&gt;&lt;/keep-alive&gt; 数组 12&lt;keep-alive :include=&quot;['a','b']&quot;&gt;&lt;/keep-alive&gt; 所以如果我们的路由配置在本地，那么就没必要在元信息中配置keepAlive了，只要将需要缓存的组件名放到include中就可以。如果路由存储在服务器，那么我们还是需要进行配置，然后筛选需要缓存的组件放入到include中。 123&lt;keep-alive :include=&quot;['a','b']&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 生命周期钩子函数在keep-alive包含的组件会多出两个新的钩子函数： activated：在组件被激活时调用。在组件第一次渲染时会被调用，之后每次keep-alive激活都会被调用 deactivated：在组件被停用时调用 在vue2.2.0及更高版本中可以触发新的钩子函数 当组件在 &lt;keep-alive&gt; 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。如果组件使用exclude排除这两个钩子不会被调用。 服务端渲染时这两个钩子函数也是不能调用的。 注意include和exclude都是先匹配被包含组件的name字段，注意是组件的name字段，而不是路由的name 如果name字段不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。 keep-alive和transition类似，是一个抽象组件，并不会创建一个dom元素 都一个组件在include和exclude中都存在时，会以exclude为主，即该组件不会被缓存。 动态判断是否缓存组件一个简单的小示例，假设我们有两个组件A，B。我们动态判断是否缓存B组件。我们的需求是从B跳转到A的时候，不再缓存B组件，其他时候需要缓存B组件。 我们可以通过监听$route，判断路由来实现动态修改需要缓存的组件 123456789101112131415161718192021&lt;keep-alive :include=&quot;keepAlive&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;script&gt;export default { data(){ return { keepAlive: ['a', 'b'] } }, watch: { $route(to, from){ if(form.name === 'b' &amp;&amp; to.name === 'a'){ this.keepAlive = ['a'] }else{ this.keepAlive = ['a', 'b'] } } }}&lt;/script&gt;","link":"/2022/03/31/Vue2%E4%B8%AD%E4%BD%BF%E7%94%A8keep-alive%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6/"},{"title":"Vue3+vite+ts搭建项目","text":"新公司待了差不多三个月了，公司前端一直使用基于Vue2封装的一个基础前端框架进行开发，主要是框架集成了一些公司封装的后台管理功能，年后尤大宣布将Vue3作为默认版本，恰好年后一直没什么项目做，就学习一下Vue3顺便把公司的框架拿Vue3重写一下吧。 因为选择了Vue3+Ts+Vite，所以基础配置的搭建跟之前的Vue-cli是有些不同的，所以还是记录一下搭建整个项目基础的过程。 初始化项目查看Vite的官方文档，我们可以使用yarn create vite来创建项目，然后根据提示完成项目的初始化即可。 当然也可以直接输入自己要用的模板来创建项目，比如我们要创建一个vue+ts的项目，也可以直接通过yarn create vite --template vue-ts生成项目。 关于eslint的配置不在此过多描述，根据部门要求创建即可。 配置vite.config.tsvite.config.ts与之前的vue.config.js是比较相似的，但也有一些不同之处，只介绍一些常用功能的配置。 配置基础路径在vue.config.js中我们可以配置publicPath来配置基础路径，在vite中我们通过配置base来实现。 假设我们在开发环境中基础路径配置为’/‘，但是在生产环境中配置为相对路径，可以如下配置： 12345678import { defineConfig } from 'vite'import vue from '@vitejs/plugin-vue'const isProduction = process.env.NODE_ENV === 'production'// https://vitejs.dev/config/export default defineConfig({ plugins: [vue()], base: isProduction ? './' : '',}) 上面我们还引入了defineConfig和vue，前者是为了有良好的代码提示，后者则必须要配置 如果配置了base路径，那么要注意你的路由是否能正常匹配 路由创建的时候也可以在createWebHistory(base)中传入一个base路径 路径配置别名大家使用vue开发都喜欢给src目录配置别名为@，一般都是定义一个resolve方法，用来返回路径。 在vite中我们也可以直接从path模块中引入resolve，不过在这个时候代码编辑器可能会给你一个错误提示。 所以我们需要先安装@types/node供我们正常使用node的模块 1yarn add @types/node 现在我们就可以引入resolve方法了 1234567891011121314151617import { resolve } from 'path'// https://vitejs.dev/config/export default defineConfig({ plugins: [vue()], resolve: { alias: [ { find: '@', replacement: resolve(__dirname, 'src') }, { find: '@coms', replacement: resolve(__dirname, 'src/components') }, ] },}) 按照之前的套路，现在应该就已经完成了，但是现在并不可以，我们还需要在tsconfig.json中进行对应的配置 123456789{ &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, // paths 路径解析起点 &quot;paths&quot;: { &quot;@/*&quot;: [&quot;src/*&quot;], // 别名路径设置 &quot;@coms/*&quot;: [&quot;src/components/*&quot;] } }} 到此我们就可以使用配置的别名进行引入了。 配置proxy代理代理的配置跟之前相比是差不多的，不过proxy不再允许直接配置为字符串了，必须配置为一个对象。 12345678910111213141516171819server: { //服务器主机名 // host: &quot;localhost&quot;, //端口号 port: 5000, //设为 true 时若端口已被占用则会直接退出， // strictPort: true, // cors: true, // 默认启用并允许任何源 open: true, // 在服务器启动时自动在浏览器中打开应用程序 //https.createServer()配置项 //https: false, proxy: { '/testApi': { target: 'http://192.168.1.1:8080', //代理接口 changeOrigin: true, rewrite: (path) =&gt; path.replace(/^\\/testApi/, '') } } } 配置CSS预处理器我们在开发过程中一般不会直接使用css，而是使用预处理器如scss/sass/less等等，虽然vite对他们有原生支持，但是必须要手动安装依赖，以scss为例： 12yarn add dart-sass --devyarn add sass --dev 配置全局css样式文件配置好样式的预处理器之后，我们可以对全局样式进行配置。 将这个全局样式文件注入到项目中，在任何组件中都可以直接使用而不需要任何引入。 假设我们将样式文件目录为 /src/style/main.scss，可以在vite中进行如下配置将样式注入全局 1234567css: { preprocessorOptions: { scss: { additionalData: '@import &quot;@/style/main.scss&quot;;' } } }, 配置路由路由需要我们手动进行添加，目前对vue-router@4版本对ts有不错的支持。 1yarn add vue-router@4 // 可以自行指定版本号，版本不低于4即可 在src目录下新建一个router目录，创建index.ts对路由进行配置 1234567891011121314151617import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'import type { App } from 'vue';const routes: RouteRecordRaw[] = [ { path: '/login', name: 'Login', component: () =&gt; import('@/views/Login.vue') },]export const router = createRouter({ // 如果用哈希模式则history: createWebHashHistory() history: createWebHistory(), // vue-router4, x=&gt;left, y=&gt;top scrollBehavior: () =&gt; ({ top: 0 }), routes}) 之前对scrollBehavior配置使用的x,y在新版本中对应为left,top，其他的配置应该都能看懂 动态路由现在大家在做路由权限的时候大多会将路由信息存储在后台，在用户登录后返回用户对应的路由信息，然后动态的生成路由，所以之前可能会有这个操作： 12345678910let routers = userMenus.map( item =&gt; { return { path: item.path, component: () =&gt; import('@/views/' + item.component), name: item.name }})routers.forEach( route =&gt; { router.addRoute( route ) }) 但是在vite中是不允许你这样动态引入路由组件的，需要使用vite提供的import.meta.glob来实现 例如： 1const modules = import.meta.glob('../views/*.vue') modules就能读取到views下的所有vue文件，Object.keys(modules)就是所有vue文件的路径 所以我们在动态引入组件的时候可以这样： 1component: modules['../views/' + item.component + '.vue'] import.meta.*前边在配置动态路由的时候我们看到了import.meta.glob，与之相对还有一个import.meta.globEager也是用来引入文件的。 还有一些别的方式也是常用的： 环境变量 Vite 在一个特殊的 import.meta.env 对象上暴露环境变量。 .env文件也有多种，我们可以查看一下官方文档。 .env # 所有情况下都会加载.env.local # 所有情况下都会加载，但会被 git 忽略.env.[mode] # 只在指定模式下加载.env.[mode].local # 只在指定模式下加载，但会被 git 忽略 我们可以基于此在不同的环境中配置不同的变量 比如创建.env.development文件配置开发环境变量 12// 开发环境变量 - .env.developmentbaseURL=devURL 创建.env.production文件配置生产环境变量 12// .env.productionbaseURL=proURL 然后我们可以在任何地方通过import.meta.env.baseURL来读取这个变量，并且会根据你当前所处环境的不同读取不同的文件。 静态资源在之前我们想在页面上加载一张本地图片可能会有这种操作 1234567&lt;template&gt; &lt;img :src=&quot;imgUrl&quot; /&gt;&lt;/template&gt;&lt;script&gt;.....imgUrl: require('@/imgs/img.png')&lt;/script&gt; 但是现在vite也不在允许这种操作了，而是提供了新的方案 我们可以定义如下函数，然后传入图片的名称就可以得到图片的URL了 1234567/** * @description 获取图片url * @param { string } name - 图片的完整名称，带后缀名 */export function getImageUrl( name: string ) { return new URL(`../imgs/${name}`, import.meta.url).href} 然后在页面中使用： 1234567&lt;template&gt;&lt;img :src=&quot;imgUrl&quot; /&gt;&lt;/template&gt;&lt;script&gt;...const imgUrl = getImageUrl('img.png')&lt;/script&gt; 状态管理在vue3项目中我们一般不会使用vuex来作为状态管理工具了，而是使用pinia来完成这个功能 在此不过多介绍pinia的使用，可以查看一下文档，用起来比较简单。 我们可以在store目录下新建index.ts生成store实例： 1234import { createPinia } from 'pinia';const store = createPinia();// 导出store，供外部使用pinia时传入store和挂载到vueexport { store }; 然后我们可以创建某一模块功能的store： 123456789101112131415161718192021222324252627// loginStore.tsimport { defineStore } from &quot;pinia&quot;;import { store } from '@/store'export const useLoginStore = defineStore( 'login', { state: () =&gt; ({ msg: '123' }), getters: {}, actions: { /** * @description 获取路由权限 */ getNav () { }, /** * @description 获取用户信息 */ getUserInfo () { } }})export function useLoginStoreWithOut() { return useLoginStore(store);} 正如你所见，pinia是没有mutation的。 我们可以在组件中使用它： 12345&lt;script setup lang='ts'&gt;import { useLoginStore } from '...'const loginStore = useLoginStore()console.log(loginStore.msg) // '123'&lt;/script&gt; 大家可能已经发现了在loginStore.ts文件中我们还定义了一个函数useLoginStoreWithOut，这是因为如果在组件外使用pinia，需要手动传入store实例，具体细节可以查看文档。 事件通信Vue3官方推荐使用mitt等来实现事件通信，以mitt为例： 创建一个工具方法EventBus.ts： 12345678import mitt from 'mitt'// Events 的key是可触发/监听的事件名， value是发送/接收的数据的类型type Events = { change: string}const emitter = mitt&lt;Events&gt;()export default emitter 在组件中就可以引入emitter来实现通信 12345&lt;script setup lang='ts'&gt;// 组件发送import emitter from './EventBus'emitter.emit('change','hello world')&lt;/script&gt; 1234567&lt;script setup lang='ts'&gt;// 组件接收import emitter from './EventBus'emitter.on('change', (str) =&gt; { console.log(str)})&lt;/script&gt; Mock数据前后端分离项目，Mock数据总是不能少的，基于Mockjs进行简单实现一下即可。 123// main.ts// 开发环境且启用Mock时引入Mockprocess.env.NODE_ENV === 'development' &amp;&amp; config.ifMock &amp;&amp; import('@/mock/index') 在/mock/index下进行Mock拦截 123456789101112131415161718192021// /mock/index.tsimport Mock from 'mockjs'Mock.setup({ // 请求延迟时间 ms timeout: &quot;100-300&quot;})const modules = import.meta.globEager('./**/*.ts')const mockModules: any[] = [];Object.keys(modules).forEach((key) =&gt; { // 自定义的工具函数请以_开头，非_开头的都默认为mock数据 if (key.includes('/_')) { return; } // 每个mock数据的文件务必 export default 一个列表 mockModules.push(...modules[key].default);});mockModules.forEach( item =&gt; { Mock.mock(item.url, item.method, item.response)}) 在/mock目录下其他文件配置相关mock接口及返回数据 123456789101112// /mock/mock数据export defualt [ { url: '/login', method: 'post', response: { code: 200, message: '', data: null } }] 如果在/mock目录下需要配置一些工具函数等不是mock数据等内容，命名以_开头，比如_util.ts","link":"/2022/02/11/Vue3-vite-ts%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"title":"Vue3状态管理工具Pinia的使用","text":"Vue3全面拥抱TypeScript，而其自家的状态管理工具Vuex对于TypeScript的支持并不友好，所以在Vue3时代Pinia显然是更好的选择。 Pinia的开发者是Vue的核心开发人员，且Pinia已经被纳入Vue的官方库，其作者也表示将来可能会与Vuex合并，所以学习Pinia并不需要担心他是否适合Vue，他一定是稳定可用的。 简单介绍核心概念Pinia从使用角度和之前的Vuex基本是一致的。只是不再需要mutations了 Store是一个保存状态和业务逻辑的实体，不会绑定到组件树，它承载全局的state。它有三个核心概念： state：存储全局状态，类似组件的data getters：根据已有state封装派生数据，也具有缓存的特性，类似组件的computed actions：用于封装业务逻辑，同步和异步都可以，类似组件的methods，也就不需要mutations了 安装123yarn add pinia // ornpm install pinia 初始化配置123456// main.tsimport { createApp } from 'vue'import App from './App.vue'import { createPinia } from 'pinia'const pinia = createPinia()createApp(App).use(pinia).mount('#app') 语法基本使用我们定义的所有store通过id进行区分，所以id必须是唯一的。 id的传入方式有两种: defineStore( id, { …. }) defineStore({ id: ‘’, …. }) 1234567891011121314151617181920212223242526// store/index.tsimport { defineStore } from &quot;pinia&quot;;export const useMainStore = defineStore( 'main', { /** * 类似于组件的data，用来存储全局状态 * 1. 必须是函数且必须是箭头函数 */ state: () =&gt; { return { count: 100 } }, // state也可以这么简写 // state: () =&gt; ({ // count: 100 // }) /** * 用来封装计算属性，有缓存功能 */ getters: {}, /** * 封装业务逻辑，修改state */ actions: {}}) 在组件中使用： 1234import { useMainStore } from '../store';// 得到容器实例const mainStore = useMainStore()console.log(mainStore.count) 解构数据我们知道在vue3中如果需要解构数据且不丢失响应式需要用到toRefs()，在Pinia中我们也需要使用它提供的storeToRefs()来实现状态数据的解构且保持响应式。 12345678910// store/index.tsimport { defineStore } from &quot;pinia&quot;;export const useMainStore = defineStore( 'main', { state: () =&gt; { return { count: 100, name: 'ali' } },}) 123456789101112131415161718192021222324252627282930&lt;!-- 组件 --&gt;&lt;template&gt; &lt;p&gt;{{mainStore.count}}&lt;/p&gt; &lt;p&gt;{{mainStore.name}}&lt;/p&gt; &lt;hr&gt; &lt;p&gt;{{count}}&lt;/p&gt; &lt;p&gt;{{name}}&lt;/p&gt; &lt;hr&gt; &lt;p&gt; &lt;button @click=&quot;handleChangState&quot;&gt; 修改数据 &lt;/button&gt; &lt;/p&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import { storeToRefs } from 'pinia';import { useMainStore } from '../store';// 得到容器实例const mainStore = useMainStore()// 使用官方API进行解构，类似于Vue3中提供的toRefsconst { count, name } = storeToRefs(mainStore)// 解构出来的数据是ref代理的，所以在js中使用需要加.valueconsole.log(count.value)// 修改state中的数据，解构后的数据也能监听到变化const handleChangState = () =&gt; { mainStore.count += 1}&lt;/script&gt; 状态更新修改state中的数据有多种方式： // 修改数据方式一： 直接修改 12mainStore.count += 1mainStore.name += 'ss' // 修改数据方式二： 修改多个数据建议使用$patch批量更新 1234mainStore.$patch({ count: mainStore.count + 2, name: mainStore.name + '--'}) // 修改数据方式三： $patch一个函数,函数接受一个参数就是state对象，更好的批量更新方式，常用于修改引用类型数据,使用$patch的时候更推荐这种方式 12345mainStore.$patch( state =&gt; { state.count ++ state.name += '--' state.arr.push(4)}) // 修改数据方式四： 通过action来修改数据，逻辑比较多的时候就可以封装到action中来操作，action内部也可以使用$patch来批量更新数据 1234567891011121314151617// store/index.tsactions: { // 一定不能使用箭头函数来定义action，因为箭头函数会绑定外部this，函数内部this就拿不到数据了 // action默认不接受参数，可以接受自定义参数且可以接受多个 changeState( num: number, str: string ) { // actions中通过this来访问state中的数据 // this.count += 3 // this.name += '--' // this.arr.push(4) // actions中一次修改多个数据也推荐使用$patch this.$patch( state =&gt; { state.count += num state.name += str state.arr.push(num) }) }} 12// 组件mainStore.changeState(10, 'ss') 需要注意的一点是：actions中的函数与vue2中的methods类似，一定不能定义成箭头函数，不然会导致函数内部的this指向出问题，拿不到state中的数据 Pinia还提供了$reset方法将容器上的数据重置为初始状态: mainStore.$reset() gettersgetters默认接受一个可选参数：state状态对象 如果传递了state可以帮助ts进行类型推导 如果不传递state使用this来访问，则需要手动指定返回值的类型 如果在getter中需要访问其他getter，就可以使用this的方式来使用，不过注意的是，使用this的话那么getter不能被定义为箭头函数 getter也具有缓存功能，依赖数据不发生变化，不会多次调用 12345678910111213141516171819202122232425262728// store/index.tsimport { defineStore } from &quot;pinia&quot;;export const useMainStore = defineStore( 'main', { state: () =&gt; { return { count: 100, name: 'ali', arr: [1, 2, 3] } }, getters: { // getters默认接收一个可选参数：state状态对象 // 使用state对象可以让ts进行类型推导 count10 (state) { console.log('getters调用了') return state.count + 10 } // 也可以不传递参数，使用this来访问state // 但是这样会导致ts没办法推导出返回值类型，需要手动指定 // 如果用this来访问，就不能使用箭头函数 // count10 () :number { // console.log('getters调用了') // return this.count + 10 // } }, }) 组件外部使用组件外部使用Pinia需要手动传入store实例才可以","link":"/2022/02/25/Vue3%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7Pinia%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"axios取消请求","text":"在日常开发中一般只会在表单提交这种接口做一下防抖，但是最近公司的项目服务器压力大得很，接口越来越慢，所以需要对于重复接口进行取消，减轻一下服务器压力，就有了这个文章。 官方提供的方式在axios0.22版本以上，官方提供了新的取消请求的方式，但由于公司项目用的是axios0.18，所以还在用老办法取消请求。对于老版本官方提供了两种取消请求的方式： 第一种方式123456789const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.post('xx', { name: 'new name'}, { cancelToken: source.token})// 取消请求 (消息参数是可选的)source.cancel('请勿重复提交'); 第二种方式12345678910const CancelToken = axios.CancelToken;let cancel;axios.post('xx', { cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; })});// 取消请求cancel(); 封装一般来说我们都会对axios请求进行封装，设置请求和响应拦截器。 所以可以在请求拦截器中收集新请求，取消重复请求。在响应拦截器中取消对于已完成请求的收集 先说一下思路吧： 我们在这里将请求方式、路径和参数都一致的请求判定为重复请求。 通过Map收集请求提高查找效率。 在拦截器中做相应处理。 请求的收集和移除 定义几个函数来辅助计算 123456789101112131415161718192021222324252627282930313233import qs from 'querystring'const pendingRequestMap = new Map()// 根据请求路径和参数生成请求的keyfunction generateKey4Request(config){ const {method, url, params, data} = config return [method, url, qs.stringify(params), qs.stringify(data)].join(&quot;&amp;&quot;)}// 收集未完成的请求function collectRequest(config){ // 根据请求配置生成key const key = generateKey4Request(config) // 设置cancelToken config.cancelToken = config.cancelToken || new axios.CancelToken(c =&gt; { // 如果当前key不存在，则收集进去 if(!pendingRequestMap.has(key)){ pendingRequestMap.set(key, c) } })}// 检查重复请求并取消function checkRequest(config){ const key = generateKey4Request(config) // 如果这个key存在，也就是存在重复请求，那么就取消这个请求并将其从map中移除 if(pendingRequestMap.has(key)){ // 得到cancelToken const cancelToken = pendingRequestMap.get(key) // 取消请求 cancelToken(key) pendingRequestMap.delete(key) }} 拦截器实现1234567891011121314151617181920212223242526272829303132// 请求拦截器axios.interceptors.request.use( function (config) { // 检查是否存在重复请求 checkRequest(config); // 将当前请求信息添加到 pendingRequestMap中 collectRequest(config); return config; }, (error) =&gt; { return Promise.reject(error); });// 响应拦截器axios.interceptors.response.use( (response) =&gt; { // 请求完成了则从 pendingRequestMap中移除请求 checkRequest(response.config); return response； }, (error) =&gt; { // 出错了该请求也已经结束，也要从 pendingRequestMap中移除请求 checkRequest(error.config || {}); if(axios.isCancel(error)){ console.log(error.message); }else { // 自行处理异常请求 } return Promise.reject(error); }); 注意我们经常会使用axios.create()创建实例来使用，但是需要注意的是，通过axios.create()创建的实例身上没有Cancel,CancelToken,all这些方法。 贴一段源码大家就知道为什么没有这些方法了： 123456789101112131415161718192021222324252627282930313233function createInstance(defaultConfig) { var context = new Axios(defaultConfig); var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance utils.extend(instance, Axios.prototype, context); // Copy context to instance utils.extend(instance, context); return instance;}// Create the default instance to be exportedvar axios = createInstance(defaults);// Expose Axios class to allow class inheritanceaxios.Axios = Axios;// Factory for creating new instancesaxios.create = function create(instanceConfig) { return createInstance(utils.merge(defaults, instanceConfig));};// Expose Cancel &amp; CancelTokenaxios.Cancel = require('./cancel/Cancel');axios.CancelToken = require('./cancel/CancelToken');axios.isCancel = require('./cancel/isCancel');// Expose all/spreadaxios.all = function all(promises) { return Promise.all(promises);}; 可见，Cancel，CancelToken这些方法是后边加到axios上去的，而通过axios.create创建的实例并没有添加这些方法，如果需要在axios.create创建的实例上使用Cancel方法，需要额外处理。 由于本人没有很优雅的实现方式，在此不表 2022年10月9日更新，又在看axios的源码，想到了一种可能。axios就是把Axios类的一些方法直接复制过来的，那么我把axios的Cancel等方法也复制到axios.create创建的实例身上是否可行呢？","link":"/2022/06/29/axios%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82/"},{"title":"css实现立方体转动动画","text":"最近项目中一些可视化内容需要做一些动画，有一个立方体的转动效果，最开始想着是拿一个3D模型放上去，但是看了看别人的实现方式，发现自己想太多。 灵活运用css的transform属性，实现一个立方体是很容易的。 坐标轴的方向因为要使用到3D到动画效果，所以必须先搞清楚坐标轴的方向。 我们以正对屏幕的角度来说： 水平向右的是X轴正方向 竖直向下的是Y轴正方向 从屏幕指向你的是Z轴正方向 然后说一些常用的transform属性： translatetranslateX是沿着X轴方向移动 translateY是沿着Y轴方向移动 translateZ同理 rotaterotateX是绕X轴旋转 rotateY和rotateZ同理 transform-style: preserve-3d;transform-style用来规定如何在3D空间内呈现被嵌套的元素，有两个值，flat 和 preserve-3d; 默认值是flat，默认情况下元素是层叠的，中心不能交汇。设置为preserve-3d之后元素的中心可以交汇，在此基础上做一些Z轴方向的变化等才能实现3D效果。 编码实现旋转的正方体提前说一点，我们打算做一个边长为300px的正方体。所以下述代码中经常看到150px这个值，这个150px就是为了单个方向移动一半距离，比如说正面向前移动150px，背面向后移动150px，来实现300px的边长。后续不对这个数值再做解释。 html结构如下，box是外层盒子，里边是正方体的六个面 12345678&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;front&quot;&gt;&lt;/div&gt; &lt;div class=&quot;back&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;&lt;/div&gt; 给最外层盒子添加样式，相对定位并且使用3D的效果描述元素 12345.box { position: relative; transform: translateZ(-150px); transform-style: preserve-3d;} 然后对正方体的六个边设置基础的尺寸 12345678910.front,.back,.left,.right,.top,.bottom { width: 300px; height: 300px; position: absolute;} 现在我们开始拼接正方体的六个面，并给予不同的背景色用于区分 正面： 延Z轴正方向移动150px 1234.front { background-color: rgba(255, 0, 0, .5); transform: translateZ(150px);} 背面： 与正面恰好相反，延Z轴负方向移动 1234.back { background-color: rgba(0, 255, 0, .5); transform: translateZ(-150px);} 正反面都很好理解，其余上下左右四个面就需要自己想象一下他的样子，我们需要先移动然后旋转达到效果。 左面： 左边的面我们延X轴负方向移动150px后，其中心点与正反面的左边是对齐的。这时我们让左面延Y轴旋转90度即可。 1234.left { transform: translateX(-150px) rotateY(90deg); background-color: rgba(255, 0, 255, .5);} 其他面同理，直接给出代码： 12345678910111213.right { transform: translateX(150px) rotateY(90deg); background-color: rgba(0, 255, 255, .5);}.top { transform: translateY(-150px) rotateX(90deg); background-color: rgba(0, 0, 255, .5);}.bottom { transform: translateY(150px) rotateX(90deg); background-color: rgba(255, 255, 0, .5);} 这样我们的正方体就画好了，只要加一个旋转动画就能看到效果了。 简单的加一个动画 123456789101112131415.box { position: relative; // transform: translateZ(-150px); transform-style: preserve-3d; animation: rotate 3s linear infinite; // 这个是新加的}@keyframes rotate { from { transform: rotateX(0) rotateY(0); } to { transform: rotateX(360deg) rotateY(360deg); }} 这样正方体就可以转起来了。","link":"/2022/05/26/css%E5%AE%9E%E7%8E%B0%E7%AB%8B%E6%96%B9%E4%BD%93%E8%BD%AC%E5%8A%A8%E5%8A%A8%E7%94%BB/"},{"title":"Vue2中的插槽编写","text":"刚在官网看完了keep-alive，就随手翻了翻，看到了插槽的内容 在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除且仍在文档中的 attribute。 What?大变天了？我好像跟不上时代了，既然都看到了，就把官网的内容再过一遍，会的加深记忆，不会的好好学习一下。 正如vue官网所说，slot和slots-cope已经被废弃了，虽然在vue2.x中仍然被支持，但是不会出现到vue3中，就借此机会把官网有关于插槽的内容过一遍。 默认插槽组件中的内容就默认加载到默认插槽中 12345678910111213141516&lt;!-- 子组件 --&gt;&lt;template&gt;&lt;div&gt; &lt;h1&gt;子组件的内容&lt;/h1&gt; &lt;!-- 插槽 --&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;&lt;/template&gt;&lt;!-- 父组件 --&gt;&lt;Child&gt; &lt;!-- 父组件标签内的内容会放到默认插槽 --&gt; &lt;h3&gt; 父组件要放入子组件插槽中的内容 &lt;/h3&gt;&lt;/Child&gt; 具名插槽当子组件中存在多个插槽时，则需要对插槽进行命名用于区分 不对插槽命名则会有默认名为default 123456789&lt;!-- 子组件child --&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;!-- 插槽 --&gt; &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;slot2&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 使用新的slot语法 123456789101112&lt;!-- 父组件 --&gt;&lt;Child&gt; &lt;!-- v-slot:可以用#代替简写为&lt;template #slot1&gt; --&gt; &lt;template v-slot:slot1&gt; &lt;img /&gt; &lt;a /&gt; &lt;/template&gt; &lt;template #slot2&gt; &lt;img /&gt; &lt;a /&gt; &lt;/template&gt;&lt;/Child&gt; 作用域插槽slot-scope语法已经被废弃，我们现在使用带值的v-slot来访问作用域插槽 123456789101112131415161718192021222324252627282930313233&lt;!-- 子组件child --&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;!-- 插槽: 这里传递的数据会传给插槽的使用者 --&gt; &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data(){ return { games: [] } } }&lt;/script&gt;&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;!-- --&gt; &lt;Child&gt; &lt;!-- slotProps包含插槽的所有prop，当然可以自己随意定义名字 --&gt; &lt;!-- 这里使用了默认插槽，所以可以不指定插槽名字为default --&gt; &lt;template v-slot=&quot;slotProps&quot;&gt; &lt;!-- 这里可以使用插槽传递的数据了 --&gt; &lt;ul&gt; &lt;!-- games就是插槽传递出来的 --&gt; &lt;li v-for=&quot;item in slotProps.games&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/Child&gt;&lt;/template&gt; 也可以将数据解构使用 123456789101112&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;!-- --&gt; &lt;Child&gt; &lt;!-- 可以将数据解构使用 --&gt; &lt;template v-slot:default=&quot;{games}&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in games&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/Child&gt;&lt;/template&gt; 也是可以使用缩写形式的： 123456789101112&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;!-- --&gt; &lt;Child&gt; &lt;!-- 使用缩写必须使用明确的插槽名，默认插槽也不能省略 --&gt; &lt;template #default=&quot;{games}&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in games&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/Child&gt;&lt;/template&gt;","link":"/2022/03/31/Vue2%E4%B8%AD%E7%9A%84%E6%8F%92%E6%A7%BD%E7%BC%96%E5%86%99/"},{"title":"mustache源码学习","text":"Vue是前端从业人员绕不开的一个框架，随着学习的深入不免要通过观看Vue的源码深入学习，但是直接看Vue的源码并不是一件简单的事情，我们不如把Vue的各部分内容拆开来一点一点学习，由浅入深。 Vue的模板是一个很方便很受人喜欢的功能，mustache是一个比较老牌的模板引擎，跟Vue有很多相似之处，所以不妨先从mustache学起。 前排说明，关于mustache的内容是通过尚硅谷的一名讲师的课程学习的，感觉老师的教导。 模板引擎就是将数据变成视图的一种优雅的解决方案。 mustache基本用法在学习mustache之前，我们要先了解mustache应该怎么用。 接下来给出几个小例子来简单说下用法，熟悉Vue的同学应该会感觉很亲切。 在md的代码块中写模板字符串，上传之后解析的格式有问题，大家可以复制放到编辑器中看。 基础应用： 渲染123456789101112131415161718&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;script type=&quot;module&quot;&gt; // 记得把mustache的包引入进来哦 import mustache from './mustache.js' // 模板 let templateStr = ` &lt;h1&gt;我买了新出的{{phone}}！&lt;/h1&gt; ` // 数据 let data = { phone: 'Iphone 13' } // 通过模板和数据生成最终视图 let domStr = mustache.render(templateStr, data) document.getElementById('container').innerHTML = domStr &lt;/script&gt;&lt;/body&gt; 基础应用：简单循环123循环通过{{ #循环的数组 }} {{/循环的数组}} 来指定要循环的数组简单循环内部通过 {{ . }} 来指代循环拿到的内容分别对应Vue中的v-for指令和循环的item 123456789101112131415161718192021&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;script type=&quot;module&quot;&gt; import mustache from './mustache.js' // 模板 let templateStr = ` &lt;ul&gt; {{#arr}} &lt;li&gt;{{.}}&lt;/li&gt; {{/arr}} &lt;/ul&gt; ` // 数据 let data = { arr: ['苹果', '三星', '华为'] } // 通过模板和数据生成最终视图 let domStr = mustache.render(templateStr, data) document.getElementById('container').innerHTML = domStr &lt;/script&gt;&lt;/body&gt; 基础应用： 循环12可以直接使用循环内容中的属性对应Vue中的 item.key 来拿到循环内容 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;script type=&quot;module&quot;&gt; import mustache from './mustache.js' // 模板 let templateStr = ` &lt;ul&gt; {{#arr}} &lt;li&gt; &lt;p&gt;姓名： {{name}}&lt;/p&gt; &lt;p&gt;年龄： {{age}}&lt;/p&gt; &lt;p&gt;性别： {{gender}}&lt;/p&gt; &lt;/li&gt; {{/arr}} &lt;/ul&gt; ` // 数据 let data = { arr: [ {name: '小明', age: 12, gender: 'male'}, {name: '小红', age: 13, gender: 'femail'} ] } // 通过模板和数据生成最终视图 let domStr = mustache.render(templateStr, data) document.getElementById('container').innerHTML = domStr &lt;/script&gt;&lt;/body&gt; 基础应用：嵌套数组循环12在循环中在嵌套一层循环对应Vue中 v-for 内部可以继续使用 v-for 12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;script type=&quot;module&quot;&gt; import mustache from './mustache.js' // 模板 let templateStr = ` &lt;ul&gt; {{#arr}} &lt;li&gt; &lt;p&gt;姓名： {{name}}&lt;/p&gt; &lt;p&gt;年龄： {{age}}&lt;/p&gt; &lt;p&gt; 爱好： {{#hobbies}} &lt;span&gt;{{.}}&lt;/span&gt; {{/hobbies}} &lt;/p&gt; &lt;/li&gt; {{/arr}} &lt;/ul&gt; ` // 数据 let data = { arr: [ {'name': '小明', 'age': 22, 'hobbies': ['游泳', '羽毛球']}, {'name': '小明', 'age': 22, 'hobbies': ['游泳', '羽毛球']}, {'name': '小明', 'age': 22, 'hobbies': ['游泳', '羽毛球']}, ] } // 通过模板和数据生成最终视图 let domStr = mustache.render(templateStr, data) document.getElementById('container').innerHTML = domStr &lt;/script&gt;&lt;/body&gt; 基础应用：布尔值123通过 {{#bool}}{{/bool}} 的方式，来根据布尔值决定是否需要显示内部包裹的内容对应于 Vue 的 v-show不过需要注意的是，mustach必须直接给定一个布尔值，而不能给一个算术运算，即便运算结果是一个布尔值，mustache并不会进行运算 12345678910111213141516171819202122&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;script type=&quot;module&quot;&gt; import mustache from './mustache.js' // 模板 let templateStr = ` &lt;ul&gt; {{#show}} &lt;h1&gt;我可以根据布尔值来显示和隐藏哦&lt;/h1&gt; {{/show}} &lt;/ul&gt; ` // 数据 let data = { // 为true则显示，为false则隐藏 show: true } // 通过模板和数据生成最终视图 let domStr = mustache.render(templateStr, data) document.getElementById('container').innerHTML = domStr &lt;/script&gt;&lt;/body&gt; mustache的底层思想我在学习mustache的时候，第一个想到的就是通过正则表达式来实现，然而mustache库是不能用简单的正则表达式来实现的，而是通过将模板字符串转译为tokens，然后结合数据生成dom字符串实现。 正则表达式示例正则表达式其实是可以实现一个比较简单的模板引擎的，但是比较完善的模板引擎肯定是不合适的。 在此就给出一个错误示例了，下面的内容只是通过正则表达式实现一个简单的渲染。 12345678910111213141516171819202122&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;script type=&quot;module&quot;&gt; let templateStr = `&lt;h1&gt;我买了一个{{thing}},好{{mood}}啊&lt;/h1&gt;` let data = { thing: 'Iphone 13', mood: '开心' } // 简单正则，仅匹配{{}} let reg = /\\{\\{(\\w+)\\}\\}/ // render函数 function render(templateStr, data){ return templateStr.replace(reg, function(_, str, c ,d){ // _ 匹配到的内容， str 圆括号捕获到的内容 // c 捕获到的内容的下标 d 原来的字符串 return data[str] }) } let domStr = render(templateStr, data) document.getElementById('container').innerHTML = domStr &lt;/script&gt;&lt;/body&gt; 真正的核心： tokenstokens是一个JS的嵌套数组，说白了就是模板字符串的Js表示 我们熟知的抽象语法树、虚拟节点也是学习了tokens的理念 假设我们有一个模板字符串 1&lt;h1&gt;我买了一个{{thing}}，好{{mood}}啊&lt;/h1&gt; mustache会将其解析为tokens，形式如下： 1234567tokens = [ // 嵌套数组 [&quot;text&quot;, &quot;&lt;h1&gt;我买了一个&quot;], [&quot;name&quot;, &quot;thing&quot;], [&quot;text&quot;, &quot;,好&quot;], [&quot;name&quot;, &quot;mood&quot;], [&quot;text&quot;, &quot;啊&lt;/h1&gt;&quot;]] 当然这只是简单模板的情况，如果模板字符串更为复杂，比如有循环存在的时候，就会被编译为有更深层嵌套的tokens 假设我们有如下的模板字符串： 1234567&lt;div&gt; &lt;ul&gt; {{#arr}} &lt;li&gt;{{.}}&lt;/li&gt; {{/arr}} &lt;/ul&gt;&lt;/div&gt; 由于模板中有循环的存在，所以tokens也会有更深层的嵌套 123456789tokens = [ [&quot;text&quot;, &quot;&lt;div&gt;&lt;ul&gt;&quot;], [&quot;#&quot;, &quot;arr&quot;, [ [&quot;text&quot;, &quot;&lt;li&gt;&quot;], [&quot;name&quot;, &quot;.&quot;], [&quot;text&quot;, &quot;&lt;/li&gt;&quot;] ]], [&quot;text&quot;, &quot;&lt;/ul&gt;&lt;/div&gt;&quot;]] 如果有双重循环呢？那么tokens的嵌套层次也随之更深一层。 我们知道了mustache会把模板字符串编译为tokens，但这远远不够，mustache还会将tokens结合数据解析为dom字符串，这个我们后续再说。 总结一下，mustache库底层主要做了两件事情： 将模板字符串编译为tokens形式 将tokens结合数据，解析为dom字符串 手写mustache库的简单实现Scanner类Scanner类用于扫描模板字符串 我们模仿mustache的用法，自己实现一个MyTemplate。我们的html内容如下： 12345678910111213&lt;body&gt; &lt;script src=&quot;./src/main.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 模板字符串 let templateStr = &quot;我买了一个{{thing}}，好{{mood}}啊&quot; // 数据 let data = { thing: '手机', mood: '开心' } MyTemplate.render(templateStr, data) &lt;/script&gt;&lt;/body&gt; 声明Scanner类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Scanner.js/** * * 扫描器，扫描模板字符串 */export default class Scanner{ constructor(templateStr) { console.log('我是Scanner类',templateStr) // 模板 this.templateStr = templateStr // 指针 this.pos = 0 // 尾巴--当前指针位置及其后边的内容 this.tail = templateStr } // 官方的scan方法,用于跳过花括号，然后在用scanUntil收集花括号内部内容 // 走过指定内容 scan(tag){ if (this.tail.indexOf(tag) == 0){ // tag有多长，指针就后移多少位 this.pos += tag.length this.tail = this.templateStr.substring(this.pos) } } // 官方的sacnUntil方法，用于收集非花括号的内容 // 指针进行扫描，直到遇见指定内容结束，并且能够返回之前路过的内容 scanUntil(stopTag){ // 记录每次开始执行本方法的时候pos的值 let pos_backup = this.pos // 当尾巴的开头不是结束标记的时候，就说明还没扫描到,还要通过eos避免死循环 while (this.eos() &amp;&amp; this.tail.indexOf(stopTag) != 0){ this.pos++ // 没找到stopTag则指针向后走 // 尾巴跟随指针的位置 this.tail = this.templateStr.substring(this.pos) } // 返回本次执行该方法路过的所有字符 return this.templateStr.substring(pos_backup, this.pos) } // 判断指针是否走完，避免 死循环 eos() { return this.pos &lt; this.templateStr.length }} main.js是我们的js程序入口文件 123456789101112131415161718192021222324// main.js// 引入扫描器import Scanner from './Scanner.js'// 全局提供MyTemplatewindow.MyTemplate = { render(templateStr, data){ // 先将模板字符串编译为tokens，通过Scanner类实现 // 实例化一个扫描器，模板字符串作为参数传递 let scanner = new Scanner(templateStr) // let words = scanner.scanUntil('{{') // console.log(scanner.pos) // console.log(words) // 交替执行scan和scanUntil方法，拿到模板的所有内容 while (scanner.pos != templateStr.length){ // 先拿到{{之前的内容，跳过{{再拿到}}之前的内容，再跳过}}以此往复 let words = scanner.scanUntil('{{') console.log(words) scanner.scan('{{') words = scanner.scanUntil('}}') console.log(words) scanner.scan('}}') } }} 将html变为tokens当然接下来的内容还仅限于非嵌套的内容 我们不再通过main.js来调用Scanner，而是通过一个新的方法来实现 Scanner类不做修改，main.js移除对Scanner的调用 123456789101112//main.js// 引入import parseTemplateToTokens from './parseTemplateToTokens.js'// 全局提供MyTemplatewindow.MyTemplate = { render(templateStr, data){ // 通过parseTemplateToTokens()让模板字符变为tokens数组 let tokens = parseTemplateToTokens(templateStr) console.log(tokens) }} 我们用于将Html变为tokens的新函数 1234567891011121314151617181920212223242526272829303132333435363738// parseTemplateToTokens.js/** * * 将模板字符串转换为tokens */// 引入扫描器import Scanner from './Scanner.js'export default function parseTemplateToTokens(templateStr){ let tokens = []; let words; // 创建扫描器 let scanner = new Scanner(templateStr) // 让扫描器工作 while(scanner.eos()){ // 开始标记出现之前的 words = scanner.scanUntil('{{') if(words != ''){ tokens.push(['text', words]) } scanner.scan('{{') // 标记之间的字符 words = scanner.scanUntil('}}') if(words != ''){ // 判断{{}}中间的内容的首字符是否为# if(words[0] == '#'){ tokens.push(['#', words.substring(1)]) // 判断是否为/ }else if (words[0] == '/'){ tokens.push(['/', words.substring(1)]) // 不是特殊符号，所以直接存起来 }else{ tokens.push(['name', words]) } } scanner.scan('}}') } return tokens;} 嵌套数组的形式截止到仙子啊，我们的parseTemplateToTokens方法仅仅将所有内容收集，但是并没有将循环内部的内容生成嵌套数组，所以我们需要对其进行一些修改。 parseTemplateToTokens不再直接返回tokens，而是返回nestTokens(tokens) 真正处理完成的tokens由nestTokens函数返回 1234567891011121314151617181920212223242526272829303132333435363738394041// parseTemplateToTokens.js/** * * 将模板字符串转换为tokens */// 引入扫描器import Scanner from './Scanner.js'// 引入tokens折叠函数、import nestTokens from './nestTokens.js';export default function parseTemplateToTokens(templateStr){ let tokens = []; let words; // 创建扫描器 let scanner = new Scanner(templateStr) // 让扫描器工作 while(scanner.eos()){ // 开始标记出现之前的 words = scanner.scanUntil('{{') if(words != ''){ tokens.push(['text', words]) } scanner.scan('{{') // 标记之间的字符 words = scanner.scanUntil('}}') if(words != ''){ // 判断{{}}中间的内容的首字符是否为# if(words[0] == '#'){ tokens.push(['#', words.substring(1)]) // 判断是否为/ }else if (words[0] == '/'){ tokens.push(['/', words.substring(1)]) // 不是特殊符号，所以直接存起来 }else{ tokens.push(['name', words]) } } scanner.scan('}}') } return nestTokens(tokens);} 而我们在nestTokens中使用栈的数据结构来方便的收集循环内部的内容，实现嵌套数组 123456789101112131415161718192021222324252627282930313233343536373839// nestTokens.js/** * * 折叠token,将tokens整合为嵌套数组 */export default function nestTokens(tokens){ // 结果数组 let nestedTokens = [] // 栈结构 let sections = [] // 收集器,默认指向nestedTokens数组，引用类型值，所以指向的是同一个数组 let collector = nestedTokens for(let i=0; i&lt;tokens.length; i++){ let token = tokens[i] switch(token[0]){ case '#': // 碰到#，入栈 // 收集器中放入这个token，此时collector指向的数据也会放入这个token // 就比如第一次碰到#，nestedTokens也会放入这个token collector.push(token) // 入栈 sections.push(token) // 碰到# 更换收集器 // 给token设置下标为2的项，并且让收集器指向它 collector = token[2] = [] break; case '/': // 碰到/ 出栈 sections.pop() // 弹出项 // 出栈之后改变收集器为栈顶的项 // 如果栈为空了，则指向nestedTokens collector = sections.length &gt; 0 ? sections[sections.length-1][2] : nestedTokens break; default: collector.push(token) } } return nestedTokens;} lookup函数123456789101112131415161718192021222324252627282930// lookup.js/** * * 用于查询data中的嵌套数据 * 可以在dataObj对象中，寻找用连续点符号的keyName对象 * 比如： * dataObj = { * a:{ * b: { * c: 100 * } * } * } * lookup(dataObj, 'a.b.c') 的结果应该是 100 */export default function lookup(dataObj, keyName){ if (keyName.indexOf('.') != -1){ //如果有.符号，但这里没有考虑完全，没有考虑循环中.指代数据的情况 // 临时的变量值用于逐层深入查找值 let temp = dataObj let names = keyName.split('.'); // 'a.b.c' =&gt; ['a', 'b', 'c'] for(let i=0; i&lt;names.length; i++){ temp = temp[names[i]] } return temp } // 如果没有.符号直接返回值 return dataObj[keyName] } renderTemplate函数用于将数组变为dom字符串 12345678910111213141516171819202122232425// renderTemplate.js/** * * 函数的功能是让tokens数组变为dom字符串 */import lookup from &quot;./lookup&quot;export default function renderTemplate(tokens, data){ // 结果字符串 let resultStr = '' // 遍历tokens for(let i = 0,length = tokens.length; i&lt;length; i++){ let token = tokens[i] // 判断类型对结果字符串进行拼接 if(token[0] == 'text'){ resultStr += token[1] } else if(token[0] == 'name'){ // 使用lookup函数防止数据是嵌套的 resultStr += lookup(data,token[1]) }else if(token[0] == '#'){ // #则需要递归 // resultStr += renderTemplate() } } return resultStr} 在主程序main.js中引入 1234567891011121314// main.js// 引入import parseTemplateToTokens from './parseTemplateToTokens.js'import renderTemplate from './renderTemplate.js'// 全局提供MyTemplatewindow.MyTemplate = { render(templateStr, data){ // 通过parseTemplateToTokens()让模板字符变为tokens数组 let tokens = parseTemplateToTokens(templateStr) // 调用renderTemplate函数，让tokens数组变为dom字符串 let domStr = renderTemplate(tokens, data) console.log(domStr) }} 完成递归内容本部分对lookup进行修改，对parseArray进行了定义，对renderTemplate进行了补充，后边两个互相引入，递归调用，多理解 123456789101112131415161718192021222324252627282930// lookup.js/** * * 用于查询data中的嵌套数据 * 可以在dataObj对象中，寻找用连续点符号的keyName对象 * 比如： * dataObj = { * a:{ * b: { * c: 100 * } * } * } * lookup(dataObj, 'a.b.c') 的结果应该是 100 */export default function lookup(dataObj, keyName){ if (keyName.indexOf('.') != -1 &amp;&amp; keyName != '.'){ //如果有.符号且不是.本身，因为简单数组循环中.可以指代数据 // 临时的变量值用于逐层深入查找值 let temp = dataObj let names = keyName.split('.'); // 'a.b.c' =&gt; ['a', 'b', 'c'] for(let i=0; i&lt;names.length; i++){ temp = temp[names[i]] } return temp } // 如果没有.符号直接返回值 return dataObj[keyName] } 1234567891011121314151617181920212223242526// renderTemplate.js/** * * 函数的功能是让tokens数组变为dom字符串 */import lookup from &quot;./lookup.js&quot; // 解析嵌套数据import parseArray from './parseArray.js' // 处理递归export default function renderTemplate(tokens, data){ // 结果字符串 let resultStr = '' // 遍历tokens for(let i = 0,length = tokens.length; i&lt;length; i++){ let token = tokens[i] // 判断类型对结果字符串进行拼接 if(token[0] == 'text'){ resultStr += token[1] } else if(token[0] == 'name'){ // 使用lookup函数防止数据是嵌套的 resultStr += lookup(data,token[1]) }else if(token[0] == '#'){ // #则需要递归 resultStr += parseArray(token, data) } } return resultStr} 123456789101112131415161718192021222324252627// parseArray.js/** * * 处理数组，结合renderTemplate实现递归 */import lookup from &quot;./lookup&quot;;import renderTemplate from &quot;./renderTemplate&quot;;// 接收token，而不收tokensexport default function parseArray(token, data){ // 递归调用的次数由data的长度决定 let v = lookup(data, token[1]) // 拿到#后边的数组名 // 结果字符串 let resultStr = '' // 遍历v这个数组 for(let i=0; i&lt;v.length; i++){ // 递归调用renderTemplate函数 // 这里要补一个'.'属性,因为如果是一个简单数组，.要指代v[i] resultStr += renderTemplate(token[2],{ // 所以我们现在是在v[i]展开的基础上，补一个.属性 // 用于解决简单数据，用.代替数据的方法 ...v[i], '.': v[i], }) } return resultStr} 在主程序main.js中返回最后的DOM字符串 12345678910111213141516// main.js// 引入import parseTemplateToTokens from './parseTemplateToTokens.js'import renderTemplate from './renderTemplate.js'// 全局提供MyTemplatewindow.MyTemplate = { render(templateStr, data){ // 通过parseTemplateToTokens()让模板字符变为tokens数组 let tokens = parseTemplateToTokens(templateStr) // 调用renderTemplate函数，让tokens数组变为dom字符串 let domStr = renderTemplate(tokens, data) return domStr; }} 现在我们就可以在html中使用更复杂的模板，而且可以挂载到真实DOM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; &lt;script src=&quot;/xuni/bundle.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 模板字符串 let templateStr = ` &lt;div&gt; &lt;ol&gt; {{#students}} &lt;li&gt; 学生{{name}}的爱好是 &lt;ol&gt; {{#hobbies}} &lt;li&gt;{{.}}&lt;/li&gt; {{/hobbies}} &lt;/ol&gt; &lt;/li&gt; {{/students}} &lt;/ol&gt; &lt;/div&gt; ` // 数据 let data = { students: [ { 'name': '小明', 'hobbies': ['游泳', '健身'] }, { 'name': '小红', 'hobbies': ['足球', '篮球', '羽毛球'] }, { 'name': '小强', 'hobbies': ['吃饭', '睡觉'] } ] } // 拿到dom let realDomStr = MyTemplate.render(templateStr, data) // 渲染 document.getElementById('container').innerHTML = realDomStr &lt;/script&gt;&lt;/body&gt;","link":"/2021/11/16/mustache%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"title":"js实现随页面滚动切换的tab栏","text":"最近项目有个需求，比较简单，就是顶部有tab栏，点击tab栏页面滚动到对应位置，手动的滚动页面tab栏也要随之切换。项目是基于vue2+ant design vue开发的，本来是想借用组件库来方便实现的，但是ui确实相差甚远，而且想着也是个简单功能，就放弃了使用组件库，转而用js来实现这个逻辑。 实现过程中，发现这虽然只是个简单的知识点，但确实也有一些要注意的地方。 各种各样的高度、距离我们都知道浏览器里有各种各样的高度、距离等等。实现这个功能我们也免不了需要去计算这些高度，但是除了常用的几个，把所有高度都记住确实还比较困难，在此先回顾一下这些内容。 参考文章链接：前端页面内的高度、位置简述 屏幕的宽高screen.height：屏幕高度。 screen.width：屏幕宽度。 screen.availHeight：屏幕可用高度。即屏幕高度减去上下任务栏后的高度，可表示为软件最大化时的高度。 screen.availWidth：屏幕可用宽度。即屏幕宽度减去左右任务栏后的宽度，可表示为软件最大化时的宽度。 任务栏的宽高就可以根据上面的内容去计算出来了。 浏览器宽高window.outerHeight：浏览器高度 window.outerWidth：浏览器宽度 window.innerHeight：浏览器内页面可用高度。此高度包含了水平滚动条的高度(若存在)。可表示为浏览器当前高度去除浏览器边框、工具条后的高度。 window.innerWidth ：浏览器内页面可用宽度；此宽度包含了垂直滚动条的宽度(若存在)。可表示为浏览器当前宽度去除浏览器边框后的宽度。 当然，屏幕与浏览器的宽高可能并不常用，加下来就是一些比较常用的内容了。 body页面的宽高body.offsetHeight：body总高度 body.offsetWidth：body总宽度 body.clientHeight：body展示的高度 body.clientWidth：body展示的宽度 所有元素的位置有些计算是涉及到盒子模型的，在此不过多赘述 clientHeight和clientWidth：元素的内尺寸，不包含边框 offsetHeight和offsetWidth：元素的外尺寸，包含边框， 不包含外边距 offsetTop和offsetLeft：元素的左上角距离已定位的父元素左上角的距离，如果找不到这个父元素那就是body scrollLeft和scrollTop：元素被卷起的高度和宽度 点击tab栏 -&gt; 页面滚动首先说明一下，我的页面中tab栏是粘性定位的，高度为80，也就是说滚动后元素距离页面顶部的高度为80就是一个合适的位置。 页面中内容并没有被已定位的父元素包裹，所以元素的offsetTop就是其距离页面顶部的距离。当然如果你的内容是被已定位元素包裹的，你可以通过 元素的offsetTop + 其定位父元素的offsetTop来计算出元素距离页面顶部的距离。 12// 拿到要滚动到页面顶部的内容元素let elem = this.$refs.tab 页面滚动的操作，我们可以借助window.scrollTo这个api来实现，可以接受一个options对象，options对象接收两个参数top和behavior，top是页面卷起的高度，behavior是滚动的行为。 如果我们没有tab栏，那么卷起 元素距页面顶部的高度，就可以使元素位于页面顶部，但是有tab栏在顶部，所以我们需要去除这个高度。 1234window.scrollTo({ top: elem.offsetTop-80, behavior: 'smooth' // smooth是平滑滚动}) 页面滚动 -&gt; tab栏自动切换此时我们可以通过点击tab栏实现页面滚动到合适的位置，反之我们手动滑动页面，tab栏也需要随之进行切换。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 监听滚动事件，使用节流的原因就不赘述了window.addEventListener('scroll',this.throttle(this.changeTabByScroll, 200))// 节流函数throttle(fn,delay){ let _this = this let valid = true // 这里之所以不用匿名函数，是为了页面卸载掉时候取消监听 function realScrollFn(){ if(!valid){ return; } valid = false setTimeout(()=&gt;{ fn() valid = true },delay) } // scroll事件绑定的函数，暴露到外部用于取消监听 _this.realScrollFn = realScrollFn return realScrollFn}, // 滚动的处理函数changeTabByScroll(){ let _this = this // 页面当前滚动到的位置 let scrollTop = document.documentElement.scrollTop // 每个tab的ref let refNames = ['content1', 'content2', 'content3', 'content4', 'content5', 'content6'] // 如果页面当前卷起的高度的小于最顶部的tab距离页面顶部的高度，那就选中第一个tab即可 if(scrollTop &lt; _this.$refs['content1'][0].offsetTop){ _this.$refs['tabs'].changeTab('content1') return; } // 不然对话对所有的元素进行遍历，对比元素距离页面顶部的高度与页面卷起的高度 refNames.forEach((item)=&gt;{ let elemOffsetTop = _this.$refs[item][0].offsetTop // 此处的数值是元素高度计算出来的，大家需要自己计算 if(scrollTop &lt; elemOffsetTop + 400 &amp;&amp; scrollTop &gt; elemOffsetTop-151){ _this.$refs['tabs'].changeTab(item) return; } })}// 页面卸载的时候取消事件的监听window.removeEventListener('scroll',this.realScrollFn) 兼容问题看起来现在好像没什么问题了对吗？ 但是这引发了一个新的问题，我们滚动页面是可以自动切换tab没有问题的，不过我们点击tab的时候，也会触发页面的滚动，这个页面的滚动也会触发滚动事件，这就会导致我们点击tab的时候tab不能准确的切换到指定的tab，而是跳来跳去。 这让我想到了以前遇到的的一个问题，有两个联动的组件，一个是数值的输入，一个是拖动条，两个都可以用，我们改变了一个，另一个要随之改变，也是导致了一个变动，另一个随之改变，这个随之改变又导致第一个跟随着变动。。。。。。好家伙，开始套娃了。 这次我也采取了跟上次的问题差不多的解决措施，加一个中间变量。因为我们手动对页面进行滚动是没有问题的，只有点击tab的时候才会出现这个问题，所以我们加一个中间变量，用于标识页面的滚动是否是点击tab触发的，如果是，我们就不执行滚动事件。 我用的方法比较low，就是加了个定时器 123456789101112131415161718192021222324252627282930313233// 点击tab事件changeSelectedTab(key){ let _this = this // 标记为通过点击tab触发的滚动 _this.byClick = true // ...执行正常的逻辑 // 添加一个定时器，待指定时间后，再将该值置为false setTimeout(()=&gt;{ _this.byClick = false },500)}, // 节流的函数throttle(fn,delay){ let _this = this let valid = true // 闭包中定义一个有名函数，匿名函数会导致没法取消监听 function realScrollFn(){ // 将这个中间变量加进来，如果是因为点击tab触发的滚动，就不执行函数 if(!valid || _this.byClick){ return; } valid = false setTimeout(()=&gt;{ fn() valid = true },delay) } // scroll事件绑定的函数，暴露到外部用于取消监听 _this.realScrollFn = realScrollFn return realScrollFn}, 最开始是不想通过定时器来做的，但是查阅了关于window.scrollTo这个api，并没有提供完成之后才执行的回调函数，就拿定时器这种取巧的方法来实现了。大家也可以通过promise等方法来准确的控制哦。 这么简单的内容还啰嗦了这么就，感谢能看到这儿。","link":"/2021/11/22/js%E5%AE%9E%E7%8E%B0%E9%9A%8F%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E5%88%87%E6%8D%A2%E7%9A%84tab%E6%A0%8F/"},{"title":"EventEmitter简单实现","text":"Node 的 Events 模块只定义了一个类，就是 EventEmitter，这个类在很多Node 本身以及第三方模块中大量使用，通常是用作基类被继承。 本内容，我们来把EventEmitter的on，once，off，emit方法进行简单的手写实现。 Events模块基本使用events模块大家使用思路基本都一致，都是继承出来使用，但是实现方式多种多样，这里默认大家都知道events模块的使用方式，不再赘述，贴一种基本使用方法吧，让不清楚使用方式的朋友有一个大概了解。 123456789101112131415const EventEmitter = require('events')// 我们一般不会直接使用EventEmitter，而是生成一个类继承EventEmitterfunction MyFun() { }MyFun.prototype = Object.create(EventEmitter.prototype)let myFun = new MyFun()// 订阅事件myFun.on('eventName', () =&gt; { })myFun.on('eventName', () =&gt; { })// 发布事件myFun.emit('eventName') Events手写实现咱们会对基础功能简单的手写实现，就里就不用Function写法直接采用ES6的Class语法来写了。 on与emit方法实现咱们通过on方法订阅事件，通过emit方法来发布事件，按照这个思路，不难写出以下代码： 1234567891011121314151617181920212223242526272829class EventEmitter { constructor() { // 用于收集订阅的事件和对应回调函数 this._events = {} } /** * @description 订阅事件 * @param {string} eventName 事件名 * @param {function} callback 回调函数 */ on(eventName, callback) { if (this._events[eventName]) { this._events[eventName].push(callback) } else { this._events[eventName] = [callback] } } /** * @description 发布事件 * @param {string} eventName 事件名 * @param {*} args 其他参数 */ emit(eventName, ...args) { // 找到对应事件的处理函数以此调用 this._events[eventName].forEach(fn =&gt; { fn(...args) }) }} 看起来好像很顺利，但是不要忽略的一个问题，我们继承的时候只是继承了原型上的方法，在实例上还可能是没有this._events的，所以我们需要做一下判断，如果没有我们要生成一个： 12345678910on(eventName, callback) { if (!this._events) { this._events = {} } if (this._events[eventName]) { this._events[eventName].push(callback) } else { this._events[eventName] = [callback] }} off和once方法实现 先看off方法 通过Array.prototype.filter方法把取消订阅的方法给过滤掉。 12345678910111213/** * @description 取消订阅 * @param {string} eventName 事件名 * @param {function} callback */off(eventName, callback) { if(this._events &amp;&amp; this._events[eventName]){ // filter过滤掉要取消订阅的callback this._events[eventName] = this._events[eventName].filter(fn =&gt; { return fn !== callback }) }} once方法 once方法注意的是只会触发一次，也就是我们要在回调函数执行后取消订阅，所以我们可以封装为一个高阶函数，将这个高阶函数作为订阅的回调函数，在这里执行真正的回调并取消订阅 这里用箭头函数是为了保证this指向没问题 123456789101112/** * @description 只订阅一次 * @param {string} eventName * @param {function} callback */once(eventName, callback) { const one = () =&gt; { callback() this.off(eventName, one) } this.on(eventName, one)} 避坑 上边的代码看起来好像也没什么问题了，但是我们要想一下，如果我们通过once方法订阅了事件，但是在发布事件之前我们就通过off方法取消订阅，这样会不会有问题呢？示例如下： 123const fn = eventEmitter.once('eventName', fn)eventEmitter.off('eventName', fn) 回看我们的once方法，我们对传入的callback进行了封装，最后添加到订阅列表的是一个名为one的方法，而此时我们传入fn方法取消订阅，肯定不能成功的把这个回调函数给过滤掉，所以我们需要在once方法中把传入的回调也收集起来。 once方法修改如下： 123456789once(eventName, callback) { const one = () =&gt; { callback() this.off(eventName, one) } // 如果回调还没触发之前就像调用off方法取消订阅，我们收集到_events中的是one，one与callback肯定不相等会导致不能解绑，所以我们把callback挂载到one的自定义属性上，在off方法中做判断+ one.l = callback; this.on(eventName, one)} 相应的，我们在off方法中也要添加判断： 12345678off(eventName, callback) { if (this._events &amp;&amp; this._events[eventName]) { // filter过滤掉要取消订阅的callback this._events[eventName] = this._events[eventName].filter(fn =&gt; {+ return fn !== callback &amp;&amp; fn.l !== callback }) }} 完整手写代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class EventEmitter { constructor() { // 用于收集订阅的事件和对应回调函数 this._events = {} } /** * @description 订阅事件 * @param {string} eventName 事件名 * @param {function} callback 回调函数 */ on(eventName, callback) { if (!this._events) { this._events = {} } if (this._events[eventName]) { this._events[eventName].push(callback) } else { this._events[eventName] = [callback] } } /** * @description 发布事件 * @param {string} eventName 事件名 * @param {*} args 其他参数 */ emit(eventName, ...args) { // 找到对应事件的处理函数以此调用 this._events[eventName].forEach(fn =&gt; { fn(...args) }) } /** * @description 取消订阅 * @param {string} eventName 事件名 * @param {function} callback */ off(eventName, callback) { if (this._events &amp;&amp; this._events[eventName]) { // filter过滤掉要取消订阅的callback this._events[eventName] = this._events[eventName].filter(fn =&gt; { return fn !== callback &amp;&amp; fn.l !== callback }) } } /** * @description 只订阅一次 * @param {string} eventName * @param {function} callback */ once(eventName, callback) { const one = () =&gt; { callback() this.off(eventName, one) } // 如果回调还没触发之前就像调用off方法取消订阅，我们收集到_events中的是one，one与callback肯定不相等会导致不能解绑，所以我们把callback挂载到one的自定义属性上，在off方法中做判断 one.l = callback; this.on(eventName, one) }}","link":"/2022/10/14/eventEmitter%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"},{"title":"vue2+antd封装cron表达式生成器组件","text":"新公司入职的第二天，接到了一个任务是封装一个cron表达式生成器的组件，一开始人都是懵的，什么是cron表达式？ 项目是vue+antd开发的，所以肯定是基于此对antd的组件二次封装，做一个表达式生成器出来，好在成功在网上找到了前辈们做过的案例，也算是轻松了许多。面向百度编程无疑了。 Cron表达式是什么关于cron表达式的内容，我大多是从这篇博客了解到的。感谢前辈的分享，如果您不喜欢别人转载您的内容，可以联系我删除。 Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式： Seconds Minutes Hours DayofMonth Month DayofWeek Year 或 Seconds Minutes Hours DayofMonth Month DayofWeek 是的，年份是可选的，其余项目是必须的。 cron 表达式最主要的就是在程序中做一些定时任务，后边大家会理解。 cron表达式允许的字符有如下这些： * / ? - L W # , 0-59 Cron表达式怎么写秒秒允许的字符： 0-59 , / - * 0-59中的某一个数字： 表示第26秒 1-10：从1秒到10秒 *：通配符，代表某一秒 1,2,3：多选，表示第1秒和第2秒还有第3秒 3/5：从第3秒开始，每隔5秒触发一次 分分允许的字符：0-59 , / - * 分的用法跟秒是一样的，就不再赘述了。 时时允许的字符：0-23 , / - * 时的用法跟分秒也是一致的，只是可选范围变为了0-23，毕竟每天只有24个小时，可以理解 天/月天/月的允许字符：1-31 , - * / ? L W 前面出现过的字符就不说了，只说前面没出现出的 L：表示一个月中的最后一天 W：表示工作日 LW：表示最后一个工作日 20W：表示距离当月20号最近的工作日，如果20号是工作日那就表示20号，如果20号是周六，那就表示19号，如果20号是周日，那就表示21号 L-2：月底前2天 ?：不知道怎么解释它，代表的是其中某一天，仅仅是一天，跟*是不一样的 天/月 和 天/周 两个必定有一个值为?，记住这一点就好。 月月允许的字符：1-12 , / - * 用法就不多说了，都一样的 天/周天/周允许的字符：1-7 , - * / ? L # 要注意的是，1代表周日，7代表周六。 #比较特殊，如7#2表示第二个周六，#前边的数表示周几，后边的表示第几个 年年允许的字符：????-???? , / - * 我也不清楚年份允许的上下限的值分别是多少，但是大家能用到的肯定没问题。 当然年份也可以留空 生成器组件感谢上天，我也成功在网上找到了前辈封装的组件，虽然有一些问题，但是前辈的代码让我理清了思路，知道怎么去继续往下写，由于原作者是直接在博客放的代码，没有给git地址，所以我把原文的连接放到这里，点击这里看原文哦 作者的思路很明确，我后续的改进也借鉴了作者的思路。 基本思路就是：做了很多的单选，把常见的用法都列出来，生成器每次改变值都重新渲染生成的表达式，点击表达式根据表达式内包含的字符再渲染到生成器。 简单说，写了很多switch,case实现了这个功能。 但是也发现了几个问题： 不管是时分秒还是什么，多选是没问题的，但是如果在多选中只选了一个值，无法成功将表达式渲染到生成器。 在天/周的位置使用#也无法将表达式渲染回生成器 还有两个问题记不住了，基本都做了修复，但是在天/周的位置使用/的用法，我有些理解不了解析出来的内容，被我把这个用法给注释掉了 我把代码放到git上了，需要的话可以自取，其中index.vue只是演示了一下应该怎么用而已，没太多实际意义，需要安装使用于vue2的ant-design-vue哦。 git地址在这里，点它！","link":"/2021/11/19/vue2-antd%E5%B0%81%E8%A3%85cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%9F%E6%88%90%E5%99%A8%E7%BB%84%E4%BB%B6/"},{"title":"一、NextJs14快速上手","text":"从Nextjs13开始，更推荐使用App Router，我们也基于App Router来展开。 我们通过 npx create-next-app@latest 创建项目并使用其默认选项。 在Nextjs13+中，默认都是服务端组件，如果我们要使用 hook 等，则需要通过 'use client' 声明为 客户端组件 路由Nextjs 使用基于文件系统的路由，一个 page.js/ts/jsx/tsx 会作为路由的 UI 进行渲染。 Pages 和 Layouts 和 Templates一个 page.js/ts/jsx/tsx 文件是一个路由的 UI 界面，这个文件总是这个路由子树的叶子节点 一个 layout.tsx 中的内容会在多个子路由页面内共享，可以嵌套，在导航时会保留布局状态和交互，不会重新渲染 最顶层要有一个 Root Layout ，其必须包含 html 和 body 标签，一般来说会使用 app/layout.tsx 作为 Root Layout 但不是必须的 layout 会包裹 page 的内容放到 children 属性的渲染位置 比如我们创建目录结构如下： 1234567- app - dashboard - layout.tsx - page.tsx # 对应路由 /dashboard - settings - layout.tsx - page.tsx # 对应路由 /dashboard/settings 我们代码如下： 123456789// /app/dashboard/layout.tsxexport default function Layout({children}: { children: React.ReactNode}) { return ( &lt;div className=&quot;w-[500px] h-[500px] bg-red-600&quot;&gt; &lt;span&gt;这是/dashboard/layout.tsx&lt;/span&gt; { children } &lt;/div&gt; )} 123456// /app/dashboard/page.tsxexport default function Page() { return ( &lt;div className=&quot;w-[150px] h-[150px] bg-green-500 m-auto mt-[200px]&quot;&gt;dashboard/page.tsx&lt;/div&gt; )} 当我们访问 /dashboard 路由时可以看到如下页面： 此时我们来完善一下/dashboard/setting的路由内容 123456789// /app/dashboard/settings/layout.tsxexport default function Layout({children}: { children: React.ReactNode}) { return ( &lt;div className=&quot;w-[400px] h-[400px] m-auto mt-4 bg-yellow-600&quot;&gt; &lt;span&gt;这是/dashboard/settings/layout.tsx&lt;/span&gt; { children } &lt;/div&gt; )} 123456// /app/dashboard/setting/page.tsxexport default function Page() { return ( &lt;div className=&quot;w-[150px] h-[150px] bg-green-500 m-auto mt-[200px]&quot;&gt;dashboard/settings/page.tsx&lt;/div&gt; )} 当我们访问 /dashboard/settings 路由时可以看到如下页面： 可见其路由渲染规则，layout 可以嵌套且会被下级路由共享， page 作为路由的子节点来渲染页面 template 和 layout 比较相似，也一样会包裹每个子布局与页面，但是在共享 template 的路由之间导航时，不回保留状态，因此在一些依赖于 useState/useEffect 等副作用函数的情况下会更合适。 这里我们在之前的案例基础上，在dashboard目录下新建一个 template.tsx: 123456789// /app/dashboard/template.tsxexport default function Template({children}: { children: React.ReactNode}) { return ( &lt;div className=&quot;w-[450px] h-[450px] m-auto bg-blue-600&quot;&gt; &lt;span&gt;这是/dashboard/template.tsx&lt;/span&gt; { children } &lt;/div&gt; )} 此时再次刷新页面查看 /dashboard/settings 路由对应的页面： 我们可以得出结论，在嵌套情况下， **template 会在 layout 和 child layout 之间进行呈现 ** Link 和 Navigating我们实现路由跳转有两种方式： &lt;Link&gt;&lt;/Link&gt; 组件跳转 useRouter 编程式导航 Link 是扩展的内置标签 a 标签，通过 href 属性指定跳转地址： 12345import Link from 'next/link'export default function Page() { return &lt;Link href=&quot;/dashboard/settings&quot;&gt;Settings&lt;/Link&gt;} useRouter 编程式路由导航，由于用到了 hook, 所以只能用于客户端组件。 123456789101112'use client'import { useRouter } from 'next/navigation'export default function Page() { const router = useRouter() const handleClick = () =&gt; { router.push('/dashboard/settings') } return ( &lt;button type=&quot;button&quot; onClick={handleClick}&gt;Settings&lt;/button&gt; )} 如果是通过用户点击来触发路由导航，我们总是建议使用 Link 组件来实现 路由组在 app 目录下的文件夹名字会被映射为路由的 url，如果我们只想将文件夹用于组织文件而不影响路径，那么就可以使用路由组来实现，语法为 (foldername) 12345678- app - layout.tsx - (marketing) - about - page.tsx # /about - (shop) - account - page.tsx # /account 路由组的命名除了组织代码之外没有特殊意义 使用路由组还要注意避免路径重复 动态路由如果不确定具体的路由路径，可以创建动态路由，语法为 [foldername] 动态路由会作为 params 参数传递 1234// /app/blog/[slug]/page.tsxexport default function Page({params}: {params: {slug: string}}) { return &lt;div&gt;{params.slug}&lt;/div&gt;} 还可以使用 [...foldername] 来捕获后续路由参数，得到的 params 中的参数会是一个数组 平行路由平行路由允许你同时或者有条件的渲染一个或多个页面在同一个layout中。 目录名使用@foldername创建。会作为参数传递给同级的layout。 假设有目录结构为： 123456- app - layout.tsx - @analytics - page.tsx - @team - page.tsx 此时同级的layout即app/layout.tsx会接收这两个slots属性： 123456789101112131415// app/layout.tsxexport default function Layout(props: { children: React.ReactNode analytics: React.ReactNode team: React.ReactNode}) { return ( &lt;div&gt; {porps.children} {/* 可以同时渲染或者有选择的渲染 */} {props.team /* app/team/page.tsx */} {props.analytics /* app/analytics/page.tsx */} &lt;/div&gt; )} children属性是一个隐式的插槽，不需要映射到文件夹。这意味着app/page.tsx相当于app/@children/page.tsx 路由处理程序路由处理程序仅在 App Router 下可用，类似于 Page Router 的 API Routes 路由处理程序定义在一个特殊的文件 route.ts 中，但是同级不能存在一个 page.js/ts/jsx/tsx 文件了。这样如果目录下是 page 文件就是页面， 是 route 文件就是 API 且遵循 Rest API 风格. 路由处理程序在GET请求时默认会进行缓存。请求方法支持GET, POST, PUT, DELETE, HEAD, PATCH, OPTIONS，如果要建立怎么方法的请求，将其作为函数名即可。 比如我们有文件 app/api/v1/blogs/route.ts 文件： 1234567891011121314// GET请求 /api/v1/blogsexport async function GET(request: Request) { const { searchParams } = new URL(request.url) const id = searchParams.get('id') const res = await fetch(`/xxx/xxx/${id}`) const data = await res.json() return Response.json({data})}// POST /api/v1/blogsexport async function POST() {}// PUT /api/v1/blogsexport async function PUT() {} 路由处理程序不进行缓存的几种方式： 将Request对象与GET方法一起使用 使用非GET请求的其他HTTP方法。 使用动态函数 手动指定动态模式 route handler可以根据目录结构来构建RESTful规范的接口,规范的请求方法为： 方法 场景 示例 GET 获取数据 获取单个: GET /api/tasks/1 获取多个: GET /api/tasks?page=1&amp;size=10 POST 创建数据 创建单个: POST /api/tasks PATCH 差量修改数据 修改单个: PATCH /api/tasks/1 PUT 全量修改数据 修改单个: PUT /api/tasks/1 DELETE 删除数据 删除单个: DELETE /api/tasks/1 删除多个: DELETE /api/tasks?ids=1,2,3 接口路径使用资源名词而非动词，动作应该由HTTP Method来体现。 接口路径中的资源名词使用复数。 完成以上功能，需要有文件目录如下： 1234567# 目录结构如下app - api - tasks - route.ts - [id] - route.ts 中间件中间件也是一个特殊的文件，我们将其命名为 middleware.ts，但是要注意需要定义在项目根目录 示例： 12345678910import type { NextRequest } from 'next/server'import { NextResponse } from 'next/server'export function middleware(request: NextRequest) { // 可以使用NextResponse进行重定向 return NextResponse.redirect(new UTL('/home', request.url))}export const config = { // 匹配在哪些路径上应用中间件 matcher: '/about/:path*'} 其他特殊文件前边我们已经说了 layout, page, template, route, middleware 这几个作为文件名的特殊意义，还有一些其他文件也会被路由匹配并有其意义。 loading.tsx - 基于 React.Suspense 创建加载 UI， 渲染完成后自动替换 可以将其效果理解为： 12345&lt;Layout&gt; &lt;Suspense fallback={&lt;Loading /&gt;}&gt; &lt;Page /&gt; &lt;/Suspense&gt;&lt;/Layout&gt; error.tsx - 处理错误 还有比较特殊的目录名，_foldername 以下划线开头的目录作为私有目录，不会被解析为路由，比如我们可以使用 _components 来存放一些用于当前同级页面的组件 数据获取有四种方式使用获取数据： 在服务端组件使用 fetch 在服务端组件使用第三方库 在客户端组件使用 Route Handlers 在客户端组件使用第三方库 第三方库的内容不展开了，后边我们还会说到 React Query， 这里说一下两外两个方式 在服务端组件使用 fetchNextjs 扩展了原生的 fetch， 允许为每个请求配置缓存和重新验证行为 fetch的基本使用： 1234567891011async function getData() { const res = await fetch('...') return res.json()}export default function Page() { const data = await getData() return ( &lt;main&gt;&lt;/main&gt; )} 默认情况下会自动缓存 fetch 请求的数据，即便是 POST 请求也会自动的缓存，除非是在 Route Hanler 中使用 POST 请求 重新验证数据有两种方式： 基于时间的重新验证，在经过一段时间后自动重新验证数据，对于不经常更改且新鲜度不高的数据很适用。 1fetch('http:', { next: { revalidate: 3600 } } ) 按需重新验证，根据事件手动重新验证数据。 1fetch('', { next: { tags: ['collection'] } }) 重新验证： 12345'use server'import { revalidateTag } from 'next/cache'export default async function action() { revalidateTag('collection')} fetch在以下几种情况下不会缓存： cache: 'no-store'添加到请求配置中 revalidate: 0添加到请求配置中 fetch请求位于POST方法的Route Handler中 fetch请求使用动态数据headers/cookies之后发出的 使用const dynamic = 'force-dynamic'路由段 fetchCache路由段配置为跳过缓存 fetch请求使用请求头Authorization / Cookie，并且组件树上有一个未缓存的请求 在客户端组件使用 Route Handlers比如有目录如下： 123456app - api - tasks - route.ts - demo - page.tsx 我们可以这样来处理请求： 123456789101112// app/demo/page.tsx'use client'export default function Page() { const getData = async function() { const res = await fetch('/api/tasks') const data = await res.json() console.log('data:', data) } return ( &lt;button onClick={getData}&gt;click&lt;/button&gt; )} 12345678910111213// app/api/tasks/route.tsexport function GET() { // 操作数据库 const mockData = { code: 0, message: 'success', data: { a: '1', b: '2' } } return Response.json(mockData)} 数据库操作会在后边说到 Prisma 的时候再引入，这里用 mock 数据来模拟一下 Server Action 是一个较新的特性，但是并不能很好的覆盖所有应用场景，所以个人不太推荐使用，这里也不展开说了。 基于以上内容，其实已经可以 Nextjs 的开发了，更全面的内容包括渲染、缓存、优化、配置等内容还是要参考官方文档来看，内容太丰富了，没有条件在这里继续展开了。","link":"/2024/05/09/%E4%B8%80%E3%80%81NextJs14%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"title":"三、ReactQuery数据获取","text":"React Query 有三个核心概念： Queries - 查 Mutations - 增删改 Query Invalidation - 重新查询 TanStack Query 目前支持多种前端框架，我们本章节专注适用于 React 的 React Query 并会在需要做示例的时候使用 Nextjs 示例。 快速上手我们先以官方文档的 Quick Start 示例来演示三个核心概念： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import { useQuery, useMutation, useQueryClient, QueryClient, QueryClientProvider,} from '@tanstack/react-query'// 引入发送请求的API，具体的API内容不关注import { getTodos, postTodo } from '../my-api'// 创建 Query Client实例const queryClient = new QueryClient()function App() { return ( // 在App组件将queryClient注入 &lt;QueryClientProvider client={queryClient}&gt; &lt;Todos /&gt; &lt;/QueryClientProvider&gt; )}function Todos() { // 在我们的业务组件中获取到queryClient实例 const queryClient = useQueryClient() // useQuery用于发送查询请求，对应核心概念之一的 Queries // 会调用queryFn的请求方法，并且拥有自己的queryKey const query = useQuery({ queryKey: ['todos'], queryFn: getTodos }) // useMutation用于创建一个mutation，其功能对应核心概念的 Mutations // mutationFn是执行mutation的时候要调用的函数，但是不会在useMutation的时候立即执行，需要我们在合适的时机手动执行 // onSuccess是mutationFn执行成功之后的回调 const mutation = useMutation({ mutationFn: postTodo, onSuccess: () =&gt; { // queryClient.invalidateQueries可以使指定queryKey的请求失效，失效后会重新执行query请求 // 在这里就是重新执行我们的 getTodos queryClient.invalidateQueries({ queryKey: ['todos'] }) }, }) return ( &lt;div&gt; {/* query查询的结果可以用来渲染，查询成功后会自动更新 */} &lt;ul&gt;{query.data?.map((todo) =&gt; &lt;li key={todo.id}&gt;{todo.title}&lt;/li&gt;)}&lt;/ul&gt; &lt;button onClick={() =&gt; { {/* mutation.mutate手动执行一个mutation，用于实现增删改操作，传递的参数会传递给mutationFn */} mutation.mutate({ id: Date.now(), title: 'Do Laundry', }) }} &gt; Add Todo &lt;/button&gt; &lt;/div&gt; )}render(&lt;App /&gt;, document.getElementById('root')) 在示例代码中，我在适当位置做了注释，查看注释即可。 Nextjs 引入 React Query由于 React Query 需要用于客户端组件，所以我们不能直接在 app/layout.tsx 中注入，我们可以在封装一层组件 1234567891011// components/query-provider.tsx'use client'import { QueryClient, QueryClientProvider } from '@tanstack/react-query'const queryClient = new QueryClient()export default function QueryProvider({children}: {children: React.ReactNode}) { return ( &lt;QueryClientProvider client={queryClient}&gt; {children} &lt;/QueryClientProvider&gt; )} 然后我们在root layout中引入使用: 1234567891011121314151617181920// app/layout.tsx// ...export default function RootLayout({ children,}: Readonly&lt;{ children: React.ReactNode;}&gt;) { return ( &lt;html lang=&quot;en&quot;&gt; &lt;body className={cn( &quot;min-h-screen bg-background font-sans antialiased&quot;, fontSans.variable )}&gt; &lt;QueryProvider&gt; {children} &lt;/QueryProvider&gt; &lt;/body&gt; &lt;/html&gt; );} 这样就可以在业务组件中使用 React Query 了 查Query可以和任何基于Promise的方法（包括GET, POST）一起使用，以从服务器获取数据。如果方法修改了服务器的数据，那么建议使用Mutations而不是Query。 使用useQuery至少需要提供： 查询的唯一key - queryKey 这个唯一的key在内部用于整个应用程序重新提取、缓存和共享查询 返回Promise的函数，他应该解析数据或抛出错误 - queryFn useQuery 返回值useQuery返回的查询结果有所有需要的信息： 1const {isPending, isError, isSucess, status, error, data, isFetching} = useQuery() 在任何时刻，查询只能处于以下状态之一： isPending或者status === 'pending' - 尚无查询数据 isError或者status === 'error' - 查询遇到错误 isSuccess或者status === 'success' - 查询成功且数据可用 除了上边的状态之外，还可以根据状态来获取更多信息： error - 处于isError状态时可以通过error获取错误 data - 处于isSuccess状态时可以通过data获取错误 isFetching - 如果查询正在获取数据，则isFetching = true 通常只需要检查isPending状态，然后检查isError状态，最后假定数据可用并呈现即可。 检查状态可以用isPending, isError等布尔值，也可以用status，两者取其一即可。 queryKeyreact-query的核心是根据查询键管理查询缓存。查询键必须是顶层的数组。可以只包含简单的字符串，也可以和嵌套对象的数组一样复杂。只要是可序列化的，并且对于查询的数据是唯一的，就可以使用： 具有常量值的数组 当查询需要更多信息来唯一描述其数据时，可以使用带有字符串和任意数量的可序列化对象的数组来描述它 如果查询函数依赖于变量， 请将其包含在查询键中 queryFn查询函数可以是返回Promise的任意函数，这个Promise必须返回数据或者抛出错误 queryKey 不仅用于标识想要获取的数据，还可以作为QueryFunctionContext的一部分传递到查询函数中。 1234useQuery({ queryKey: [], queryFn: async (context: QueryFunctionContext) =&gt; {}}) QueryFunctionContext是传递给每个查询函数的对象，包括： queryKey: QueryKey - 查询键 signal?: AbortSignal - 用于取消查询 meta: Record&lt;string, unknown&gt; | undefined - 可以填写有关查询的其他信息 另外，Infinite Queries无限查询会额外传递参数： pageParam: TPageParam - 提取当前页面的page参数 direction: 'forward' | 'backward' - 页面数据的提取方向 读取queryKey的示例： 12345678const [page, setPage] = useState(1)useQuery({ queryKey: ['todos', page, { page }, 'others'], queryFn: async ({queryKey}: QueryFunctionContext) =&gt; { // ['todos', 1, { page: 1 }, 'others'] console.log(queryKey) }}) 接收到的queryKey与定义的完全一致，依然是数组，顺序保持一致。 query options在多个位置之间共享 queryKey 和 queryFn 但使它们彼此位于同一位置的最佳方法之一是使用 queryOptions 帮助程序。在运行时，这个帮助程序只返回你传递给它的任何内容，但它在与 TypeScript 一起使用时有很多优点。您可以在一个位置定义查询的所有可能选项，并且将获取所有这些选项的类型推断和类型安全 1234567891011121314import { queryOptions } from '@tanstack/react-query'function groupOptions(id: number) { return queryOptions({ queryKey: ['groups', id], queryFn: () =&gt; fetchGroups(id), staleTime: 5 * 1000, })}// usage:useQuery(groupOptions(1))useQuery(groupOptions(5)) 对于无限查询，可以使用单独的infiniteQueryOptions帮助程序。 并行查询并行执行查询，最大限度提高查询的并发性。 手动并行查询当并行查询数量没有变化时，不需要做任何工作，只要并排使用任意数量的useQuery或者useinfiniteQuery即可 1234const usersQuery = useQuery()const teamsQuery = useQuery()const projectsQuery = useQuery()... 使用useQueries进行动态并行查询当需要执行的查询数量在不同渲染之间会发生变化，那么不能用手动查询了，可以使用useQueries这个hook，他可以动态执行任意数量的查询。 useQueries接收一个带有queries字段的对象，其值是一个查询对象数组。返回查询结果数组： 12345678910function App({ users }) { const userQueries = useQueries({ queries: users.map(user =&gt; { return { queryKey: ['user', user.id], queryFn: () =&gt; fetchUserById(user.id) } }) })} 这里用的是props来动态生成的请求查询，当然可以根据state或者其他来动态生成查询。 串行查询依赖于先前的查询在执行之前完成。 useQuery 依赖查询只需要使用enabled来告知查询何时准备好运行即可。 123456789101112131415// 获取 userconst { data: user } = useQuery({ queryKey: ['user', email], queryFn: getUserByEmail})const userId = user?.id// 获取 user projectsconst {} = useQuery({ queryKey: ['projects', userId], queryFn: getProjectsByUser, // 直到 userId 存在了才会执行查询 enabled: !!userId,}) useQueries依赖查询useQueries也可以依赖于以前的查询，实现方法： 123456789101112131415161718// 获取 user idsconst { data: userIds } = useQuery({ queryKey: ['users'], queryFn: getUsersData, select: (users) =&gt; users.map(user =&gt; user.id),})// 然后获取用户信息const usersMessage = useQueries({ queries: userIds ? userIds.map(id =&gt; { return { queryKey: ['message', id], queryFn: () =&gt; getMessageByUsers(id) } }) : [] // 如果没有userIds则返回空数组}) 初始数据使用 config.initialData 选项来设置查询的初始数据并跳过初始加载状态 12345const result = useQuery({ queryKey: ['todos'], queryFn: () =&gt; fetch('/todos'), initialData: initialTodos,}) initialData将保存在缓存中，因此不建议向此选项提供占位符或不完整数据，而应该使用placeholderData 占位数据类似于 initialData 选项，但数据不会保存到缓存中。当您有足够的部分（或虚假）数据来成功呈现查询，而实际数据是在后台获取时，这会派上用场 1234567function Todos() { const result = useQuery({ queryKey: ['todos'], queryFn: () =&gt; fetch('/todos'), placeholderData: placeholderTodos, })} 如果访问查询占位符数据的过程非常密集，或者您不想在每次渲染时都执行，则可以记住该值： 12345678function Todos() { const placeholderData = useMemo(() =&gt; generateFakeTodos(), []) const result = useQuery({ queryKey: ['todos'], queryFn: () =&gt; fetch('/todos'), placeholderData, })} placeholderData 也可以是一个函数，您可以在其中访问“上一个”成功 Query 的数据和 Query 元信息。对于希望将一个查询中的数据用作另一个查询的占位符数据的情况，这很有用。当 QueryKey 发生变化时，例如从 [‘['todos', 1]， ['todos', 2]，我们可以继续显示“旧”数据，而不必在数据从一个查询转换到下一个查询时显示加载器。 12345const result = useQuery({ queryKey: ['todos', id], queryFn: () =&gt; fetch(`/todos/${id}`), placeholderData: (previousData, previousQuery) =&gt; previousData,}) 在某些情况下，您可以根据另一个查询的缓存结果提供占位符数据。 1234567891011121314function Todo({ blogPostId }) { const queryClient = useQueryClient(); const result = useQuery({ queryKey: ['blogPost', blogPostId], queryFn: () =&gt; fetch(`/blogPosts/${blogPostId}`), placeholderData: () =&gt; { // Use the smaller/preview version of the blogPost from the 'blogPosts' // query as the placeholder data for this blogPost query return queryClient .getQueryData(['blogPosts']) ?.find((d) =&gt; d.id === blogPostId) }, })} 分页查询分页数据是非常常见的，在React Query中通过在查询键中包含分页信息来实现： 1234const result = useQuery({ queryKey: ['projects', page], queryFn: fetchProjects}) 这样确实可以工作，但是会发生一些奇怪的情况，页码改变时UI 跳入和跳出success和pending状态，因为每个新页面都被视为一个全新的查询。 这种体验是不佳的，React Query中有名为placeholderData的功能，可以解决这个问题。 思路： 在请求新数据时，上次成功提取的数据可用，即使查询键已更改也是如此. 当新数据到达时，以前的数据将无缝交换以显示新data。 isPlaceholderData 可用于了解查询当前为您提供的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import { keepPreviousData, useQuery } from &quot;@tanstack/react-query&quot;;import React from &quot;react&quot;;function Todos() { const [page, setPage] = React.useState(0) const fetchProjects = (page = 0) =&gt; fetch('/api/projects?page=' + page).then((res) =&gt; res.json()) const { isPending, isError, error, data, isFetching, isPlaceholderData, } = useQuery({ queryKey: ['projects', page], queryFn: () =&gt; fetchProjects(page), placeholderData: keepPreviousData, }) return ( &lt;div&gt; {isPending ? ( &lt;div&gt;Loading...&lt;/div&gt; ) : isError ? ( &lt;div&gt;Error: {error.message}&lt;/div&gt; ) : ( &lt;div&gt; {data.projects.map(project =&gt; ( &lt;p key={project.id}&gt;{project.name}&lt;/p&gt; ))} &lt;/div&gt; )} &lt;span&gt;Current Page: {page + 1}&lt;/span&gt; &lt;button onClick={() =&gt; setPage(old =&gt; Math.max(old - 1, 0))} disabled={page === 0} &gt; Previous Page &lt;/button&gt;{' '} &lt;button onClick={() =&gt; { if (!isPlaceholderData &amp;&amp; data.hasMore) { setPage(old =&gt; old + 1) } }} disabled={isPlaceholderData || !data?.hasMore} &gt; Next Page &lt;/button&gt; {isFetching ? &lt;span&gt; Loading...&lt;/span&gt; : null}{' '} &lt;/div&gt; )} 将keepPreviousData设置为placeholderData，会在之后的请求过程中用当前的数据进行占位。 通过isPlaceholderData判断是否是占位数据 关于 Query 的内容就先说这么多吧，这些是常用内容，当然 React Query 支持更多的配置项和操作，自己查阅文档吧 增删改Nextjs示例由于目前还没接触到数据库相关内容，做示例太过于局限，所以决定在下一章节讲 Prisma 与 Nextjs 的基础配合使用，然后在这个基础上做一个相对简单但是增删改查覆盖全面的示例。","link":"/2024/06/08/%E4%B8%89%E3%80%81ReactQuery%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"},{"title":"为什么Proxy和Reflect要配合使用","text":"主要对于Proxy和Reflect的get方法做一些演示，来说明为什么Proxy和Reflect要配合使用 文章内容主要来源于公众号前端大全。当作笔记记录。如有侵扰烦请联系删除。 还是之前说过的一点： Reflect 里的函数都和 Proxy 的陷阱配套，返回值的类型也和 Proxy 要求的相同，所以如果我们要实现原本的功能，直接调用 Reflect 里对应的函数就好了。 这里主要对于Proxy和Reflect的get方法做一些演示，来说明为什么Proxy和Reflect要配合使用。 Proxy代理，它内置了一系列”陷阱“用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。 Reflect反射，它提供拦截 JavaScript 操作的方法。这些方法与 Proxy [5]的方法相同。 简单来说，我们可以通过 Proxy 创建对于原始对象的代理对象，从而在代理对象中使用 Reflect 达到对于 JavaScript 原始操作的拦截。 单独使用Proxy12345678910111213const obj = { name: 'wang.haoyu',};const proxy = new Proxy(obj, { // get陷阱中target表示原对象 key表示访问的属性名 get(target, key) { console.log('劫持你的数据访问' + key); return target[key] },});proxy.name // 劫持你的数据访问name -&gt; wang.haoyu 当访问我们访问 proxy.name 时实际触发了对应的 get 陷阱，它会执行 get 陷阱中的逻辑，同时会执行对应陷阱中的逻辑，最终返回对应的 target[key] 也就是所谓的 wang.haoyu Proxy中的receiver1234567891011121314const obj = { name: 'wang.haoyu',};const proxy = new Proxy(obj, { // get陷阱中target表示原对象 key表示访问的属性名 get(target, key, receiver) { console.log(receiver === proxy); return target[key]; },});// log: trueproxy.name; 我们在陷阱内部打印 console.log(receiver === proxy); 它会打印出 true ，表示这里 receiver 的确是和代理对象相等的。 所以 receiver 的确是可以表示代理对象，但是这仅仅是 receiver 代表的一种情况而已。 来看另外一个例子： 123456789101112131415161718192021222324const parent = { get value() { return '19Qingfeng'; },};const proxy = new Proxy(parent, { // get陷阱中target表示原对象 key表示访问的属性名 get(target, key, receiver) { console.log(receiver === proxy); // log: false console.log(receiver === obj) // log:true return target[key]; },});const obj = { name: 'wang.haoyu',};// 设置obj继承与parent的代理对象proxyObject.setPrototypeOf(obj, proxy);obj.value 上述的代码同样我在 proxy 对象的 get 陷阱上打印了 console.log(receiver === proxy); 结果却是 false 。 那么你可以稍微思考下这里的 receiver 究竟是什么呢？其实这也是 proxy 中 get 陷阱第三个 receiver 存在的意义。 它是为了传递正确的调用者指向 其实简单来说，get 陷阱中的 receiver 存在的意义就是为了正确的在陷阱中传递上下文。 涉及到属性访问时，不要忘记 get 陷阱还会触发对应的属性访问器，也就是所谓的 get 访问器方法。 我们可以清楚的看到上述的 receiver 代表的是继承与 Proxy 的对象，也就是 obj。 看到这里，我们明白了 Proxy 中 get 陷阱的 receiver 不仅仅代表的是 Proxy 代理对象本身，同时也许他会代表继承 Proxy 的那个对象。 其实本质上来说它还是为了确保陷阱函数中调用者的正确的上下文访问，比如这里的 receiver 指向的是 obj 。 当然，你不要将 revceiver 和 get 陷阱中的 this 弄混了，陷阱中的 this 关键字表示的是代理的 handler 对象。 Reflect中的Receiver我们知道在 Proxy 中（以下我们都以 get 陷阱为例）第三个参数 receiver 代表的是代理对象本身或者继承与代理对象的对象，它表示触发陷阱时正确的上下文。 12345678910111213141516171819202122232425const parent = { name: '19Qingfeng', get value() { return this.name; },};const handler = { get(target, key, receiver) { return Reflect.get(target, key); // 这里相当于 return target[key] },};const proxy = new Proxy(parent, handler);const obj = { name: 'wang.haoyu',};// 设置obj继承与parent的代理对象proxyObject.setPrototypeOf(obj, proxy);// log: 19Qingfengconsole.log(obj.value); 我们稍微分析下上边的代码： 当我们调用 obj.value 时，由于 obj 本身不存在 value 属性。 它继承的 proxy 对象中存在 value 的属性访问操作符，所以会发生屏蔽效果。 此时会触发 proxy 上的 get value() 属性访问操作。 同时由于访问了 proxy 上的 value 属性访问器，所以此时会触发 get 陷阱。 进入陷阱时，target 为源对象也就是 parent ，key 为 value 。 陷阱中返回 Reflect.get(target,key) 相当于 target[key]。 此时，不知不觉中 this 指向在 get 陷阱中被偷偷修改掉了！！ 原本调用方的 obj 在陷阱中被修改成为了对应的 target 也就是 parent 。 自然而然打印出了对应的 parent[value] 也就是 19Qingfeng 。 这显然不是我们期望的结果，当我访问 obj.value 时，我希望应该正确输出对应的自身上的 name 属性也就是所谓的 obj.value =&gt; wang.haoyu 。 那么，Relfect 中 get 陷阱的 receiver 就大显神通了。 12345678910111213141516171819202122232425const parent = { name: '19Qingfeng', get value() { return this.name; },};const handler = { get(target, key, receiver) {- return Reflect.get(target, key);+ return Reflect.get(target, key, receiver); },};const proxy = new Proxy(parent, handler);const obj = { name: 'wang.haoyu',};// 设置obj继承与parent的代理对象proxyObject.setPrototypeOf(obj, proxy);// log: wang.haoyuconsole.log(obj.value); 首先，之前我们提到过在 Proxy 中 get 陷阱的 receiver 不仅仅会表示代理对象本身同时也还有可能表示继承于代理对象的对象，具体需要区别与调用方。这里显然它是指向继承与代理对象的 obj 。 其次，我们在 Reflect 中 get 陷阱中第三个参数传递了 Proxy 中的 receiver 也就是 obj 作为形参，它会修改调用时的 this 指向。 你可以简单的将 Reflect.get(target, key, receiver) 理解成为 target[key].call(receiver)，不过这是一段伪代码，但是这样你可能更好理解。 相信看到这里你已经明白 Relfect 中的 receiver 代表的含义是什么了，没错它正是可以修改属性访问中的 this 指向为传入的 receiver 对象。 针对于 get 陷阱（当然 set 其他之类涉及到 receiver 的陷阱同理）： Proxy 中接受的 Receiver 形参表示代理对象本身或者继承与代理对象的对象。 Reflect 中传递的 Receiver 实参表示修改执行原始操作时的 this 指向。","link":"/2022/07/25/%E4%B8%BA%E4%BB%80%E4%B9%88Proxy%E5%92%8CReflect%E8%A6%81%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8/"},{"title":"二、ShadcnUI组件","text":"ShadcnUI 并不是一个组件库，不通过 npm 分发，而是可重用组件的集合，可以将组件代码复制到自己的应用中使用，并根据自己的需求对其进行调整、自定义，代码是我们自己的。 ShadcnUI 是 React 生态的，支持多个框架下的使用，由于我们是在 Nextjs 分类下的文章，后续的内容也会基于 Nextjs ，其安装方式可以在官方文档上很方便的找到，按照步骤进行操作即可。 使用组件虽然在前边我们说可以复制代码到自己的应用，但是实际开发中我们一般是使用命令行来实现这个过程的，比如: 12# 添加 button 组件npx shadcn-ui@latest add button 执行该命令之后，会在 /components/ui/ 目录下生成对应的组件文件，我们就可以拿来使用了。 12345678import { Button } from &quot;@/components/ui/button&quot;export default function Page() { return ( &lt;div&gt; &lt;Button&gt;按钮&lt;/Button&gt; &lt;/div&gt; )} 各种组件的应用查看文档即可 components.json我们还是要说一下项目配置文件 components.json 比如我们当前项目根目录下会存在该文件： 1234567891011121314151617{ &quot;$schema&quot;: &quot;https://ui.shadcn.com/schema.json&quot;, &quot;style&quot;: &quot;default&quot;, &quot;rsc&quot;: true, &quot;tsx&quot;: true, &quot;tailwind&quot;: { &quot;config&quot;: &quot;tailwind.config.ts&quot;, &quot;css&quot;: &quot;app/globals.css&quot;, &quot;baseColor&quot;: &quot;slate&quot;, &quot;cssVariables&quot;: true, &quot;prefix&quot;: &quot;&quot; }, &quot;aliases&quot;: { &quot;components&quot;: &quot;@/components&quot;, &quot;utils&quot;: &quot;@/lib/utils&quot; }} 我们看一下其中的一些字段： style - 组件样式，初始化后就不能修改了 rsc - React Server Component支持 tsx - tsx支持 tailwind - tailwind css的一些配置 config - tailwind 的配置文件 css - 将tailwind 导入到项目的 css 文件的路径 baseColor - 用于生成组件的默认调色板，初始化后无法更改 cssVariables - 可以选择使用 css 变量 或者 tailwind css 实用程序类进行主题设置，初始化后无法更改 prefix - tailwind 实用程序类的前缀 alias - 实用这里的别名值和路径，从而将你的组件等放到正确的位置","link":"/2024/05/22/%E4%BA%8C%E3%80%81ShadcnUI%E7%BB%84%E4%BB%B6%E5%BA%94%E7%94%A8/"},{"title":"伍:axios1.x改动内容","text":"前边我们对axios0.18.0的源码内容做了解读，但是0.18.0的版本有些老了，从github拉了axios1.0.0-beta版本来看一下有了哪些变动吧 目录结构与入口文件目录结构与旧版本基本一致，只有些许变动。 12345678910111213141516171819lib // 源码目录|---- adapters // 适配器目录| |---- index.js // ++++++++++++++++++++++++| |---- xhr.js // 浏览器xhr| |---- http.js // node环境http||---- cancel // 取消请求相关功能目录| |---- CanceledError.js // ++++++++++++++++++| |---- CancelToken.js| |---- isCancel.js|---- core // 核心代码目录| |---- Axios.js // Axios类，用于创建axios实例| |---- dispatchRequest.js // 封装发送请求的方法| |---- InterceptorManager.js // 拦截器| |---- settle.js| |---- transformData.js // 数据转换|---- helpers // 一些辅助函数|---- defaults // 默认配置 修改为目录|---- axios.js // 真正的入口文件|---- utils.js // 一些公共方法 代码有了些或多或少的改动，位置也有了一些变化，语法也用上了ES6，但是内部的思想还是没有什么大的改动的。 axios.jslib/axios.js加了几个新方法，但是更大的改动我觉得是createInstance这个方法。 1234567891011121314151617function createInstance(defaultConfig) { const context = new Axios(defaultConfig); const instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance utils.extend(instance, Axios.prototype, context, {allOwnKeys: true}); // Copy context to instance utils.extend(instance, context, {allOwnKeys: true}); // Factory for creating new instances instance.create = function create(instanceConfig) { return createInstance(mergeConfig(defaultConfig, instanceConfig)); }; return instance;} 现在create方法是在craeteInstance方法添加到实例上的了，这也就意味着通过axios.creaet()创建的实例依然可以调用create方法，这是与老版本不同的。 axios还添加了一个有意思的方法formToJSON()，但是通过axios.create创建的实例依然不能调用CancelToken等用于取消请求的方法。 CancelTokenCancelToken的改动也挺大的，改用了listeners去收集需要取消的请求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122'use strict';import CanceledError from './CanceledError.js';/** * A `CancelToken` is an object that can be used to request cancellation of an operation. * * @param {Function} executor The executor function. * * @returns {CancelToken} */class CancelToken { constructor(executor) { if (typeof executor !== 'function') { throw new TypeError('executor must be a function.'); } let resolvePromise; this.promise = new Promise(function promiseExecutor(resolve) { resolvePromise = resolve; }); const token = this; // eslint-disable-next-line func-names this.promise.then(cancel =&gt; { if (!token._listeners) return; let i = token._listeners.length; while (i-- &gt; 0) { token._listeners[i](cancel); } token._listeners = null; }); // eslint-disable-next-line func-names this.promise.then = onfulfilled =&gt; { let _resolve; // eslint-disable-next-line func-names const promise = new Promise(resolve =&gt; { token.subscribe(resolve); _resolve = resolve; }).then(onfulfilled); promise.cancel = function reject() { token.unsubscribe(_resolve); }; return promise; }; executor(function cancel(message, config, request) { if (token.reason) { // Cancellation has already been requested return; } token.reason = new CanceledError(message, config, request); resolvePromise(token.reason); }); } /** * Throws a `CanceledError` if cancellation has been requested. */ throwIfRequested() { if (this.reason) { throw this.reason; } } /** * Subscribe to the cancel signal */ subscribe(listener) { if (this.reason) { listener(this.reason); return; } if (this._listeners) { this._listeners.push(listener); } else { this._listeners = [listener]; } } /** * Unsubscribe from the cancel signal */ unsubscribe(listener) { if (!this._listeners) { return; } const index = this._listeners.indexOf(listener); if (index !== -1) { this._listeners.splice(index, 1); } } /** * Returns an object that contains a new `CancelToken` and a function that, when called, * cancels the `CancelToken`. */ static source() { let cancel; const token = new CancelToken(function executor(c) { cancel = c; }); return { token, cancel }; }}export default CancelToken; xhrdispatchRequest基本是没有改动的，但是xhr适配器还是有一些改动的，取消请求的部分也随着CancelToken的变动有了不小的变动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236function progressEventReducer(listener, isDownloadStream) { let bytesNotified = 0; const _speedometer = speedometer(50, 250); return e =&gt; { const loaded = e.loaded; const total = e.lengthComputable ? e.total : undefined; const progressBytes = loaded - bytesNotified; const rate = _speedometer(progressBytes); const inRange = loaded &lt;= total; bytesNotified = loaded; const data = { loaded, total, progress: total ? (loaded / total) : undefined, bytes: progressBytes, rate: rate ? rate : undefined, estimated: rate &amp;&amp; total &amp;&amp; inRange ? (total - loaded) / rate : undefined }; data[isDownloadStream ? 'download' : 'upload'] = true; listener(data); };}export default function xhrAdapter(config) { return new Promise(function dispatchXhrRequest(resolve, reject) { let requestData = config.data; const requestHeaders = AxiosHeaders.from(config.headers).normalize(); const responseType = config.responseType; let onCanceled; function done() { if (config.cancelToken) { config.cancelToken.unsubscribe(onCanceled); } if (config.signal) { config.signal.removeEventListener('abort', onCanceled); } } if (utils.isFormData(requestData) &amp;&amp; utils.isStandardBrowserEnv()) { requestHeaders.setContentType(false); // Let the browser set it } let request = new XMLHttpRequest(); // HTTP basic authentication if (config.auth) { const username = config.auth.username || ''; const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : ''; requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password)); } const fullPath = buildFullPath(config.baseURL, config.url); request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS request.timeout = config.timeout; function onloadend() { if (!request) { return; } // Prepare the response const responseHeaders = AxiosHeaders.from( 'getAllResponseHeaders' in request &amp;&amp; request.getAllResponseHeaders() ); const responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response; const response = { data: responseData, status: request.status, statusText: request.statusText, headers: responseHeaders, config, request }; settle(function _resolve(value) { resolve(value); done(); }, function _reject(err) { reject(err); done(); }, response); // Clean up request request = null; } if ('onloadend' in request) { // Use onloadend if available request.onloadend = onloadend; } else { // Listen for ready state to emulate onloadend request.onreadystatechange = function handleLoad() { if (!request || request.readyState !== 4) { return; } // The request errored out and we didn't get a response, this will be // handled by onerror instead // With one exception: request that using file: protocol, most browsers // will return status as 0 even though it's a successful request if (request.status === 0 &amp;&amp; !(request.responseURL &amp;&amp; request.responseURL.indexOf('file:') === 0)) { return; } // readystate handler is calling before onerror or ontimeout handlers, // so we should call onloadend on the next 'tick' setTimeout(onloadend); }; } // Handle browser request cancellation (as opposed to a manual cancellation) request.onabort = function handleAbort() { if (!request) { return; } reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request)); // Clean up request request = null; }; // Handle low level network errors request.onerror = function handleError() { // Real errors are hidden from us by the browser // onerror should only fire if it's a network error reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request)); // Clean up request request = null; }; // Handle timeout request.ontimeout = function handleTimeout() { let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded'; const transitional = config.transitional || transitionalDefaults; if (config.timeoutErrorMessage) { timeoutErrorMessage = config.timeoutErrorMessage; } reject(new AxiosError( timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request)); // Clean up request request = null; }; // Add xsrf header // This is only done if running in a standard browser environment. // Specifically not if we're in a web worker, or react-native. if (utils.isStandardBrowserEnv()) { // Add xsrf header const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) &amp;&amp; config.xsrfCookieName &amp;&amp; cookies.read(config.xsrfCookieName); if (xsrfValue) { requestHeaders.set(config.xsrfHeaderName, xsrfValue); } } // Remove Content-Type if data is undefined requestData === undefined &amp;&amp; requestHeaders.setContentType(null); // Add headers to the request if ('setRequestHeader' in request) { utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) { request.setRequestHeader(key, val); }); } // Add withCredentials to request if needed if (!utils.isUndefined(config.withCredentials)) { request.withCredentials = !!config.withCredentials; } // Add responseType to request if needed if (responseType &amp;&amp; responseType !== 'json') { request.responseType = config.responseType; } // Handle progress if needed if (typeof config.onDownloadProgress === 'function') { request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true)); } // Not all browsers support upload events if (typeof config.onUploadProgress === 'function' &amp;&amp; request.upload) { request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress)); } if (config.cancelToken || config.signal) { // Handle cancellation // eslint-disable-next-line func-names onCanceled = cancel =&gt; { if (!request) { return; } reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel); request.abort(); request = null; }; config.cancelToken &amp;&amp; config.cancelToken.subscribe(onCanceled); if (config.signal) { config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled); } } // false, 0 (zero number), and '' (empty string) are valid JSON values if (!requestData &amp;&amp; requestData !== false &amp;&amp; requestData !== 0 &amp;&amp; requestData !== '') { requestData = null; } const protocol = parseProtocol(fullPath); if (protocol &amp;&amp; platform.protocols.indexOf(protocol) === -1) { reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config)); return; } // Send the request request.send(requestData); });} 本篇主要是把一些大的变动的内容给列出来了，没有对axios1.x对源码做解读。 至于会不会有axios1.x对源码解读还是看后续的时间吧","link":"/2022/10/27/%E4%BC%8D-axios1-x%E6%94%B9%E5%8A%A8%E5%86%85%E5%AE%B9/"},{"title":"使用hexo+gitee搭建个人博客网站","text":"前言作为一名刚入社会的小程序员，在学校的时候就经常看到前辈们推荐要搭建一个自己的个人博客，不管是对于自己技术的积累还是日后的面试都有着不错的效果。彼时的我并没有理解这个做法的意义，当然时至今日也不是很理解……此前的我遇到技术上的问题亦或是其他值得记录的内容，更加倾向于放到简书、CSDN这些网站上去，感觉这跟自己搭建一个博客网站并没有多大不同，反而更加的便捷，这次是因为家里有一些事情需要回来处理，趁此机会，花了两天时间，借鉴了很多前辈的经验，成功依靠hexo+gitee搭建了自己的个人博客，由于没有太过深入研究，也只是搭建了简单的功能，所以只能给朋友们说一下我的搭建过程，希望能对大家有所帮助。 后续会将之前的笔记整理慢慢搬到博客上，至于后续是多久，别问，问就是拖延症晚期。 背景首先介绍下自己的技术选型，博客选择了hexo来搭建，我也不知道为什么，我看别人推荐的。反正又快又好看还支持markdown，对于我这种基础用户来讲，很够用。当前hexo的默认主题可能不是那么的美观，所以我们大多需要选择一个自己喜欢的主题再去进行配置，在此我选择的是ICARUS，当然这个看个人主观选择，还有其他热门的主题像是Next、Matery等，朋友们挑选自己喜欢的即可（不同主题的配置还是有差异的，后边我只会说下我选择的主题的配置）。 至于博客放在哪儿的问题，也是看个人选择，因为我没有准备买服务器和域名，所以我选择gitee而不是github的原因就是一个访问速度快（不过gitee免费版不能自动更新内容，每次博客更新了需要手动去gitee pages点更新很烦，土豪请忽略这个问题。） 接下来就正式开始吧！ 安装Node安装node直接官网下载一路Next就好，不会的朋友们可以自行百度一下。 安装完之后可以在终端输入node -v和npm -v测试一下是否安装成功。 后续通过npm进行其他包的安装时如果速度很慢，可以尝试安装cnpm或者添加淘宝镜像。 npm install cnpm 或者 npm config set registry https://registry.npm.taobao.org 安装git把本地的网页文件上传到gitee或者github肯定少不了git的帮助。 还是一样这里只给出下载链接，安装过程不多介绍，安装成功后可以通过git --version测试是否安装成功 安装hexo在我们准备存放博客的地方新建一个文件夹，用来存放所有的文件，为了避免一些意外的bug，建议不要使用中文路径。 在该目录下打开终端，windows可以在目录下右键Git Bash Here，mac可以在终端cd到该目录下，定位到该目录下之后，通过输入npm install hexo-cli -g全局安装Hexo，安装过程中可能会出现一些报错，大多都不影响，安装完成后我们通过输入hexo -v验证是否安装成功，如果成功则无视之前都报错即可。 此时已经成功安装了hexo，我们要开始准备初始化我们的博客网站并书写第一篇文章了。 首先输入hexo init初始化文件夹，注意此时文件夹内必须是空的，不能有任何内容。初始化完成之后就可以输入npm install安装必备的组件了，这一步是必不可少的。 接下来介绍几个常用的命令吧，后边会经常用得到： hexo new post “文章名” 创建新文章 hexo clean 清除缓存 hexo g 生成静态网页 hexo s 打开本地服务器 hexo d 推送到远程服务器 我们安装完必备的组件之后，是有一个默认的Hello World文章的，此时我们依次执行hexo g 和hexo s就可以打开http://localhost:4000查看预览效果了。如果想关闭本地服务器则按下ctrl+C即可。 gitee创建仓库打开gitee登录自己的账号，没有则自行注册。创建一个个人仓库，项目名字为yourname.gitee.io，注意名字一定不要写错了。创建之后进入仓库选择服务-Gitee Pages开启Pages服务，首次使用需要实名认证，认证完成后会出现自己的Gitee Pages地址，后续就在该地址访问自己的博客。 为了我们能顺利的把本地的文章推送到Gitee，还需要配置ssh公钥。不会的可以按照官方教程操作。 文章发布文章发布到线上，还需要进行一些简单的配置才可以，我们必须配置好要推送的仓库和分支，hexo才能将文章准确的推送到线上服务器，我们打开博客根目录下的_config.yml文件并拖动到最后，然后进行如下配置即可： 1234567deploy: type: git repo: # 这里配置你的git仓库的ssh地址 gitee: git@gitee.com:yourname/yourname.git # 这里是使用的分支 branch: master 现在本地与线上等环境都已经搭建好了，终于可以动手写自己的第一篇博客了。 输入hexo new post &quot;文章名&quot;会创建一个文章位于source/_posts/文章名.md，打开markdown文件就可以书写自己的第一篇文章了，文章最开始有一些配置项，大家可以先忽略它，后边主题中我们再学习那个是做什么的。接下来我们在markdown文件中书写一些内容，然后回到终端输入hexo g生成静态文件，如果此时想在本地进行预览则输入hexo s开启本地服务器，在http://lcoalhost:4000可以进行预览，如果想到线上去查看，则执行hexo d将静态文件推送到远程服务器上去，推送完成后，就可以去线上网站进行查看了。（前面说过，如果使用的是免费的GItee Pages则需要手动去更新一下线上页面。） 可能有朋友想问怎么让自己的文章在首页有阅读全文的按钮，其实只要在markdown文件中合适的位置添加一个&lt;!-- more --&gt;即可，大家自己尝试一下吧。 ICARUS主题ICARUS现在也有完整的中文文档了，大家可以查看一下文档，很详细。首先说明，我只搭建了简单的博客内容，所以像是评论组件、分享组件、打赏组件都是被我给去掉的，如果大家有需要可以对其进行配置，看一下文档也比较简单，我就说一下我配置的过程吧。 首先安装ICARUS，大家可以clone一下源码来安装，我这里采用的是npm的方式进行安装的： npm install -S hexo-theme-icarus 安装之后我们再配置文件中应用该主题，就是配置仓库时使用过的_config.yml文件 1theme: icarus 我们可以先依次执行一下hexo g和hexo s查看一下有没有成功应用主题，如果有问题请朋友们细心检查一下有没有配置错误，没有问题则进行主题的相关配置了，主题的配置在_config.icarus.yml中完成。 官方给出的这个文档说明基本涵盖了所有的配置项，大家可以看一下详细的配置内容，我会简单说一下比较容易踩坑的部分。 在默认情况下navbar是英文的，如果想改成中文则手动更改即可。sidebar用于配置左右两侧的定位方式，为true则不会随博客内容的滚动而滚动，前端的小伙伴应该比较理解粘性布局，简单说就是当顶部滚动到浏览器顶端时就不会滚动了，而是固定在那里。 widgets用于配置所有的挂件，前面sidebar配置的左右两侧就是用于存放这些挂件的。每个挂件必有的两个属性是position和type，如果所有挂件的position值都一致则博客是两栏布局，如果不一致则是三栏布局。当前也可以定义新的配置文件做自定义配置，比如_config.post.yml的配置仅应用于所有的文章，不会影响其他的页面，其优先级比主题的配置文件要高。像我的博客就是通过在_config.post.yml配置三栏布局，在_config.icarus.yml配置两栏布局实现的。 说一下widgets中的挂件吧，第一个是profile用于配置个人信息，需要注意的一点是，如果头像是通过路径来配置的，路径是以source为起点的，比如配置的头像路径为/img/avatar.jpg，那么图片的路径应该是博客根目录/source/img/avatar.jpg。toc挂件是用于配置目录的，如果要使用目录挂件，那么在文章开头的配置项应该加上toc: true才可以，对，就是前边说到过的文章的配置项，文章的配置项是优先级最高的，但是只作用于当前的文章，也要注意的一点是，toc:与true中间必须要有一个空格，否则不能正常读取，应该是所有的配置项的值前面都要有一个空格，不知道这是yaml语法还是什么原因，我没有去深入探究。categories是文章所属的分类，分类可以有多级，也可以只有一级，比如我们的文章是处于前端/框架/React分类下，则在文章开头进行如下配置： 1234categories: - 前端 - 框架 - React 还有一个需要说一下的挂件是tags标签，给文章添加标签也是在文章开头的配置项中进行的，如果给文章添加一个标签的话可以直接写： tags: 一个标签 如果要添加多个标签的话可以拿列表进行包裹： tags: [&quot;第一个&quot;, &quot;第二个&quot;] 通过这些配置项基本可以完成一个简单博客的搭建了，像其他配置大家可以自行决定进行配置或将其注释掉即可。 跨设备书写博客不可避免的我们会遇到博客写了一半，要更换设备继续书写的情况，我们可以在仓库新建一个分支用来存储博客的源文件，这样每次都把源文件也提交上去，我是新建了一个仓库用来存储源文件的，大家选择自己喜欢的方式即可。当我们提交源文件之后换到新设备上之后，通过如下方式即可继续博客： pull博客源文件 继续书写博客，书写完成后hexo d查看线上是否正常 将源文件push到git仓库 每次换到新设备重复此步骤即可。 结语看到这里，大家应该都已经成功搭建了一个基础的博客，内容比较简单，只希望能带大家入个门，少走一些弯路。 感谢大家看完我这又臭又长的文章，希望大家都好好维护自己的博客哦！ 后续 -部署到github2021年10月使用hexo搭建博客并部署到gitee pages，这一年来运行稳定，但是在2022年10月发现更新的时候gitee pages提示内容涉嫌违规，但是也没有提示具体哪里违规，考虑到国内的审核较为严格也就只能理解了。 所以这次准备迁移到github了，还可以免费解析域名，除了国内访问有时会抽风外一切都很美好。 基于此，在这里做一次教程的更新。 由于前边对部署到gitee已经做了比较多的描述，这里类似的就快速略过了。 ssh一样需要配置，生成方式一样的，只是配置到github上。 还是更改_config.yml文件，把仓库改成github仓库即可。 这样操作完网站就可以访问了，可以自动更新，够香吧？ 接下来说一下配置域名哦，在仓库的设置中找到pages目录下的Custom domain配置我们的域名。网上的教程可能很多是叫你配置一级域名，这里根据自己想配置成哪个域名就在这里输入，二级域名也是可以的。 配置完之后会自动在仓库里生成一个文件CNAME，里边是我们的域名，但是我们每次提交博客都会将其覆盖，所以更推荐把CNAME文件写在博客的源文件里，所以我们可以在博客的source目录下创建CNAME文件 1xxx.xxx.com // 这里配置域名，不要有其他内容 然后就是去做一下域名解析，主机输入我们要解析的二级域名，记录类型为CNAME，记录值就是yourname.github.io.，最后要加一个.一定注意！！！ 这样就可以通过域名访问我们的博客了。","link":"/2021/10/19/%E4%BD%BF%E7%94%A8hexo-gitee%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"title":"使用yarn workspace搭建简单的monorepo项目","text":"前段时间上级主管提出开发过程中使用yarn workspace，之前对其并没有什么了解，对该功能也没有多少热情。知道这两天有同事问我使用yarn workspace管理多个项目，可能会导致项目启动出现问题，经过检查及上网检索大致可以确定是依赖版本的问题导致，就此机会大概了解一下yarn workspace，做点笔记如下： yarn workspace多个包互相引用我们在根目录monorepo中使用yarn工作空间，在monorepo目录下执行yarn init -y生成package.json。新建文件夹packages管理所有的项目 目录如下: | monorepo | – | package.json | – | packages 在packages.json配置如下： 123456789{ &quot;name&quot;: &quot;monorepo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;private&quot;: true, &quot;workspaces&quot;: [ &quot;packages/*&quot; ]} 指定packages目录下所有的都是我们管理的包。 假设我们有两个包分别为package_a和package_b，在两个目录下分别yarn init -y，生成配置文件，进行配置。指定入口文件都为index.js，在b包中引入a包并执行install。 目录如下： | monorepo | – | package.json | – | packages | – | – | package_a | – | – | – | package.json | – | – | – | index.js | – | – | package_b | – | – | – | package.json | – | – | – | index.js 代码如下： 包名一般以 父级名称/包名称 命名 1234567// /monorepo/packages/package_a/package.json{ &quot;name&quot;: &quot;@monorepo/package_a&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;license&quot;: &quot;MIT&quot;} 12// /monorepo/packages/package_a/index.jsconsole.log('this is package a') 1234567891011// /monorepo/packages/package_b/package.json{ &quot;name&quot;: &quot;@monorepo/package_b&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: { // 由于包没有发布，所以需要手动在这里添加包，而不能yarn add &quot;@monorepo/package_a&quot;: &quot;1.0.0&quot; }} 123// /monorepo/packages/package_b/index.jsrequire('@monorepo/backage_a')console.log('this is package b') 在package_b中执行yarn install之后执行node index.js，可以看到如下内容： 12this is package athis is package b 说明package_a被成功引入到package_b中了 要注意的是，由于使用了工作空间，所以node_modules在monorepo目录下，也就是monorepo下边的包可以共用这些依赖 假设我们前后端全部使用ts进行开发，我们对api的一些类型约束在前后端都能用到，我们就可以把所有的接口定义为一个包，这样就可以在前后端代码中引入接口这个包来使用，当然要记得将decleration设置为true生成.d.ts的声明文件 123456789101112// /monorepo/packages/interface/package.json// 我们要对tsconfig进行配置，生成声明文件，假设将文件编译到dist目录下：{ &quot;name&quot;: &quot;@monorepo/interface&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;dist/index.js&quot;, // 入口文件 &quot;types&quot;: &quot;dist/idnex.d.ts&quot;, // 类型声明 &quot;license&quot;: &quot;MIT&quot;, &quot;script&quot;: { &quot;build&quot;: &quot;tsc&quot; }} 管理的项目使用不同版本的依赖需要在monorepo目录下的package.json进行配置，在nohoist中配置的依赖则不会被安装到monorepo目录下的node_modules中，而是会安装到具体某一个项目的目录下。 123456789101112131415// /monorepo/package.json{ &quot;name&quot;: &quot;monorepo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;private&quot;: true, &quot;workspaces&quot;: { &quot;packages&quot;: [ &quot;packages/*&quot; ], &quot;nohoist&quot;: [ &quot;**/bootstrap&quot; ] }} 假设如上配置之后，在某一个包中进行yarn add bootstrap之后不会在根目录的node_modules中安装bootstrap，而会在我们安装命令所在的包中安装这个依赖","link":"/2022/04/12/%E4%BD%BF%E7%94%A8yarn-workspace%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84monorepo%E9%A1%B9%E7%9B%AE/"},{"title":"前端Canvas实现验证码功能","text":"最近在做的项目的登录功能需要通过验证码进行校验，虽然这个功能很常见很常用，但是自己还没有真的手写实现过，于是去网上看了看各个博主的博客，都是推荐通过canvas来实现这个功能，我也看了博主的源码，照着写了一遍，做了一下笔记，由于项目技术栈使用的是vue3+ts，所以下边也是基于此实现的。 页面结构由于是一个Demo页面，结构很简单，一个输入框用于输入验证码，一个canvas用于显示验证码，一个按钮用于验证是否输入正确，由于技术栈使用了ant-design，所以在模板中有使用其中的组件，可以随意替换为普通的输入框与按钮组件。 123456789101112131415161718192021&lt;template&gt;&lt;div style=&quot;padding: 80px;&quot;&gt; &lt;a-input style=&quot;width: 300px;&quot; type=&quot;text&quot; v-model:value=&quot;inputValue&quot; placeholder=&quot;点击验证码刷新&quot; /&gt; &lt;canvas ref=&quot;myCanvas&quot; @click=&quot;refreshCode&quot; width=&quot;120&quot; height=&quot;36&quot; style=&quot;margin: 0 40px;border: 1px solid rgb(136,131,131); border-radius: 4px;&quot; &gt;&lt;/canvas&gt; &lt;a-button type=&quot;primary&quot; @click=&quot;handleSubmit&quot; &gt;提交&lt;/a-button&gt;&lt;/div&gt;&lt;/template&gt; 验证码生成准备基础数据首先要将基础的数据准备好，然后运行我们的生成逻辑，所以我在组件挂载之后执行了生成验证码的函数 以下代码均运行在&lt;script setup&gt;中 12345678910111213141516171819202122232425import { ref, onMounted, Ref } from 'vue'// input 绑定的值let inputValue = ref&lt;string&gt;('')// canvas实例let myCanvas = ref()// canvas画笔, 挂载之后才能拿到canvas元素let context: CanvasRenderingContext2D;// 宽高let canvas_width: number;let canvas_height: number;// 验证码的字符选项let codeArray: string[] = ['A','B','C','E','F','G','H','J','K','L','M','N','P','Q','R','S','T','W','X','Y','Z','1','2','3','4','5','6','7','8','9','0']// 显示的验证码let showNum: string[] = []onMounted(() =&gt; { // canvas画笔, 挂载之后才能拿到canvas元素 context = myCanvas.value.getContext('2d') // 宽高 canvas_width = myCanvas.value.clientWidth canvas_height = myCanvas.value.clientHeight initDrawCode()}) 入口程序initDrawCode方法是绘制验证码的一个入口程序，实现如下 initDrawCode方法是绘制验证码的一个入口程序，实现如下 1234567891011/** * @description 绘制验证码的入口 */const initDrawCode = (): void =&gt; { // 重新绘制则清空画布 context.clearRect(0,0,canvas_width,canvas_height); // 依次绘制验证码，线条遮挡，模糊点遮挡 drawText() drawLine() drawPoint()} 绘制过程在绘制的过程中，画笔颜色是随机生成的，所以先将随机生成颜色的函数放到最前边: 12345678910/** * @description 生成随机颜色 * @returns {string} */const randomColor = (): string =&gt; { let r = Math.floor(Math.random() * 256) let g = Math.floor(Math.random() * 256) let b = Math.floor(Math.random() * 256) return `rgb(${r},${g},${b})`} 验证码的绘制过程中，可以自由控制生成验证码的数量，不过需要注意一下canvas元素的尺寸，要与验证码的数量匹配。 需要注意的一点是，canvas的画笔在旋转角度之后，其坐标轴也会随之旋转，所以我们在将其复位的时候要先复位旋转角度。 验证码绘制过程如下： 12345678910111213141516171819202122232425262728/** * @description 绘制验证码 */const drawText = (): void =&gt; { // 随机4位验证码 for(let i = 0; i &lt;= 3; i++){ // 取一个codeArray长度内的随机下标 let randomIndex = Math.floor(Math.random() * codeArray.length) // 根据下标生成一位验证码 showNum[i] = codeArray[randomIndex] // 产生0-40度的随机角度 let deg = Math.random() * 40 * Math.PI / 180 // 生成文字坐标，初识距离x，y为10和20，文字为24px let x = 10 + i * 20 let y = 20 + Math.random() * 8 context.font = 'bold 24px 微软雅黑' context.translate(x, y) // 画笔位置 context.rotate(deg) // 倾斜 // 随机颜色 context.fillStyle = randomColor() context.fillText(showNum[i], 0, 0) // 绘制完成后画笔恢复到初识的位置和角度 // 避免下次绘制将位置和角度进行累加 // 重点注意，由于我们之前是先移动，后旋转，在旋转之后canvas的坐标轴被改变了，所以此时我们必须先将旋转角度复原，然后移动到原来的位置 context.rotate(-deg) context.translate(-x, -y) }} 遮挡线与模糊点可以让验证码不那么清晰，增加验证难度，当然这不是必须的。 绘制过程如下: 12345678910111213141516171819202122232425262728293031/** * @description 绘制遮挡线 */const drawLine = (): void =&gt; { // 可自行调整线条数量 for (let i = 0; i &lt; 5; i++){ context.strokeStyle = randomColor() context.beginPath() // 开始绘制 // 随机位置 context.moveTo(Math.random()*canvas_width, Math.random()*canvas_height) // 画线到随机位置 context.lineTo(Math.random()*canvas_width, Math.random()*canvas_height) context.stroke() }}/** * @description 生成模糊点 */const drawPoint = (): void =&gt; { // 自由控制模糊点的数量 for(let i = 0; i &lt;= 30; i ++){ context.strokeStyle = randomColor() context.beginPath() let x = Math.random() * canvas_width let y = Math.random() * canvas_height context.moveTo(x, y) context.lineTo(x + 1, y + 1) context.stroke() }} 验证与刷新验证码刷新验证码的操作很简单，再调用一次入口程序即可: 123456/** * @description 刷新验证码 */const refreshCode = (): void =&gt; { initDrawCode()} 验证是否输入正确也是很简单的一件事，去除一下空字符然后统一一下大小写就可以了: 123456789101112131415/** * @description 提交 */const handleSubmit = (): void =&gt; { let v = inputValue.value ? inputValue.value.trim() : '' if(!v){ alert('请输入验证码') return; } if(v.toUpperCase() === showNum.join('').toUpperCase()){ alert('验证成功') return; } alert('验证失败')} 总结整个验证码的生成逻辑其实是比较简单的，就是需要对canvas比较熟悉就能很容易的写出来，不过在这个案例中用到的也都是基础功能，没有太大的难度。 真的很推荐typescript，像我这种对canvas几乎一无所知的，只要约束好了类型，也能根据提示来猜个大概。 完整代码防到下边了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;template&gt;&lt;div style=&quot;padding: 80px;&quot;&gt; &lt;a-input style=&quot;width: 300px;&quot; type=&quot;text&quot; v-model:value=&quot;inputValue&quot; placeholder=&quot;点击验证码刷新&quot; /&gt; &lt;canvas ref=&quot;myCanvas&quot; @click=&quot;refreshCode&quot; width=&quot;120&quot; height=&quot;36&quot; style=&quot;margin: 0 40px;border: 1px solid rgb(136,131,131); border-radius: 4px;&quot; &gt;&lt;/canvas&gt; &lt;a-button type=&quot;primary&quot; @click=&quot;handleSubmit&quot; &gt;提交&lt;/a-button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import { ref, onMounted, Ref } from 'vue'// input 绑定的值let inputValue = ref&lt;string&gt;('')// canvas实例let myCanvas = ref()// canvas画笔, 挂载之后才能拿到canvas元素let context: CanvasRenderingContext2D;// 宽高let canvas_width: number;let canvas_height: number;// 验证码的字符选项let codeArray: string[] = ['A','B','C','E','F','G','H','J','K','L','M','N','P','Q','R','S','T','W','X','Y','Z','1','2','3','4','5','6','7','8','9','0']// 显示的验证码let showNum: string[] = []onMounted(() =&gt; { // canvas画笔, 挂载之后才能拿到canvas元素 context = myCanvas.value.getContext('2d') // 宽高 canvas_width = myCanvas.value.clientWidth canvas_height = myCanvas.value.clientHeight initDrawCode()})/** * @description 绘制验证码的入口 */const initDrawCode = (): void =&gt; { // 重新绘制则清空画布 context.clearRect(0,0,canvas_width,canvas_height); // 依次绘制验证码，线条遮挡，模糊点遮挡 drawText() drawLine() drawPoint()}/** * @description 绘制验证码 */const drawText = (): void =&gt; { // 随机4位验证码 for(let i = 0; i &lt;= 3; i++){ // 取一个codeArray长度内的随机下标 let randomIndex = Math.floor(Math.random() * codeArray.length) // 根据下标生成一位验证码 showNum[i] = codeArray[randomIndex] // 产生0-40度的随机角度 let deg = Math.random() * 40 * Math.PI / 180 // 生成文字坐标，初识距离x，y为10和20，文字为24px let x = 10 + i * 20 let y = 20 + Math.random() * 8 context.font = 'bold 24px 微软雅黑' context.translate(x, y) // 画笔位置 context.rotate(deg) // 倾斜 // 随机颜色 context.fillStyle = randomColor() context.fillText(showNum[i], 0, 0) // 绘制完成后画笔恢复到初识的位置和角度 // 避免下次绘制将位置和角度进行累加 // 重点注意，由于我们之前是先移动，后旋转，在旋转之后canvas的坐标轴被改变了，所以此时我们必须先将旋转角度复原，然后移动到原来的位置 context.rotate(-deg) context.translate(-x, -y) }}/** * @description 绘制遮挡线 */const drawLine = (): void =&gt; { // 可自行调整线条数量 for (let i = 0; i &lt; 5; i++){ context.strokeStyle = randomColor() context.beginPath() // 开始绘制 // 随机位置 context.moveTo(Math.random()*canvas_width, Math.random()*canvas_height) // 画线到随机位置 context.lineTo(Math.random()*canvas_width, Math.random()*canvas_height) context.stroke() }}/** * @description 生成模糊点 */const drawPoint = (): void =&gt; { // 自由控制模糊点的数量 for(let i = 0; i &lt;= 30; i ++){ context.strokeStyle = randomColor() context.beginPath() let x = Math.random() * canvas_width let y = Math.random() * canvas_height context.moveTo(x, y) context.lineTo(x + 1, y + 1) context.stroke() }}/** * @description 生成随机颜色 * @returns {string} */const randomColor = (): string =&gt; { let r = Math.floor(Math.random() * 256) let g = Math.floor(Math.random() * 256) let b = Math.floor(Math.random() * 256) return `rgb(${r},${g},${b})`}/** * @description 刷新验证码 */const refreshCode = (): void =&gt; { initDrawCode()}/** * @description 提交 */const handleSubmit = (): void =&gt; { let v = inputValue.value ? inputValue.value.trim() : '' if(!v){ alert('请输入验证码') return; } if(v.toUpperCase() === showNum.join('').toUpperCase()){ alert('验证成功') return; } alert('验证失败')}&lt;/script&gt;","link":"/2022/03/24/%E5%89%8D%E7%AB%AFCanvas%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD/"},{"title":"使用Lunarvim搭建开发环境","text":"前两个周上班时感觉右手手麻，以为自己是不是年纪轻轻就椎间盘突出压迫神经了，吓人的很，花 500 大洋去医院拍了个 CT, 好消息是医生说没什么事，不是椎间盘的问题，然后问到我的工作，是不是经常用鼠标的问题，我一下子就想到了我那个毫无人体工程学的 magicmouse， 害。 虽然现在已经好了不再手麻了，但是之前就有的学习一下 vim 的念头又被我拾起来了，趁着周末折腾一下配个环境试试。 为什么选 Lunarvim其实在选用 Lunarvim 之前，我在网上已经看了一些帖子了，但是 vim 相关的文章真的不多哦，东拼西凑了一些文章开始用 neovim 来从头配置开发环境，还赶潮流的用了 Lazy.nvim 作为插件管理器，真的是太年轻了，两个晚上没配出来一个能用的环境，直接心态爆炸了。。。 然后就退而求其次，我们 VSCode 装一个 vim 插件，也可以的，但是用着 vim 的快捷键和 VSCode 的快捷键，有点割裂，又想再折腾一下。 这个时候，在网上发现了 spacevim 和 lunarvim，看了一下还是别人的 starter 比较香，最终选用了 Lunarvim。我选择的原因如下： Lunarvim会自动安装打开文件所需要的 LSP 和 treesitter 高亮内容 开箱即用，我没有额外安装任何插件 官网有中文文档，虽然没有全部翻译，但是够用了。 安装Lunarvim 的安装是比较简单的，照着官网教程走即可。我这里碰到了两个坑，可以记录一下： 使用neovim 0.8版本的时候nvm-web-devicons的图标有些不能正常显示，换到了neovim 0.9之后就可以了。 telescope的文本搜索没生效，后边才发现需要本地装一个插件 ripgrep， 直接 brew install ripgrep 即可。 然后我做了一些自己觉得舒服的配置，这个自己根据自己的需求来即可： 1234567891011121314151617181920212223-- config.lua-- ESClvim.keys.insert_mode[&quot;jk&quot;] = &quot;&lt;ESC&gt;&quot;-- 代码块移动lvim.keys.visual_mode[&quot;K&quot;] = &quot;:m '&lt;-2&lt;CR&gt;gv=gv&quot;lvim.keys.visual_mode[&quot;J&quot;] = &quot;:m '&gt;+1&lt;CR&gt;gv=gv&quot;-- 页签左右切换lvim.keys.normal_mode[&quot;&lt;C-n&gt;&quot;] = &quot;:bprevious&lt;CR&gt;&quot;lvim.keys.normal_mode[&quot;&lt;C-m&gt;&quot;] = &quot;:bnext&lt;CR&gt;&quot;-- 窗口lvim.keys.normal_mode[&quot;&lt;leader&gt;vv&quot;] = &quot;&lt;C-w&gt;v&quot; -- 水平新增窗口lvim.keys.normal_mode[&quot;&lt;leader&gt;vh&quot;] = &quot;&lt;C-w&gt;s&quot; -- 垂直新增窗口-- 自定义配置vim.opt.relativenumber = true -- 相对行号vim.opt.termguicolors = true -- 终端真颜色vim.opt.signcolumn = &quot;yes&quot;vim.opt.wrap = true -- 自动换行-- 透明背景要设置这个lvim.transparent_window = true-- 设置主题lvim.colorscheme = &quot;tokyonight-moon&quot; vim语法如果是自己从头配置 vim ，那么真的是可以洋洋洒洒写一大篇配置的文章，但是由于我选用了 Lunarvim， 真的没有什么配置的内容好写了，所以这篇文章的主要目的是搜罗一些常用的 vim 语法记录下来，毕竟在这之前对于 vim 的了解仅限于能打开能退出的程度。。。 在这里分类记录一下 vim 的各个语法，方便查阅。 光标移动相关 命令 行为 h,j,k,l 左，下，上，右 control + u 翻上半页 up control + d 翻下半页 down control + f 翻下一页 forward control + b 翻上一页 backward w 跳到下一个单词的字首 e 跳到下一个单词的字尾 b 跳到上一个单词的字首 0 跳到当前行的行首 ^ 跳到当前行行首的第一个字符 $ 跳到行尾 gg 跳到文本的开头 G 跳到文本的结尾 f + x 在当前行搜索 x 字符，按;跳到下一个x字符 / + x 在文本中搜索 x 字符，按n跳到下一个 复制/删除 命令 行为 dd 删除一行 dw 从光标位置开始删除到单词结束 x 删除当前字符 y 复制光标下的内容 yw 从光标位置开始复制到单词结束 yy 复制一行 p 粘贴内容到当前行的下方 P 粘贴内容到当前行的上方 插入/编辑 命令 行为 i 在光标前进入插入模式 I 光标移动到行首进入插入模式 a 在光标后进入插入模式 A 光标移动到行尾进入插入模式 o 当前行下边新加一行并进入插入模式 O 当前行上边新加一行并进入插入模式 r 按下r之后输入的字符会替换光标下的字符，替换完成后进入普通模式 s 删除光标所在的字符并进入插入模式 S 删除光标所在行并进入插入模式 u 撤销最近的一次操作 control + r 重做，可以恢复撤销的内容 &gt;&gt; 当前行右移 &lt;&lt; 当前行左移 == 自动缩进当前行 保存/退出 命令 行为 :w 保存 :wq 保存并推出 :q 退出，如果修改未保存会提示 :q! 强制退出，放弃修改的内容不保存 对于刚接触 vim 的我来说，以上的命令足够我用了，接下来就可以使用 vim 来做一些简单的工作熟悉一下各种命令了，至于复杂项目，至少短期内应该不会用 vim 来作为主力开发工具，我也没想过用 vim 来作为主力开发工具。","link":"/2023/07/08/%E4%BD%BF%E7%94%A8Lunarvim%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"前端大文件上传实现","text":"文件上传是一个常见的功能，但是大文件上传需要考虑几个问题： 单个请求上传时间及传输大小限制 断点续传 重复文件不上传 … 本节我们实现一个简单的文件上传功能，前端基于react实现，但基本不涉及到react内容。后端采用koa搭建简单后台用于调试。 前端实现 前端： App.tsx 1234567891011121314151617181920212223import { ChangeEvent, useState } from &quot;react&quot;import FileUpdater from &quot;./FileUpdater&quot;function App() { const [progress, setProgress] = useState(0) const handleProgressChange = (value: number) =&gt; { setProgress(value) } const handleFileChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; { const file = e.target.files![0] const updater = new FileUpdater(file, 0.125) updater.onProgressChange(handleProgressChange) updater.upload() } return ( &lt;div&gt; &lt;input id=&quot;file&quot; type=&quot;file&quot; onChange={handleFileChange} /&gt; &lt;span&gt;进度:{progress}&lt;/span&gt; &lt;/div&gt; )}export default App 前端: FileUpdater.ts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189import axios from 'axios'import SparkMD5 from 'spark-md5'interface ChunksItem { chunk: Blob, start: number}class FileUpdater { // 要上传的文件 private file: File // 文件切片数组 private chunks: ChunksItem[] = [] // 上传进度 private uploadProgress: number = 0 // 订阅上传进度变化的回调 private cbs: Function[] = [] // 上传切片的序号 private uploadNum: number = 0 // 已经上传完成的切片数 private uploadedChunkNum: number = 0 // 切片的大小（KB） private chunkSize: number; // 文件上传的并发数 private maxUploadNum: number; // 文件的md5 private md5: string = '' // 是否需要在计算完md5之后执行upload方法，如果在执行upload方法的时候md5已经计算好了，那么为false，否则为true，在计算好之后执行 private needUpload: boolean = false /** * @author zhaolei_hu * @description constructor * @param {File} file 要上传的文件 * @param {number} chunkSize 切片大小,默认1M * @param {number} maxUploadNum 上传并发数 */ constructor(file: File, chunkSize: number = 1024, maxUploadNum: number = 5) { this.file = file this.chunkSize = chunkSize * 1024 this.maxUploadNum = maxUploadNum this.generateFileChunk() this.generateMD5() } /** * @author zhaolei_hu * @description 切分文件 */ generateFileChunk() { const size = this.file.size let start = 0 while (start &lt; size) { this.chunks.push({ chunk: this.file.slice(start, start + this.chunkSize), start: start }) start += this.chunkSize } } /** * @author zhaolei_hu * @description 计算文件md5 */ generateMD5() { const spark = new SparkMD5.ArrayBuffer() const fileReader = new FileReader() let currentChunk = 0 fileReader.onload = (e) =&gt; { spark.append(e.target!.result as ArrayBuffer) currentChunk += 1 if (currentChunk &lt; this.chunks.length) { loadNext() } else { this.md5 = spark.end() this.needUpload &amp;&amp; this.upload() } } const loadNext = () =&gt; { fileReader.readAsArrayBuffer(this.chunks[currentChunk].chunk) } loadNext() } /** * @author zhaolei_hu * @description 上传入口 */ async upload() { if (!this.md5) { // 如果还没有计算出md5，则先不上传，等待md5计算完成 this.needUpload = true return; } // 根据md5去请求后台判断是否已经存在该文件 const exist = await this.checkIfExist() // 如果已经存在则不需要上传 if (exist) { this.uploadProgress = 100 this.triggerProgressChange() // 秒传完成 return; } // 当前可以并发上传的数量 const lth = this.chunks.length &gt; this.maxUploadNum ? this.maxUploadNum : this.chunks.length for (let i = 0; i &lt; lth; i++) { this.uploadChunk(this.chunks[this.uploadNum]) this.uploadNum += 1 } } /** * @author zhaolei_hu * @description 检查文件是否已存在 */ async checkIfExist() { // 根据md5去后台判断 const res:any = await axios.get(`http://localhost:8088/checkExists/${this.md5}`) if (res.data.success) { // 后台约定code为1则已经上传了 return res.data.code === 1 } return false } /** * @author zhaolei_hu * @description 订阅进度变化 */ onProgressChange(cb: Function) { this.cbs.push(cb) } /** * @author zhaolei_hu * @description 通知进度变化 */ triggerProgressChange() { this.cbs.forEach(fn =&gt; { fn(this.uploadProgress) }) } /** * @author zhaolei_hu * @description 上传切片流程 * @param {ChunksItem} chunksItem */ async uploadChunk(chunksItem: ChunksItem) { const fd = new FormData() fd.append('file', chunksItem.chunk) // 存储改切片的开始位置用来做服务器存储的名字，方便排序合并为一个文件 fd.append('start', chunksItem.start + '') fd.append('hash', this.md5) const { success } = await this.postFormData(fd) if (success) { // 该切片上传成功 this.uploadedChunkNum += 1 this.uploadProgress = Math.ceil(100 * this.uploadedChunkNum / this.chunks.length) // 触发回调变化 this.triggerProgressChange() if (this.uploadNum &lt; this.chunks.length) { this.uploadChunk(this.chunks[this.uploadNum]) this.uploadNum += 1 } else { // 上传成功的数量等于切片的数量 if (this.uploadedChunkNum === this.chunks.length) { // 上传完成了，开始合成切片 this.mergeFile() } } } else { this.uploadChunk(chunksItem) } } /** * @author zhaolei_hu * @description 上传数据 * @param {FormData} fd */ async postFormData(fd: FormData) { const res = await axios.post('http://localhost:8088/upload', fd) return { success: res.status &gt;= 200 &amp;&amp; res.status &lt; 300 ? true : false, data: res.data } } /** * @author zhaolei_hu * @description 通知服务器合成切片 */ mergeFile() { axios.get(`http://localhost:8088/mergeFile/${this.md5}/${this.file.name}`) }}export default FileUpdater 后端实现 后端：index.js 1234567891011121314import Koa from 'koa'import { koaBody } from 'koa-body'import cors from 'koa2-cors'const app = new Koa()import router from './routers/router.js'app.use(koaBody())app.use(cors())app.use(router.routes()).use(router.allowedMethods())app.listen(8088, () =&gt; { console.log('server running: 8088')}) 后端： router.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import Router from 'koa-router'import multiparty from 'multiparty'import path from 'node:path'import {fileURLToPath} from 'node:url';import fse from 'fs-extra'import fs from 'node:fs'const router = new Router()const __filename = fileURLToPath(import.meta.url);const __dirname = path.dirname(__filename);const hash2path = {}router.get('/checkExists/:hash', async (ctx, next) =&gt; { const { hash } = ctx.params if (hash2path[hash]) { console.log('已经上传过了') ctx.body = { success: true, msg: '已经上传过了', code: 1, path: hash2path[hash] } } else { ctx.body = { success: true, msg: '没有上传过', code: 0, path: null } } })router.post('/upload', async (ctx, next) =&gt; { const form = new multiparty.Form() const msg = await writeChunk(form, ctx.req) ctx.body = { success: true, msg, }})router.get('/mergeFile/:md5/:name', async (ctx, next) =&gt; { // 合并完成后可以把md5和对应的文件名、文件地址在数据库中存储，方便后续上传新文件匹配md5是否存在 // 如果已经存在就可以把新的文件名及md5存储到数据库，也指向同一个文件地址 const {md5, name} = ctx.params const dirPath = path.resolve(__dirname,'chunks/' + md5) const targetDir = path.resolve(__dirname, 'files') if(!fse.existsSync(targetDir)) { await fse.mkdirs(targetDir) } const filePath = path.resolve(targetDir, name) let dests = fse.readdirSync(dirPath) dests = dests.sort((a, b) =&gt; { return Number(a) - Number(b) }) await mergeFile(dests, filePath, dirPath) await fse.remove(dirPath) hash2path[md5] = filePath ctx.body = { success: true, msg: 'success', file: filePath }})function writeChunk(form, req) { return new Promise((resolve, reject) =&gt; { form.parse(req, async (err, fields, files) =&gt; { if (err) return; // console.log(err, fields, files) // console.log(files.file) const [file] = files.file const [hash] = fields.hash const [start] = fields.start const chunkDir = path.resolve(__dirname, 'chunks/' + hash) if (!fse.existsSync(chunkDir)) { await fse.mkdirs(chunkDir) } if (!fse.existsSync(chunkDir + '/' + start)) { await fse.move(file.path, `${chunkDir}/${start}`) } resolve('上传成功') }) })}const mergeFile = async (dests, filePath, dirPath) =&gt; { let ws = fs.createWriteStream(filePath) for (let i = 0; i &lt; dests.length; i ++) { // 按顺序写入，拿到chunk的路径 const chunkPath = path.resolve(__dirname, dirPath + '/' + dests[i]) await write(ws, chunkPath) }}const write = (ws, chunkPath) =&gt; { return new Promise(resolve =&gt; { let rs = fs.createReadStream(chunkPath) rs.pipe(ws, { end: false}) rs.on('end', () =&gt; { resolve() }) })}export default router 后端的内容写的比较糙，主要是实现一下这个流程。只是在内存中维护了一个已经上传文件的md5，没有再引入数据库。 总结前端实现思路： 将文件根据指定大小切分成多份，然后根据切片计算md5 通过计算出的md5请求后台检测是否已经有相同的文件了，有的话就不用再传一次了可以实现秒传 如果没有改文件，那么需要并发的将切片传给后台。每有一个切片传递完成了，就继续传递下一个切片。 在上传切片的过程中传递了start字段，这是这个切片的开始位置，为了让合并切片的时候用。 上传的进度是通过上传完的切片数/总切片数来得到的，所以每上传完成一个切片，我们会更新一下进度数值。并通过发布订阅的形式告诉页面进度的变化。 在所有切片都上传完成之后，我们发起一个合并文件的请求，请求后台将所有切片合并为一个文件。 后端实现思路： 前端上传文件切片，我们以文件的hash值作为目录名，文件的start作为文件名，存储到磁盘上。 前端所有文件切片上传完成，请求合并的时候，我们根据hash值去找对应的目录，然后拿到该目录下的所有文件的文件名，因为文件名是这个文件的start，所以可以进行排序。然后按照排好的顺序，把切片文件流依次写入到同一个文件中。写入完成后删除之前的切片。 注意！ 前端： 没有实现断点续传，这个需要根据自己的策略来做，可以让后端告知已经上传了哪些切片，也可以前端上传切片之后保存在storage已经上传的。 暂停、取消上传的功能可以使用xhr.abort() 或者 axios.Cancel 相关功能取消正在上传的请求，然后不再继续上传了。如果需要继续上传就是用断点续传的思路来做。 后端： 后端实现很糙，完全为了实现而实现，看起来比较乱，注意思路即可。 为了实现的简易，没有引入数据库，实际开发中不可能在内存里存储映射的。 创建写入流的时候要注意不会自动创建外层的目录，所以需要判断并创建一下。","link":"/2023/03/08/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"title":"前端根据url实现文件下载","text":"往常开发过程中，文件下载的实现都是后端提供一个接口，大多是返回一个Blob对象，然后前端编码实现下载，在这次项目中后端只返回文件的url，需要自己实现下载，突然发现自己连这么基础的问题都解决不了，确实挺离谱的。 通过Blob对象下载先前说了，往常是通过后端返回一个Blob对象来实现下载功能，如果后端返回的是二进制的文件流，我们需要指定ajax请求的响应类型为blob 先看下后端返回Blob的情况下应该怎么实现下载呢。 12345678910async downloadFn(){ // 一个虚假的请求，res就是后端返回的Blob对象，方便后续演示 let res = await downLoad(params) let file_name = '文件名称' let save_blob = new Blob([res]) let save_link = document.createElement('a') save_link.setAttribute('href', window.URL.createObjectURL(save_blob)) save_link.setAttribute('download', file_name) save_link.click()} 就这么简单，关键点就是new Blob和createObjectURL。 注意点是new Blob([data])中的data只能是ArrayBuffer、blob等几种类型，不是所有类型都可以直接放入的。 如果后端不直接返回blob，而是一个文件流，那么需要指定接口的响应类型，其他就同后端直接返回blob一样了 123456789// 请求接口getFile(){ return axios({ method: 'post', url: '', data: '', responseType: 'blob' })} 通过Url实现下载我们在只有一个url的情况下，我最开始通过简单的a标签想实现这个功能，但是并不是那么可行的。 查阅网上前辈的解决方法，找到了一个学习成本最低的，就是我们通过这个url来得到一个Blob对象，然后就跟前边一样了。 1234567891011121314151617181920212223242526272829downloadFile(url){ let file_name = '文件名称' let url2 = url.replace(/\\\\/g, '/') const xhr = new XMLHttpRequest(); xhr.open('GET', url, true); // 指定响应类型 xhr.responseType = 'blob'; // 为了避免大文件影响用户体验，建议加loading xhr.onload = () =&gt; { if (xhr.status === 200) { // 获取文件blob数据并保存 saveAs(xhr.response, fileName); } }; xhr.send();}saveAs(data, name){ const urlObject = window.URL || window.webkitURL || window; const export_blob = new Blob([data]); // 如果要下载excel文件，可以传入配置项(xls格式) // const export_blob = new Blob([data],{type: &quot;application/vnd.ms-excel&quot;}) // 如果要导出.xlsx格式的文件将type更改为： // application/vnd.openxmlformats-officedocument.spreadsheetml.sheet // 如果可以尽量使用xlsx格式 const save_link = document.createElement('a') save_link.href = urlObject.createObjectURL(export_blob); save_link.download = name; save_link.click();} 这个方法呢是先去请求这个url，并将返回的内容格式设置为blob，然后就是一样的new Blob和createObjectURL了。","link":"/2021/12/29/%E5%89%8D%E7%AB%AF%E6%A0%B9%E6%8D%AEurl%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"},{"title":"四、Prisma操作数据库","text":"四、Prisma操作数据库","link":"/2024/06/23/%E5%9B%9B%E3%80%81Prisma%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"叁:dispatchRequest和adapter","text":"书接上回，上节课的内容留下了一个坑，dispatchRequest方法内部究竟做了什么？这一节我们就来看一下其内部实现。 关于取消请求部分的逻辑在这一节会省略掉，以求最简单清晰的去理解整个工作流程。 dispatchRequestdispatchRequest这里我们主要还是对于整体工作流程的一个把控，对于取消请求的内容会进行省略。在该方法中其实也没有真正的发送请求，真正的XMLHttpRequest部分是在适配器中做的，我们会在说完dispatchRequest方法之后再来看一下adapter中的具体实现。 config处理在Axios类的request方法中，我们对于请求拦截器一直在传递一个config，毫无疑问在dispatchRequest方法中也会接收到这个config参数。所以先依次来看一下对于config到处理： 123if (config.baseURL &amp;&amp; !isAbsoluteURL(config.url)) { config.url = combineURLs(config.baseURL, config.url);} isAbsoluteURL这个方法就是通过正则来判断是否是一个绝对路由，内容只有一句return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);。 如果config.baseURL存在且config.url不是一个绝对路由，就对两者进行拼接，逻辑就是如果baseURL最后一个字符是/就会去掉，如果url到第一个字符是/也会去掉，然后通过在两者中间加一个/将两者拼起来，代码如下： 123456// combineURLsfunction combineURLs(baseURL, relativeURL) { return relativeURL ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '') : baseURL;}; 然后是对于data的一些处理： 123456config.headers = config.headers || {};config.data = transformData( config.data, config.headers, config.transformRequest); transformRequest我们在默认配置那一章节就已经看到了，通过调用transformData方法，把data和headers依次作为transformRequest中每一个方法的参数执行，返回转换后的数据。 12345678// transformDatafunction transformData(data, headers, fns) { utils.forEach(fns, function transform(fn) { data = fn(data, headers); }); return data;}; 然后把headers的内容合并，注意后边的参数的优先级会更高： 12345config.headers = utils.merge( config.headers.common || {}, config.headers[config.method] || {}, config.headers || {}); 我们在默认配置中在headers为每一个方法创建了一个对象存储一些属性，在发送请求的时候这是没有用的，所以要删除掉。 123456utils.forEach( ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) { delete config.headers[method]; }); adapter使用处理完了config就该发送请求了，记得我们在默认配置中设置了适配器，如果没有传递就会使用这个默认的适配器，大家平常使用的时候应该也不会传递适配器把。 1var adapter = config.adapter || defaults.adapter; 这里简单提一嘴适配器adapter，方便阅读下边的代码，adapter接收config作为参数，并返回一个Promise，所以我们在这里传入了一个成功的回调和一个失败的回调，并通过transformData来调用transformResponse把结果返回。 1234567891011121314151617return adapter(config).then(function onAdapterResolution(response) { response.data = transformData( response.data, response.headers, config.transformResponse ); return response; }, function onAdapterRejection(reason) { if (reason &amp;&amp; reason.response) { reason.response.data = transformData( reason.response.data, reason.response.headers, config.transformResponse ); } return Promise.reject(reason);}); 注意，前边我们说过，这里我们省略了关于取消请求的相关内容，在下边的dispathRequest完整源码中可以忽略相关内容，我们会在后边单独讲解取消请求的相关内容。 dispatchRequest源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// dispatchRequest.js'use strict';var utils = require('./../utils');var transformData = require('./transformData');var isCancel = require('../cancel/isCancel');var defaults = require('../defaults');var isAbsoluteURL = require('./../helpers/isAbsoluteURL');var combineURLs = require('./../helpers/combineURLs');/** * Throws a `Cancel` if cancellation has been requested. */function throwIfCancellationRequested(config) { if (config.cancelToken) { config.cancelToken.throwIfRequested(); }}/** * Dispatch a request to the server using the configured adapter. * * @param {object} config The config that is to be used for the request * @returns {Promise} The Promise to be fulfilled */module.exports = function dispatchRequest(config) { throwIfCancellationRequested(config); // Support baseURL config if (config.baseURL &amp;&amp; !isAbsoluteURL(config.url)) { config.url = combineURLs(config.baseURL, config.url); } // Ensure headers exist config.headers = config.headers || {}; // Transform request data config.data = transformData( config.data, config.headers, config.transformRequest ); // Flatten headers config.headers = utils.merge( config.headers.common || {}, config.headers[config.method] || {}, config.headers || {} ); utils.forEach( ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) { delete config.headers[method]; } ); var adapter = config.adapter || defaults.adapter; return adapter(config).then(function onAdapterResolution(response) { throwIfCancellationRequested(config); // Transform response data response.data = transformData( response.data, response.headers, config.transformResponse ); return response; }, function onAdapterRejection(reason) { if (!isCancel(reason)) { throwIfCancellationRequested(config); // Transform response data if (reason &amp;&amp; reason.response) { reason.response.data = transformData( reason.response.data, reason.response.headers, config.transformResponse ); } } return Promise.reject(reason); });}; adapter - xhr主线任务马上就要结束了哦，前边我们说过适配器分为两种，我们这里只关注适用于浏览器端的xhr。 adapter接收config并返回一个promise，前边刚说过，我们就直接来看函数内部的处理逻辑。 config处理是的，这里还是进行了一些额外处理，其实就是判断了一些如果数据是formData就去掉请求头中的Contetn-Type让浏览器来设置它。 1234567891011var requestData = config.data;var requestHeaders = config.headers;if (utils.isFormData(requestData)) { delete requestHeaders['Content-Type']; // Let the browser set it}if (config.auth) { var username = config.auth.username || ''; var password = config.auth.password || ''; requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);} 请求头和请求数据对于请求头的处理直接看代码吧，比较容易理解 同样省略了取消请求部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849if (utils.isStandardBrowserEnv()) { var cookies = require('./../helpers/cookies'); // Add xsrf header var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) &amp;&amp; config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined; if (xsrfValue) { requestHeaders[config.xsrfHeaderName] = xsrfValue; }}if ('setRequestHeader' in request) { utils.forEach(requestHeaders, function setRequestHeader(val, key) { if (typeof requestData === 'undefined' &amp;&amp; key.toLowerCase() === 'content-type') { // Remove Content-Type if data is undefined delete requestHeaders[key]; } else { // Otherwise add header to the request request.setRequestHeader(key, val); } });}if (config.withCredentials) { request.withCredentials = true;}if (config.responseType) { try { request.responseType = config.responseType; } catch (e) { if (config.responseType !== 'json') { throw e; } }}if (typeof config.onDownloadProgress === 'function') { request.addEventListener('progress', config.onDownloadProgress);}if (typeof config.onUploadProgress === 'function' &amp;&amp; request.upload) { request.upload.addEventListener('progress', config.onUploadProgress);}if (requestData === undefined) { requestData = null;} XMLHttpRequest接下来就是创建XMLHttpRequest准备发送请求，还有为了适配IE 8/9做的处理 1234567891011121314var request = new XMLHttpRequest();var loadEvent = 'onreadystatechange';var xDomain = false;if (process.env.NODE_ENV !== 'test' &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.XDomainRequest &amp;&amp; !('withCredentials' in request) &amp;&amp; !isURLSameOrigin(config.url)) { request = new window.XDomainRequest(); loadEvent = 'onload'; xDomain = true; request.onprogress = function handleProgress() { }; request.ontimeout = function handleTimeout() { };} 调用xhr.open方法， buildURL方法是为了拼接params参数，不单独拿出来说了。 1request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true); 设置超时时间： 1request.timeout = config.timeout; 重头戏肯定是onreadystatechange事件啦，直接在代码中写注释啦。 1234567891011121314151617181920212223242526272829request[loadEvent] = function handleLoad() { if (!request || (request.readyState !== 4 &amp;&amp; !xDomain)) { return; } // 无响应 if (request.status === 0 &amp;&amp; !(request.responseURL &amp;&amp; request.responseURL.indexOf('file:') === 0)) { return; } // 开始准备响应结果 var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null; // ajax响应数据 var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response; // 生成返回结果 var response = { data: responseData, // IE浏览器就用1223代替204状态码 status: request.status === 1223 ? 204 : request.status, statusText: request.status === 1223 ? 'No Content' : request.statusText, headers: responseHeaders, config: config, request: request }; settle(resolve, reject, response); // 清空request request = null;}; 我们看到对于返回内容是通过settle方法来处理的，我们来单独看一下这个方法做了什么： 12345678910111213141516function settle(resolve, reject, response) { var validateStatus = response.config.validateStatus; // 通过验证就返回response if (!response.status || !validateStatus || validateStatus(response.status)) { resolve(response); } else { // 不然就抛出一个错误 reject(createError( 'Request failed with status code ' + response.status, response.config, null, response.request, response )); }}; 看完这一段代码应该知道后端返回的结果为什么在data中才能取到哦 对于网络错误和超时的处理就是直接抛出了错误，就直接放代码了： 12345678910request.onerror = function handleError() { reject(createError('Network Error', config, null, request)); request = null;};request.ontimeout = function handleTimeout() { reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request)); request = null;}; 最后的最后，发送请求，大功告成～ 1request.send(requestData); 注意，源码的书写顺序与这里并不一致，但是不会影响理解源码内容。 接下来放出完整源码，一样可以忽略取消请求的内容哈。 xhr源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181'use strict';var utils = require('./../utils');var settle = require('./../core/settle');var buildURL = require('./../helpers/buildURL');var parseHeaders = require('./../helpers/parseHeaders');var isURLSameOrigin = require('./../helpers/isURLSameOrigin');var createError = require('../core/createError');var btoa = (typeof window !== 'undefined' &amp;&amp; window.btoa &amp;&amp; window.btoa.bind(window)) || require('./../helpers/btoa');module.exports = function xhrAdapter(config) { return new Promise(function dispatchXhrRequest(resolve, reject) { var requestData = config.data; var requestHeaders = config.headers; if (utils.isFormData(requestData)) { delete requestHeaders['Content-Type']; // Let the browser set it } var request = new XMLHttpRequest(); var loadEvent = 'onreadystatechange'; var xDomain = false; // For IE 8/9 CORS support // Only supports POST and GET calls and doesn't returns the response headers. // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest. if (process.env.NODE_ENV !== 'test' &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.XDomainRequest &amp;&amp; !('withCredentials' in request) &amp;&amp; !isURLSameOrigin(config.url)) { request = new window.XDomainRequest(); loadEvent = 'onload'; xDomain = true; request.onprogress = function handleProgress() { }; request.ontimeout = function handleTimeout() { }; } // HTTP basic authentication if (config.auth) { var username = config.auth.username || ''; var password = config.auth.password || ''; requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password); } request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true); // Set the request timeout in MS request.timeout = config.timeout; // Listen for ready state request[loadEvent] = function handleLoad() { if (!request || (request.readyState !== 4 &amp;&amp; !xDomain)) { return; } // The request errored out and we didn't get a response, this will be // handled by onerror instead // With one exception: request that using file: protocol, most browsers // will return status as 0 even though it's a successful request if (request.status === 0 &amp;&amp; !(request.responseURL &amp;&amp; request.responseURL.indexOf('file:') === 0)) { return; } // Prepare the response var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null; var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response; var response = { data: responseData, // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201) status: request.status === 1223 ? 204 : request.status, statusText: request.status === 1223 ? 'No Content' : request.statusText, headers: responseHeaders, config: config, request: request }; settle(resolve, reject, response); // Clean up request request = null; }; // Handle low level network errors request.onerror = function handleError() { // Real errors are hidden from us by the browser // onerror should only fire if it's a network error reject(createError('Network Error', config, null, request)); // Clean up request request = null; }; // Handle timeout request.ontimeout = function handleTimeout() { reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request)); // Clean up request request = null; }; // Add xsrf header // This is only done if running in a standard browser environment. // Specifically not if we're in a web worker, or react-native. if (utils.isStandardBrowserEnv()) { var cookies = require('./../helpers/cookies'); // Add xsrf header var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) &amp;&amp; config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined; if (xsrfValue) { requestHeaders[config.xsrfHeaderName] = xsrfValue; } } // Add headers to the request if ('setRequestHeader' in request) { utils.forEach(requestHeaders, function setRequestHeader(val, key) { if (typeof requestData === 'undefined' &amp;&amp; key.toLowerCase() === 'content-type') { // Remove Content-Type if data is undefined delete requestHeaders[key]; } else { // Otherwise add header to the request request.setRequestHeader(key, val); } }); } // Add withCredentials to request if needed if (config.withCredentials) { request.withCredentials = true; } // Add responseType to request if needed if (config.responseType) { try { request.responseType = config.responseType; } catch (e) { // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2. // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function. if (config.responseType !== 'json') { throw e; } } } // Handle progress if needed if (typeof config.onDownloadProgress === 'function') { request.addEventListener('progress', config.onDownloadProgress); } // Not all browsers support upload events if (typeof config.onUploadProgress === 'function' &amp;&amp; request.upload) { request.upload.addEventListener('progress', config.onUploadProgress); } if (config.cancelToken) { // Handle cancellation config.cancelToken.promise.then(function onCanceled(cancel) { if (!request) { return; } request.abort(); reject(cancel); // Clean up request request = null; }); } if (requestData === undefined) { requestData = null; } // Send the request request.send(requestData); });}; 恭喜，主线任务完成了🎉🎉🎉","link":"/2022/10/18/%E5%8F%81-dispatchRequest%E5%92%8Cadapter/"},{"title":"在vue2中引入外部的字体文件","text":"作为一个卑微的切图仔，肯定要100%还原UI老师给的设计图纸，然而UI老师为了优美的界面，在各个位置恰到好处的使用的不同的字体。 这种情况在实际的开发中应该是很长见的。但是我们本地没有这个字体怎么办呢？用户本地也没有这个字体怎么办呢？ 出现这个问题肯定不是用户的问题，那只能是我们解决这个问题。 我们一般会在项目中有一个文件夹专门用来存放字体文件，我是习惯于放到src/assets/fonts这个目录下。 我们将字体文件下载下来，然后放到fonts目录下，不管你是什么.ttf的文件还是.otf的文件，放进去就好了。 然后呢我们是需要一个css文件来引入这些字体的，当然你用less、scss也可以。 引入会涉及到路径这个问题，所以我就把css文件也放到fonts目录下。 123456789/* font.css */@font-face { /* font-family是我们给字体文件起的名字，以后使用这个字体就用这个名字 */ font-family: &quot;SourceHanSansCN-R&quot;; /* 对应的字体文件 */ src: url('./SourceHanSansCN-Regular.otf'); font-weight: normal; font-style: normal;} 这样我们就定义好了一个字体，为了方便我们使用呢，我们会在main.js中将这个样式文件引入 123// main.js// 就只写这一行了，main.js该咋写咋写，把这个加进去就行import './assets/fonts/font.css' 现在我们在开发组件的时候，就可以开心的使用定义好的字体了 123456/* 组件的样式文件 */p{ /* 这个名字不是字体文件的名字，而是我们定义好的字体名字哦 */ font-family: 'SourceHanSansCN-R'} 细心的小伙伴肯定有一个疑问，我的项目怎么可能就只引入一款字体呢，那如果引入很多种字体该怎么做呢？ 答案很简单，在字体的样式文件中把用到的所有字体全部罗列出来就好了。 1234567891011121314151617181920212223/* font.css */@font-face { /* font-family是我们给字体文件起的名字，以后使用这个字体就用这个名字 */ font-family: &quot;SourceHanSansCN-R&quot;; /* 对应的字体文件 */ src: url('./SourceHanSansCN-Regular.otf'); font-weight: normal; font-style: normal;}@font-face { font-family: &quot;SourceHanSansCN-L&quot;; src: url('./SourceHanSansCN-Light.otf'); /* font-weight: normal; */ /* font-style: normal; */}@font-face { font-family: &quot;SourceHanSansCN-M&quot;; src: url('./SourceHanSansCN-Medium.otf'); font-weight: normal; font-style: normal;} 这样子我们就可以使用想要的字体进行开发了。 不过这还涉及到一个问题，字体文件都比较大，想我演示的这一整套思源黑体要40-50M，这也太大了，关于字体的文件压缩，目前尚未找到一个满意的方案。 像是字蛛这种都是需要你确定你用到哪些文字，他只把字体中你用到的文字保留下来实现的压缩，但是我们的文字可能都是动态获取的，确实满足不了需求。 如果找到了我会在后续更新中加入的。","link":"/2021/11/22/%E5%9C%A8vue2%E4%B8%AD%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E7%9A%84%E5%AD%97%E4%BD%93%E6%96%87%E4%BB%B6/"},{"title":"壹:axios默认配置","text":"在上一节的入口文件中，我们都知道axios是基于默认配置创建的，那么这个默认配置到底配置了哪些东西呢？ 这一节，我们就来看一看lib/defaults.js的源码内容。 辅助函数normalizeHeaderName正如其名字一样，normalizeHeaderName方法用来标准化请求头，看一下其代码实现： 12345678function normalizeHeaderName(headers, normalizedName) { utils.forEach(headers, function processHeader(value, name) { if (name !== normalizedName &amp;&amp; name.toUpperCase() === normalizedName.toUpperCase()) { headers[normalizedName] = value; delete headers[name]; } });}; 方法接收两个参数，请求头headers和标准请求头名称normalizedName,所以我们每次只会对一个请求头参数名称进行标准化。 utils.forEach我们在上一节说到过，在这里的作用就是循环请求头，然后把每个请求头的值和名字分别传入处理函数。 处理函数内部的操作很简单，如果请求头的名称与标准名称不同但是两者转为大写后相同，那么这个请求头的名称就是不标准的，我们用标准化的请求头名称进行替换。 比如我们有一个请求头： 123headers = { 'CONTENT-TYPE': 'application/json'} 我们调用normalizedHeaderName方法并传入标准名称Content-Type 1normalizedHeaderName(headers, 'Content-Type') 经过处理后我们得到的结果是这样的： 123headers = { 'Content-Type': 'application/json'} getDefaultAdapter见名知意，这个方法是用来获取默认适配器的。 123456789function getDefaultAdapter() { var adapter; if (typeof XMLHttpRequest !== 'undefined') { adapter = require('./adapters/xhr'); } else if (typeof process !== 'undefined') { adapter = require('./adapters/http'); } return adapter;} 前边我们说过，axios分别为浏览器环境和NodeJs环境做了不同的适配器，所以在这个方法中进行了判断返回正确的适配器。 setContentTypeIfUnset一样的见名知意，如果没有设置ContentType那么就给设置ContentType 这里用到一个辅助方法isUndefined，方法内容非常简单，就是判断参数是否为undefined 123function isUndefined(val) { return typeof val === 'undefined';} 然后看一下setContentTypeIfUnset的源码内容，很简单，不多解释： 123456function setContentTypeIfUnset(headers, value) { // 如果headers是undefined或者headers['Content-Type']是undefined，就把headers['Content-Type']设置为传入的value if (!utils.isUndefined(headers) &amp;&amp; utils.isUndefined(headers['Content-Type'])) { headers['Content-Type'] = value; }} headers默认配置这里并不是直接配置请求头，而是做了一些处理，axios对默认配置中的headers做了分类，比如通用的配置、适用于某个方法的配置等，然后在dispatchRequest中根据具体的请求方法去取出对应的配置内容来使用。 接收类型限制Accept是一个通用配置，意味着在所有请求方法都是可用的： 12345defaults.headers = { common: { 'Accept': 'application/json, text/plain, */*' }}; 对于get,delete,head请求，由于不需要携带body，只声明了一个空对象 123utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) { defaults.headers[method] = {};}); 对于post,put,patch请求，声明了Content-Type。 源码中有Content-Type的默认声明 1234567var DEFAULT_CONTENT_TYPE = { 'Content-Type': 'application/x-www-form-urlencoded'};utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) { defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);}); 这里还用到了辅助方法merge，也不复杂，就是做了一个合并操作，代码如下： 12345678910111213141516171819function merge() { // 存放合并后的内容 var result = {}; function assignValue(val, key) { // 如果result中有且是个对象，且新传入的也是个对象，需要继续合并 // 如果其中一个或者都不是对象的话后边的会覆盖前边的。 if (typeof result[key] === 'object' &amp;&amp; typeof val === 'object') { result[key] = merge(result[key], val); } else { // 如果result中没有这个属性就放进去 result[key] = val; } } // 对所有参数合并到result中 for (var i = 0, l = arguments.length; i &lt; l; i++) { forEach(arguments[i], assignValue); } return result;} 注意，如果需要合并的两个对象中有相同的属性，但是对应的值不全是对象的话，后传入的会把前边的覆盖掉。 这样我们对于headers的内容基本也看完了，现在的defaults应该是这样的： 1234567891011121314151617181920let defaults = { headers: { common: { 'Accept': 'application/json, text/plain, */*' }, get: {}, delete: {}, head: {}, post: { 'Content-Type': 'application/x-www-form-urlencoded' }, put: { 'Content-Type': 'application/x-www-form-urlencoded' }, patch: { 'Content-Type': 'application/x-www-form-urlencoded' }, }} defaults其他内容其他内容就比较简单了，直接贴出来看一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var defaults = { // 适配器 adapter: getDefaultAdapter(), // 请求数据格式转换 transformRequest: [function transformRequest(data, headers) { normalizeHeaderName(headers, 'Content-Type'); if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data) ) { return data; } if (utils.isArrayBufferView(data)) { return data.buffer; } if (utils.isURLSearchParams(data)) { setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8'); return data.toString(); } if (utils.isObject(data)) { setContentTypeIfUnset(headers, 'application/json;charset=utf-8'); return JSON.stringify(data); } return data; }], // 响应数据格式转换 transformResponse: [function transformResponse(data) { /*eslint no-param-reassign:0*/ if (typeof data === 'string') { try { data = JSON.parse(data); } catch (e) { /* Ignore */ } } return data; }], // timeout:0就是没设置超时时间 timeout: 0, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, // 用来判断状态码是不是处于200-299 validateStatus: function validateStatus(status) { return status &gt;= 200 &amp;&amp; status &lt; 300; }}; transformRequest和transformResponsetransformRequest和transformResponse后边还会看到，在这里就先简单说一下吧，到后边还会见到他们的。他们两个的用法其实是一样的，只是一个处理请求数据，一个处理响应数据。他们都是数组，数组元素是函数，每个函数接收两个参数data和headers。 在defaults中设置了对与请求数据和响应数据的默认转换方式，他们最后会在dispatchRequest中执行，执行时会将数据、请求头、transformRequest或者transformResponse数组传入transformData方法，在这个方法中会依次执行数组中的方法，并将数据和请求头传入。 需要注意的是不管是transformRequest还是transformResponse，对数据转换后需要将数据返回出来 我们现在已经大概知道这两个数组中的方法是做什么的了，具体在哪里进行调用咱们先不关注，会在后续内容中讲解，先来看一下defaults提供的默认数据转换内容： transformRequest请求内容的处理并不复杂，首先是对与Content-Type请求头进行了标准化，前边说到的方法终于在这里用到了。 其次用到了一些辅助方法去判断数据的格式，根据不同数据格式对其进行不同的转换，如果没有配置Content-Type，那么有些格式还需要设置对应的Content-Type。 比如我们最常见的情况，我们传递的数据是一个对象，如果我们没有配置Content-Type，这里就给我们请求头的Content-Type设置为application/json;charset=utf-8，然后将我们的对象转换为JSON字符串。 123456789101112131415161718192021222324function transformRequest(data, headers) { normalizeHeaderName(headers, 'Content-Type'); if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data) ) { return data; } if (utils.isArrayBufferView(data)) { return data.buffer; } if (utils.isURLSearchParams(data)) { setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8'); return data.toString(); } if (utils.isObject(data)) { setContentTypeIfUnset(headers, 'application/json;charset=utf-8'); return JSON.stringify(data); } return data;} transformResponse对于响应内容的默认处理比较简单哈，如果响应内容是字符串，就考虑是不是JSON字符串，尝试将其转换为对象形式。 12345678function transformResponse(data) { if (typeof data === 'string') { try { data = JSON.parse(data); } catch (e) { /* Ignore */ } } return data;} 完整源码贴一下完整的defaults源码内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091'use strict';var utils = require('./utils');var normalizeHeaderName = require('./helpers/normalizeHeaderName');var DEFAULT_CONTENT_TYPE = { 'Content-Type': 'application/x-www-form-urlencoded'};function setContentTypeIfUnset(headers, value) { if (!utils.isUndefined(headers) &amp;&amp; utils.isUndefined(headers['Content-Type'])) { headers['Content-Type'] = value; }}function getDefaultAdapter() { var adapter; if (typeof XMLHttpRequest !== 'undefined') { // For browsers use XHR adapter adapter = require('./adapters/xhr'); } else if (typeof process !== 'undefined') { // For node use HTTP adapter adapter = require('./adapters/http'); } return adapter;}var defaults = { adapter: getDefaultAdapter(), transformRequest: [function transformRequest(data, headers) { normalizeHeaderName(headers, 'Content-Type'); if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data) ) { return data; } if (utils.isArrayBufferView(data)) { return data.buffer; } if (utils.isURLSearchParams(data)) { setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8'); return data.toString(); } if (utils.isObject(data)) { setContentTypeIfUnset(headers, 'application/json;charset=utf-8'); return JSON.stringify(data); } return data; }], transformResponse: [function transformResponse(data) { /*eslint no-param-reassign:0*/ if (typeof data === 'string') { try { data = JSON.parse(data); } catch (e) { /* Ignore */ } } return data; }], timeout: 0, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, validateStatus: function validateStatus(status) { return status &gt;= 200 &amp;&amp; status &lt; 300; }};defaults.headers = { common: { 'Accept': 'application/json, text/plain, */*' }};utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) { defaults.headers[method] = {};});utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) { defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);});module.exports = defaults;","link":"/2022/10/10/%E5%A3%B9-axios%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE/"},{"title":"如何调试NodeJs源代码","text":"在开发过程中我们经常会使用debug模式来调试代码，在NodeJs项目开发中，有时候我们想去了解一下其内置库的执行流程，就需要对源代码进行调试。 我们接下来就通过require引入一个内置库，来演示如何调试 1const path = require('path') WebStorm调试在WebStorm中调试就更简单了，我们直接通过step into是无法进入源代码的，可以通过Force Step Into来强制进入源代码，如下图： 如果看不到这个图标，可以点击右边的更多来找到这个按钮 如果想跟我一样直接显示这个图标，可以在这个工具栏右键，自定义要展示的工具 VsCode调试在VsCode中，直接打断点后运行调试，默认会跳过内置库，无法进入 我们需要编辑调试配置文件来实现，点击如图位置来编辑配置文件： 配置文件的默认内容为： 1234567891011121314151617{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;启动程序&quot;, &quot;skipFiles&quot;: [ &quot;&lt;node_internals&gt;/**&quot; ], &quot;program&quot;: &quot;${workspaceFolder}/index.js&quot; } ]} 我们可以看到其中有一项名为skipFiles的配置，用于配置跳过调试的文件，默认跳过了node_internals，我们将其注释即可在调试过程中进入源代码了。","link":"/2023/04/17/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95NodeJs%E6%BA%90%E4%BB%A3%E7%A0%81/"},{"title":"实现Promise&#x2F;A+规范的Promise","text":"Promise是ES6的核心内容，有效解决回调地狱的问题，我们在此解读Promise/A+规范，并手写实现一个Promsie。 文章内容主要来源于实现一个完美符合Promise/A+规范的Promise 个人博客主要作为笔记记录使用。如不允许转载，烦请联系删除。感谢。 解读一下Promise/A+规范 术语 “promise”是一个对象或者函数，该对象或者函数有一个then方法 “thenable”是一个对象或者函数，用来定义then方法 “value”是promise状态成功时的值 “reason”是promise状态失败时的值 要求 一个promise必须有3个状态，pending，fulfilled(resolved)，rejected当处于pending状态的时候，可以转移到fulfilled(resolved)或者rejected状态。当处于fulfilled(resolved)状态或者rejected状态的时候，就不可变。 promise英文译为承诺，也就是说promise的状态一旦发生改变，就永远是不可逆的。 一个promise必须有一个then方法，then方法接受两个参数： 12// 其中onFulfilled方法表示状态从pending——&gt;fulfilled(resolved)时所执行的方法，而onRejected表示状态从pending——&gt;rejected所执行的方法。promise.then(onFulfilled,onRejected) 为了实现链式调用，then方法必须返回一个promise 1promise2=promise1.then(onFulfilled,onRejected) 初始版本的Promise一个简单版本的Promise，注意其尚不能处理异步任务，.then也不能返回Promise 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// myPromise构造函数function myPromise(constructor){ let self = this // 初始状态为pending self.status = &quot;pending&quot; // 状态为fullFilled状态的值 self.value = undefined // 状态为rejected状态的值 self.reason = undefined // resolve方法，接收value function resolve(value){ if(self.status === &quot;pending&quot;){ self.value = value self.status = &quot;fullFilled&quot; } } // reject方法，接收reason function reject(reason){ if(self.status === &quot;pending&quot;){ self.reason = reason self.status = &quot;rejected&quot; } } // 调用constructor并捕获异常 // 我们调用new Promise的时候传入一个函数，函数接收resolve和reject两个参数，所以在这里我们调用传入的constructor并传入resolve和reject try{ constructor(resolve, reject) }catch(e){ reject(e) }}// 在原型添加.then方法// .then方法接收两个函数，分别是resolve的回调和reject的回调myPromise.prototype.then = function(onFullfilled, onRejected){ let self = this switch(self.status){ case &quot;fullFilled&quot;: // 调用resolve的回调并传入value onFullfilled(self.value) break; case &quot;rejected&quot;: // 调用reject的回调并传入reason onRejected(self.reason) break; default: break; }} 这里myPromise还无法处理异步的resolve 比如： 1234567var p=new myPromise(function(resolve,reject){ setTimeout(function(){ resolve(1) },1000)});p.then(function(x){console.log(x)})//无输出 基于观察者模式处理异步用2个数组onFullfilledArray和onRejectedArray来保存异步的方法。在状态发生改变时，一次遍历执行数组中的方法。 基本逻辑就是： 在.then执行的时候，如果状态还是pending，那么就把回调函数收集到数组中 在执行resolve或者reject的时候，执行数组中保存的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// myPromise构造函数function myPromise(constructor){ let self = this // 初始状态为pending self.status = &quot;pending&quot; // 状态为fullFilled状态的值 self.value = undefined // 状态为rejected状态的值 self.reason = undefined // 保存resolve的回调函数列表 self.onFullFilledArray = [] // 保存reject的回调函数列表 self.onRejectedArray = [] // resolve方法，接收value function resolve(value){ if(self.status === &quot;pending&quot;){ self.value = value self.status = &quot;fullFilled&quot; // 调用resolve的时候执行resolve的所有回调 self.onFullFilledArray.forEach( fn =&gt; { fn(self.value) }) } } // reject方法，接收reason function reject(reason){ if(self.status === &quot;pending&quot;){ self.reason = reason self.status = &quot;rejected&quot; // 调用reject的时候执行reject的所有回调 self.onRejectedArray.forEach(fn =&gt; { fn(self.reason) }) } } // 调用constructor并捕获异常 // 我们调用new Promise的时候传入一个函数，函数接收resolve和reject两个参数，所以在这里我们调用传入的constructor并传入resolve和reject try{ constructor(resolve, reject) }catch(e){ reject(e) }}// 在原型添加.then方法// .then方法接收两个函数，分别是resolve的回调和reject的回调myPromise.prototype.then = function(onFullFilled, onRejected){ let self = this switch(self.status){ // 如果调用.then的时候是pending状态，那么可能是一个异步任务，还没有执行resolve/reject，所以先把对应的回调函数收集起来，等待时机运行 case &quot;pending&quot;: self.onFullFilledArray.push(function(value){ onFullFilled(value) }) self.onRejectedArray.push(function(reason){ onRejected(reason) }) break; case &quot;fullFilled&quot;: // 调用resolve的回调并传入value onFullFilled(self.value) break; case &quot;rejected&quot;: // 调用reject的回调并传入reason onRejected(self.reason) break; default: break; }} 经过这样改造，再看上边的异步任务的例子： 开始new Promise中执行到了定时器会将其加入到宏任务队列，并不会立即执行定时器中的内容 紧接着执行.then方法，此时由于定时器中的内容还未执行，所以status为pending，我们将onFullFilled和onRejected方法收集起来 执行完之后会执行定时器也就会调用resolve方法，此时改变status的状态，并通知收集的依赖进行更新执行相应的回调。 异步的问题解决了，但是Promise/A+规范的最大的特点就是链式调用，也就是说then方法返回的应该是一个promise。 then方法实现链式调用要通过then方法实现链式调用，那么也就是说then方法每次调用需要返回一个primise,同时在返回promise的构造体里面，增加错误处理部分 由于只需要对then方法进行修改，下边就不展示构造函数的内容了，只放then方法上来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051myPromise.prototype.then = function(onFullFilled, onRejected){ let self = this // 要返回的新promise let promise2; switch(self.status){ case &quot;pending&quot;: promise2 = new myPromise(function(resolve, reject){ self.onFullFilledArray.push(function(value){ try{ let temp = onFullFilled(value) resolve(temp) }catch(e){ reject(e) } }) self.onRejectedArray.push(function(reason){ try{ let temp = onRejected(reason) resolve(temp) }catch(e){ reject(e) } }) }) break; case &quot;fullFilled&quot;: promise2 = new myPromise(function(resolve, reject){ try{ let temp = onFullFilled(self.value) resolve(temp) }catch(e){ reject(e) } }) break; case &quot;rejected&quot;: promise2 = new myPromise(function(resolve, reject){ try{ let temp = onRejected(self.reason) resolve(temp) }catch(e){ reject(e) } }) break; default: break; } // 返回新的promise return promise2} 由于掺杂了异步的逻辑可能有些乱，可以只看状态为fullFilled和rejected的情况会清晰一些，然后加上异步的处理就可以理解了。 基本流程就是我们会在.then方法中创建一个新的promsie返回来实现.then的链式调用。 在这个新的promise中，我们要执行之前的promise.then的回调函数，并根据其回调函数的返回值在新的回调函数中执行resolve/reject操作，以保证在下一个.then方法中可以接收到我们传递的值。 还有一个问题，就是在Promise/A+规范中then函数里面的onFullfilled方法和onRejected方法的返回值可以是对象，函数，甚至是另一个promise。 解决then函数中的onFullfilled和onRejected方法的返回值问题特别的为了解决onFullfilled和onRejected方法的返回值可能是一个promise的问题。 首先来看promise中对于onFullfilled函数的返回值的要求 如果onFullfilled函数返回的是该promise本身，那么会抛出类型错误 如果onFullfilled函数返回的是一个不同的promise，那么执行该promise的then函数，在then函数里将这个promise的状态转移给新的promise 如果返回的是一个嵌套类型的promsie，那么需要递归。 如果返回的是非promsie的对象或者函数，那么会选择直接将该对象或者函数，给新的promise。 根据上述返回值的要求，我们要重新的定义resolve函数，这里Promise/A+规范里面称为：resolvePromise函数，该函数接受当前的promise、onFullfilled函数或者onRejected函数的返回值、resolve和reject作为参数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155// myPromise构造函数function myPromise(constructor){ let self = this // 初始状态为pending self.status = &quot;pending&quot; // 状态为fullFilled状态的值 self.value = undefined // 状态为rejected状态的值 self.reason = undefined // 保存resolve的回调函数列表 self.onFullFilledArray = [] // 保存reject的回调函数列表 self.onRejectedArray = [] // resolve方法，接收value function resolve(value){ if(self.status === &quot;pending&quot;){ self.value = value self.status = &quot;fullFilled&quot; // 调用resolve的时候执行resolve的所有回调 self.onFullFilledArray.forEach( fn =&gt; { fn(self.value) }) } } // reject方法，接收reason function reject(reason){ if(self.status === &quot;pending&quot;){ self.reason = reason self.status = &quot;rejected&quot; // 调用reject的时候执行reject的所有回调 self.onRejectedArray.forEach(fn =&gt; { fn(self.reason) }) } } // 调用constructor并捕获异常 // 我们调用new Promise的时候传入一个函数，函数接收resolve和reject两个参数，所以在这里我们调用传入的constructor并传入resolve和reject try{ constructor(resolve, reject) }catch(e){ reject(e) }}// 在原型添加.then方法// .then方法接收两个函数，分别是resolve的回调和reject的回调myPromise.prototype.then = function(onFullFilled, onRejected){ let self = this // 要返回的新promise let promise2; switch(self.status){ case &quot;pending&quot;: promise2 = new myPromise(function(resolve, reject){ self.onFullFilledArray.push(function(value){ setTimeout(function(){ try{ let temp = onFullFilled(value) resolvePromise(promise2, temp, resolve, reject) }catch(e){ reject(e) } }) }) self.onRejectedArray.push(function(reason){ setTimeout(function(){ try{ let temp = onRejected(reason) resolvePromise(promise2 ,temp, resolve, reject) }catch(e){ reject(e) } }) }) }) break; case &quot;fullFilled&quot;: promise2 = new myPromise(function(resolve, reject){ setTimeout(function(){ try{ let temp = onFullFilled(self.value) resolvePromise(promise2 ,temp, resolve, reject) }catch(e){ reject(e) } }) }) break; case &quot;rejected&quot;: promise2 = new myPromise(function(resolve, reject){ setTimeout(function(){ try{ let temp = onRejected(self.reason) resolvePromise(promise2 ,temp, resolve, reject) }catch(e){ reject(e) } }) }) break; default: break; } // 返回新的promise return promise2}/** * @desc 处理返回值 * @param {*} promise .then中要返回的那个新的promise * @param {*} x .then中的onFullFilled/onRejected回调函数的返回值 * @param {*} resolve 新promise的resolve * @param {*} reject 新promise的reject * @returns */function resolvePromise(promise, x, resolve,reject){ // 如果返回的promise本身则报错 if(promise === x){ throw new Error(&quot;type error&quot;) } let isUsed; if(x!==null &amp;&amp; (typeof x===&quot;object&quot; || typeof x === &quot;function&quot;)){ try{ let then = x.then // 如果x.then是一个函数，那么x就是一个promise if(typeof then === &quot;function&quot;){ then.call(x, function(y){ if(isUsed){ return; } isUsed = true // onFullFilled回调可能还会返回promise resolvePromise(promise, y, resolve, reject) }, function(e){ if(isUsed){ return; } isUsed = true reject(e) }) }else{ // 如果x没有then方法那么仅仅是一个普通函数或者对象 resolve(x) } }catch(e){ if(isUsed){ return; } isUsed = true reject(e) } }else{ // 返回的基本数据类型，直接resolve resolve(x) }}","link":"/2022/08/03/%E5%AE%9E%E7%8E%B0Promise-A-%E8%A7%84%E8%8C%83%E7%9A%84Promise/"},{"title":"展开运算符与可迭代对象","text":"在ES6中引入了很多新的语法，三个点...的语法就是其中之一。该语法有两个用处，一个是作为展开运算符，还可以作为rest参数。其作为剩余参数的方法用法比较简单，也不是本文的关注内容，所以下边说一下关于展开运算符的一些操作以及引出迭代器与生成器。 基础用法展开运算符正如其名，就是可以将目标展开，常用于展开数组。 12let arr = [1,2,3,4,5]console.log(...arr) // 1 2 3 4 5 不过我使用展开运算符最多的是用来合并两个数组 123let arr1 = [1,2]let arr2 = [...arr1, 3]console.log(arr2) // [1,2,3] 当我们传递参数的时候，有时候也能用到它 12345function sum(a, b, c){ return a + b + c}let arr = [1, 2, 3]let res = sum(...arr) // res = 6 展开运算符就只能用于展开数组吗？当然不是，在对象中也是可用的 123456789let obj1 = { name: 'tom', age: 19}let obj2 = { ...obj1, gender: 'male'}console.log(obj2) // {name: 'tom', age: 19, gender: 'male'} 自然，他也可以用来拷贝一个对象，不过要注意这并不是一个深拷贝 12let obj = {name: 'tom'}let objCopy = {...obj} 既然能合并数组，自然也可以合并对象了。 123let obj1 = {name: 'tom'}let obj2 = {age: 19, name: 'tony'}let obj = {...obj1, ...obj2} 发现了吗？好像跟数组的合并不太一样了，有重复的属性怎么办呢 我希望你可以自己去试一下然后得出这个答案，不过在这里我就直说了，合并有重复的属性时会以右边的对象属性为准哦。 所以obj = {age: 19, name: 'tony'} 不过这里的坑不止这一个，我们合并对象跟拷贝对象是一样的，合并操作执行的也是一个浅拷贝，如果源对象中还有引用数据类型，使用过程中要注意。 展开运算符可以操作数组和对象，但不仅限于此。 我们将字符串展开为数组会怎么做呢？第一时间肯定想到了split()方法吧，其实展开运算符也可以实现这个效果。 12let str = 'abc'let arr = [...str] 常用操作就说这些了，展开运算符是不是很简单呢？好像是的 那，[...undefined]会输出什么呢？ 可迭代对象我们打开控制台输入[...undefined]会发生什么呢 123[...undefined]Uncaught TypeError: undefined is not iterable 控制台告诉我们undefined是不可迭代的 什么是可迭代对象呢？ 在ES6中常用的集合对象和字符串都是可迭代对象 通过生成器创建的迭代器也是可迭代对象 要成为可迭代对象， 一个对象必须实现 iterator 方法。可迭代对象具有Symbol.iterator属性，即具有Symbol.iterator属性的对象都有默认迭代器。 我们可以用Symbol.iterator来访问对象的默认迭代器 迭代器迭代器是一种特殊对象，每一个迭代器都有一个next方法，该方法会返回一个对象，对象包括value和done属性。 我们实现一个简单的迭代器来看一下方便理解： 123456789101112131415161718192021222324// 生成迭代器对象的函数function createIterator(items){ let i = 0; return { next(){ // 判断i是否大于等于items的长度，也就是遍历是否完成的标识 let done = ( i &gt;= items.length) // 如果done为false，则尚未完成遍历 // 返回value为items[i]的值，然后将i自增，这里就不说i++和++i的区别了 // 如果done为true，则便利完成，返回value为undefined let value = !done ? items[i++] : undefined; return { done, value } } }}// 上边的函数是用于返回迭代器对象的，函数不是迭代器，返回的对象才是const a = createIterator([1,2,3])console.log(a.next()) // {value: 1, done: false}console.log(a.next()); //{value: 2, done: false}console.log(a.next()); //{value: 3, done: false}console.log(a.next()); //{value: undefined, done: true} 生成器迭代器是一个对象，我们前边通过一个函数来生成了迭代器 提到迭代器就不可避免的印出来生成器 生成器是一个函数，用来返回迭代器。 生成器函数是ES6提出来的，声明的时候需要声明一个带有*星号的函数，同时你还会用到yield。 还是拿到代码中看一下吧 12345678910111213// 生成器是函数，函数名前边加一个*function *createIterator(){ yield 1; yield 2; yield 3;}// 生成一个迭代器,调用生成器的时候就不需要加*了const a = createIterator();// 生成的迭代器并不会自动执行，还是需要调用next才可以console.log(a.next()); //{value: 1, done: false}console.log(a.next()); //{value: 2, done: false}console.log(a.next()); //{value: 3, done: false}console.log(a.next()); //{value: undefined, done: true} 我们可以发现生成器与我们自己定义一个迭代器可以实现相同的效果，这就是yield的作用 生成器的yield关键字有一个神奇的功能，就是当你执行一次next()，那么就会执行一个yield后边的内容，然后语句终止运行 yield使用限制当然yield使用是有限制的，只能在生成器函数内部使用，不能在非生成器的其他函数内部使用。 123456789function *createInerator(items){ // 这里是生成器的内部，可以使用yield items.map((value,key) =&gt; { // 这里会出现语法错误，因为我们将yield用在了map的回调函数中，而不是生成器函数内部 yield value; })}const a = createIterator([1,2,3])console.log(a.next()) // 无输出 生成器函数表达式函数表达式就是匿名函数，就这么叫没什么好纠结的 12345const createIterator = function *(){ yield 1; yield 2;}const a = createIterator() 对象中添加生成器函数一个普通对象通常是长这个样子的 123const obj = { a: 1} 我们可以在对象中添加一个生成器，也就是一个带星号的方法 12345678const obj = { a: 1, *createIterator(){ yield this.a }}const a = obj.createIterator()console.log(a.next) // {value: 1, done: false} 理解可迭代对象前边我们说到过什么是可迭代对象，但描述并不容易理解，所以由此引出了迭代器与生成器，现在我们应该可以好好理解什么是可迭代对象了。 再次强调一遍，迭代器是一个对象，生成器是一个返回迭代器的函数 凡是通过生成器生成的迭代器，都是可迭代对象，也就可以通过for..of遍历。 123456789function *createIterator(){ yield 1; yield 2; yield 3;}const a = createIterator()for (let value of a){ console.log(value) // 1 2 3} 我们前边也提到过可迭代对象都具有Symbol.iterator属性，我们可以通过这个属性访问迭代器 12345678function *createIterator() { yield 1; yield 2; yield 3;}const a = createIterator(); const s = a[Symbol.iterator]();//使用Symbol.iterator访问迭代器console.log(s.next()) //{value: 1, done: false} 通过Symbol.iterator来检测一个对象是否可迭代也是可行的 1typeof obj[Symbol.iterator] === &quot;function&quot; 创建可迭代对象前边已经提到过了，在es6中，数组、set、map、字符串都是可迭代对象。 但是默认情况下定义的对象是不可迭代的 1234567cosnt obj = { items: []}obj.items.push(1)for(let x of obj){ console.log(x) // _iterator[Symbol.iterator] is not a function} 所以就需要我们手动的给对象添加[Symbol.iterator]属性，使其成为一个可迭代的对象 123456789101112const obj = { items: [], *[Symbol.iterator](){ for (let item of this.items){ yield item } }}obj.items.push(1)for(let x of obj){ console.log(x) // 现在就可以通过for of来访问obj了} 内建迭代器我们上边提到过，数组、set、map默认都是可迭代对象，也就是说他们内部已经实现了迭代器，并且其提供了3中迭代器的函数调用 entries()：返回键值对 12345678910111213141516171819202122// 数组const arr = ['a', 'b', 'c']for(let v of arr.entries()){ console.log(v)}// [0, 'a'] [1, 'b'] [2, 'c']// Setconst arr = new Set(['a', 'b', 'c'])for(let v of arr.entries()) { console.log(v)}// ['a', 'a'] ['b', 'b'] ['c', 'c']//Mapconst arr = new Map();arr.set('a', 'a');arr.set('b', 'b');for(let v of arr.entries()) { console.log(v)}// ['a', 'a'] ['b', 'b'] values()：返回键值对的value 12345678910111213141516171819202122//数组const arr = ['a', 'b', 'c'];for(let v of arr.values()) { console.log(v)}//'a' 'b' 'c'//Setconst arr = new Set(['a', 'b', 'c']);for(let v of arr.values()) { console.log(v)}// 'a' 'b' 'c'//Mapconst arr = new Map();arr.set('a', 'a');arr.set('b', 'b');for(let v of arr.values()) { console.log(v)}// 'a' 'b' keys：返回键值对的key 12345678910111213141516171819202122//数组const arr = ['a', 'b', 'c'];for(let v of arr.keys()) { console.log(v)}// 0 1 2//Setconst arr = new Set(['a', 'b', 'c']);for(let v of arr.keys()) { console.log(v)}// 'a' 'b' 'c'//Mapconst arr = new Map();arr.set('a', 'a');arr.set('b', 'b');for(let v of arr.keys()) { console.log(v)}// 'a' 'b' for…of循环解构对象对象本身不支持迭代，我们前边给对象添加生成器使其成为可迭代对象。这次我们给对象添加新的生成器使其可以使用for…of循环解构key和value 12345678910111213const obj = { a: 1, b: 2, *[Symbol.iterator](){ for(let i in obj){ yield [i, obj[i]] } }}for (let [key, value] of obj){ console.log(key, value) // 'a' 1 'b' 2} 高级功能高级功能就是涉及到一些传参、抛出异常、委托生成器等等功能，由于自己也不是特别理解，避免误导就不写太多，简单写一下传参和生成器的返回语句的用法吧，具体原理不太懂，如果后续有了比较好的理解，会修改这篇文章的。 传参不是特别理解这个概念，给大家看一下示例 123456789function *createIterator(){ let first = yield 1; yield first + 2}const a = createIterator()console.log(a.next()) // {value: 1, done: false}// 为什么是NaN呢？此时first为undefined，并不是第一句next返回的1console.log(a.next()) // {value: NaN, done: false}console.log(a.next()) // {value: undefined, done: true} 我们可以给next传入参数，它会替代掉上一个next的yield返回值 123456789function *createIterator(){ let first = yield 1; yield first + 2}const a = createIterator()console.log(a.next()) // {value: 1, done: false}// 此时first为5，传入的参数代替了上一句的yield返回值firstconsole.log(a.next(5)) // {value: 7, done: false}console.log(a.next()) // {value: undefined, done: true} 生成器返回语句生成器中添加return表示退出操作，函数中使用return应该没什么好说的。 12345678function *createIterator(){ yield 1; return; yield 2;}cosnt a = createIterator()console.log(a.next()) // {value: 1, done: false}console.log(a.next()) // {value: undefined, done: true} 委托生成器委托生成器就是生成器之间进行嵌套 只能给一个简单示例，太深入的用法不懂 1234567891011121314151617181920// 生成器1function *aIterator(){ yield 1; yield 2;}// 生成器2function *bIterator(){ yield 3;}// 生成器3function *cIterator(){ yield *aIterator() yield *bIterator()}// 会把内部的迭代器按顺序依次进行迭代，只有前一个的内容迭代完成，才会对后一个迭代器的内容进行迭代const i = cIterator()console.log(i.next()); // {value: 1, done: false}console.log(i.next()); // {value: 2, done: false}console.log(i.next()); // {value: 3, done: false}console.log(i.next()); // {value: undefined, done: true} 好吧，就先到这里了，后续有新理解再更新内容吧。","link":"/2021/12/13/%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1/"},{"title":"常用排序算法Python实现","text":"本文仅提供冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序的Python实现。 在最开始先列出上述排序算法的时间复杂度： 冒泡排序bubbleSort()复杂度O(n^2) 选择排序 selectionSort() 复杂度O(n^2) 插入排序 insertionSort() 复杂度O(n^2) 希尔排序 shellSort() 复杂度O(n)与O(n^2)之间 归并排序 mergeSort() 复杂度O(nlog n) 需要额外使用一倍的存储空间 快速排序 quickSort() 复杂度O(nlog n) 不需要额外使用存储空间 冒泡排序冒泡排序的思路在于对无序表进行多趟比较交换。 每趟包括了多次两两相邻比较，并将逆序(顺序)的数据项互换位置，最终能将本趟的最大项(最小项)就位。 经过n-1次比较、交换，实现整表的排序。 1234567def bubbleSort(list): # num就是还未完成排序的数据项的最后一项的下标 for num in range(len(list)-1, 0, -1): # 将未排序的数据项两两比较进行排序 for i in range(num): if list[i] &gt; list[i+1]: list[i], list[i+1] = list[i+1], list[i] 选择排序选择排序对冒泡排序进行了改进，保留了其基本的多趟比对思路，每趟都使当前最大项就位 但选择排序对交换进行了削减，相比起冒泡排序进行多次交换，每趟仅进行1次交换，记录最大项的所在位置，最后再跟本趟最后一项交换 123456789101112def selectionSort(list): # 与冒泡排序思想一致 for num in range(len(list)-1, 0, -1): # 最大项所在的位置 posMax = 0 # 需要下标，所以num+1保证可取到到最后一项的下标 for i in range(num+1): # 存储本趟的最大数据的位置 if list[i] &gt; list[posMax]: posMax = i # 循环结束后将最大数据放到最后，即num的位置 list[num],list[posMax] = list[posMax],list[num] 插入排序插入排序维持一个已排好序的子列表，其位置始终在列表的前部，然后逐步扩大这个子列表直到全表 第1趟，子列表仅包含第1个数据项，将第 2个数据项作为“新项”插入到子列表的合适位置中，这样已排序的子列表就包含了2个数据项 第2趟，再继续将第3个数据项跟前2个数据项比对，并移动比自身大的数据项，空出位置来，以便加入到子列表中 经过n-1趟比对和插入，子列表扩展到全表，排序完成 1234567891011121314def insertionSort(list): for i in range(1, len(list)): # 要插入的值 currentVal = list[i] # 目前的位置 pos = i # 如果 不在第一位且前一位的值大于要插入的值 while pos &gt; 0 and list[pos-1] &gt; currentVal: # 将前一位的值放到当前pos位置 list[pos] = list[pos-1] # 将pos前移 pos -= 1 # 在合适的位置将要插入的值插入 list[pos] = currentVal 冒泡排序，选择排序，插入排序的时间复杂度都比较高，也比较容易理解，接下来的几个排序算法需要好好理解一下。 希尔排序希尔排序是一种分组的插入排序算法 对无序表进行“间隔”划分子列表，每个子列表都执行插入排序 随着子列表的数量越来越少，无序表的整体越来越接近有序，从而减少整体排序的比对次数 最后一趟是标准的插入排序，但由于前面 几趟已经将列表处理到接近有序，这一趟仅需少数几次移动即可完成 上边的描述可能比较难以理解，给一个小示例作为思路就可以懂了： 1234567891011121314151617181920212223242526272829''' 希尔排序思路假定有一个列表list=[6,5,3,2,8,7,1,9,4],n为列表长度91.首先取一个整数d1=n//2，将元素分为d1个组，每组内相邻两元素之间距离为d1，在各组内直接进行插入排序： d1 = len(list) // 2 = 4 第一组 6 8 4 第二组 5 7 第三组 3 1 第四组 2 9 分为4组，每组内相邻两数据间隔为4，每组内进行排序 排序之后结果为： 第一组 4 6 8 第二组 5 7 第三组 1 3 第四组 2 9 然后将其恢复为列表： list = [4,5,1,2,6,7,3,9,8]2.取第二个整数d2=d1//2，重复上述排序过程，直到d=1，也就是所有元素在一个组内排序 d2 = d1 // 2 = 2 第一组 4 1 6 3 8 第二组 5 2 7 9 分为两组，间隔为2，每组内进行插入排序 第一组 1 3 4 6 8 第二组 2 5 7 9 恢复为列表： list = [1,2,3,5,4,7,6,9,8] 取第三个整数，d3 = d2 // 2 = 1，即只有这一组数据 此时列表已经接近有序，进行一次插入排序即可 list = [1,2,3,4,5,6,7,8,9]''' 可以发现，希尔排序就是分为多个组，在每个组内进行插入排序，不同的是排序的间隔不再是1，而是同组内相邻两元素的距离gap 只是逻辑上分为多个组进行排序，并没有真的将列表拆分为多个列表 1234567891011121314151617181920# 希尔排序算法def shellSort(list): # 去gap gap = len(list) // 2 # gap大于等于1就分组进行插入排序 while gap &gt;= 1: insertSortGap(list, gap) gap = gap // 2# 改造后可接收gap的插入排序def insertSortGap(list, gap): # 由于是分组进行，所以是从第一组的第二个元素的下标开始进行插入排序 for i in range(gap, len(list)): current = list[i] pos = i # 分组就在此处表现，每次pos与pos-gap两个位置去比较，而不是与其前1位进行比较 # 也就从逻辑上分为了多个组 while pos &gt; 0 and list[pos-gap] &gt;current: list[pos] = list[pos-gap] pos -= gap list[pos] = current 归并排序归并排序是递归算法，思路是将数据表持续分裂为两半，对两半分别进行归并排序，即先分解后合并。 也简单说一下思路好了： 123456789101112131415161718'''假定有一个列表list=[6,5,3,2,8,7,1,9]分解过程：一层一层分解 [6,5,3,2,8,7,1,9] [6,5,3,2] [8,7,1,9] [6,5] [3,2] [8,7] [1,9] [6] [5] [3] [2] [8] [7] [1] [9]合并过程：一层一层合并第一次： [6,5,3,2,8,7,1,9] [6,5,3,2] [8,7,1,9] [5,6] [2,3] [7,8] [1,9]第二次： [6,5,3,2,8,7,1,9] [3,2,5,6] [1,7,8,9]第三次： [1,2,3,5,6,7,8,9]''' 看一下代码，应该很容易理解，就是一个递归。 123456789101112131415161718192021222324252627282930def mergeSort(list): # 如果只有一个数据，就不需要再分解了，这是递归的结束条件 if len(list) &lt;= 1: return list # 取中间值 mid = len(list) // 2 # 左右两侧继续分解 left = mergeSort(list[:mid]) right = mergeSort(list[mid:]) # 准备一个空列表用于存放排好序的数据,这也就是所需的额外一倍内存空间 merged = [] # 合并 while left and right: if left[0] &lt; right[0]: # 注意这里不能直接放left[0]，要把left[0]从left中删除并放入merged merged.append(left.pop(0)) else: merged.append(right.pop(0)) # while循环结束，left或者right肯定有一个是空的，另一个是有数据的 # 将剩余的数据直接放入merged中 merged.extend(right if right else left) ''' extend函数用于在列表末尾一次性追加另一个列表中的多个值，如果不懂也可以写： while left: merged.append(left[0]) while right: merged.append(right[0]) ''' # 将排序好的列表返回 return merged 快速排序快速排序的思路是依据一个“中值”数据 项来把数据表分为两半 小于中值的一半 和大于中值的一半，然后每部分分别进行快速排序(递归) 快速排序的递归算法“递归三要素”如下 ​ 基本结束条件:数据表仅有1个数据项，自然是排好序的 ​ 缩小规模:根据“中值”，将数据表分为两半，最好情况是相等规模的两半 ​ 调用自身:将两半分别调用自身进行排序 注意：排序基本操作在分裂过程中完成！ 快速排序的思路： 选定中值，将表分为两半，最好是想等规模的两半 将两半分别调用自身进行排序(排序操作在分裂过程中) 设置左右标： 左标向右移动，右标向左移动 左标一直向右移动，碰到比中值大的就停止 右标一直向左移动，碰到比中值小的就停止 然后把左右标所指的数据项交换 直到左标移动到右标的右侧，即交错，停止移动 此时右标所指的位置就是中值应处的位置 将中值和这个位置的值进行交换 此时分裂完成，左半部比中值小，右半部比中值大 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 主程序def quickSort(list): # 调用辅助程序，执行分裂操作 quickSortHelper(list, 0, len(list)-1)# 辅助程序def quickSortHelper(list, first, last): # 如果最左侧下标 ＜ 最右侧下标，说明至少还有两个值 if first &lt; last: # 调用partition函数返回中值点 splitPoint = partition(list, first, last) # 拿到中值点的位置，分别将左右两侧递归调用进行排序 # 中值点在分裂过程中是已经排好序的，所以不需要对其进行排序 quickSortHelper(list, first, splitPoint-1) quickSortHelper(list, splitPoint+1, last)# 分裂程序def partition(list, first, last): # 将第一个值作为中值 pivotValue = list[first] # 设置左右标 leftMark = first + 1 rightMark = last # 左右标是否停止移动的标记 done = False while not done: # 如果左标不大于右标且左标数据小于中值，左标向右移动 while leftMark &lt;= rightMark and list[leftMark] &lt;= pivotValue: leftMark += 1 # 如果左标不大于右标且右标数据大于中值，右标向左移动 while leftMark &lt;= rightMark and list[rightMark] &gt;= pivotValue: rightMark -= 1 # 程序运行到这里肯定是上述两个循环程序都因为某个条件不满足 # 如果是因为右标小于左标了，那就停止移动 if rightMark &lt; leftMark: done = True else: # 不然就是因为左标的数据大于中值，右标的数据小于中值了 # 此时交换左右标的数据 list[leftMark], list[rightMark] = list[rightMark], list[leftMark] # 跳出循环了则满足rightMark &lt; leftMark # 由于是从小到大排列的，所以此时左标的位置数据大于中值，右标的位置的数据小于中值 # 我们将中值和右标所处位置的数据交换，即可保证中值左侧的比他小，右侧的比他大 list[first], list[rightMark] = list[rightMark], list[first] # 我们将应该存放中值的位置返回出去，用于程序对中值两侧分别进行快排 return rightMark 快速排序的算法比较绕，理解了中值应该放到什么位置，就能比较好的理解这个排序算法了。","link":"/2021/10/31/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Python%E5%AE%9E%E7%8E%B0/"},{"title":"实现图片的卷帘对比效果","text":"项目中遇到了一个需求是前台上传原图与对比图，后台进行对比分析，返回一个带有标注的识别结果，然后前台要实现原图与识别结果的卷帘对比效果。 我也不知道这个应该叫什么，感觉像个卷帘门一样，就姑且叫它卷帘效果了。 在学习arcgis的js api时，发现arcgis是有提供这种效果的小部件的，当然这次项目并没有使用arcgis，所以没法使用这个效果。后台问我这种效果好实现不，去找找插件试一下。回想到之前做过图片的截取效果，想着这个也可以用类似的方法实现的吧，所以就用同样的思想实现了这个效果，可能走了弯路，见谅哦。 先看下效果图吧(点击图片跳转到图床页可播放，感谢路过图床)： 接下来从图片的上传开始，到图片的预览，再到图片的对比效果，一步一步来。 图片上传因为需求比较简单，每次只需要上传一张图片到后台即可，所以图片的上传我并没有直接使用组件库提供的组件，而是使用了一个div实现上传按钮的样式，然后添加了一个隐藏的input标签，手动触发上传事件。 123456789&lt;input style=&quot;opacity: 0;width:0;height:0;&quot; type=&quot;file&quot; value=&quot;&quot; name=&quot;file&quot; ref=&quot;inputFile&quot; accept=&quot;image/gif,image/jpeg,image/jpg,image/png,image/svg&quot; @change=&quot;handleUploadImg($event)&quot; &gt; 当用户上传了文件触发了input标签的change事件后，我们在这里实现上传的操作。 12345678function handleUploadImg(event){ // 上传的文件 let file = event.target.files[0] // 后台通过formData接收，所以使用formData let formData = new FormData() formData.append('file', file) // 将formData传给后台即可完成上传} 图片预览在大多情况下，我们将图片文件传给后台之后，后台会返回图片文件的地址，我们将地址渲染到image标签上就可以完成预览了。 如果后台不返回图片的地址，或者我们需要用户选择后先进行预览，待用户再次确认后才进行上传，那么我们就需要对用户上传的图片进行操作实现预览了。 12345678910function handleUploadImg(event){ let file = event.target.files[0] let reader = new FileReader() // 读取图片文件为base64 reader.readAdDataURL(file) // 读取完成的回调函数 reader.onload = function(evt){ // evt.target.result 就是图片的base64，渲染到image即可 }} 卷帘的对比效果图片的上传与预览都是比较简单的工作，难点还是在实现卷帘的对比效果这一块 我的业务需求是上传一张图片进行ai识别，生成识别结果然后做对比效果的，在此处就简化一下直接拿两张图片来实现这个样式效果了。 说一下大概思路： 页面上会有两张图片，一张原图，一张对比图 原图放到底部作为底图，然后将对比图定位到原图的正上方，通过裁切显示指定的区域。 有用但又不常用的clip属性首先介绍一个可能不是那么常用的CSS样式属性clip，我们就要通过他来裁切我们的对比图。 w3c对于clip的定义是： clip 属性剪裁绝对定位元素。 这个属性用于定义一个剪裁矩形。对于一个绝对定义元素，在这个矩形内的内容才可见。出了这个剪裁区域的内容会根据 overflow 的值来处理。剪裁区域可能比元素的内容区大，也可能比内容区小。 1clip: rect(&lt;top&gt;, &lt;right&gt;, &lt;bottom&gt;, &lt;left&gt;) 如果我们要进行裁切的话，clip有且仅有这一种用法，接收的四个值是用于指定矩形四条边的位置，而不是四个点的坐标。 要注意的是：top和bottom是基于盒子的顶部边缘开始算的，left和right是基于盒子的左侧边缘开始算的 所以我们要传入的四个值分别是：矩形上边距离盒子顶部的距离，矩形右边距离盒子左侧的距离，矩形下边距离盒子顶部的距离，矩形左边距离盒子左侧的距离。 因为传入的不是坐标值，可能一下子不太适应，给一个简单的例子吧，比如我们有一个绝对定位的div，其宽度为800px，高度为400px，此时我们要将其裁剪为只显示右边一半区域，应该怎么写呢？ 1clip: rect(0, 800px, 400px, 400px) 确实不太符合常用坐标的直觉，熟悉一下也很容易接受的。 拖动事件确定好怎么裁切内容，接下来就要开始解决怎么改变裁切区域大小的问题了。 首先，我们需要一个元素供我们拖动，这个看你设计的样式，怎么实现都可以，不过建议是可以放到一个初始裁切区域大小相同位置相同的盒子中，然后将其绝对定位到左侧，这样在拖动过程中只需要改变盒子的大小就可以使拖动条位置跟随变化了。 这里并没有使用更新的drapstart,drag...等事件，而是监听了鼠标的mousedown,mousemove,mouseup事件。 不过绑定事件的时候要注意了，不要把所有的事件都绑定到滚动条上哦，只需要保证是在滚动条上按下鼠标即可。因为拖动过程中很容易把鼠标脱离滚动条，导致事件一致在触发了。 所以我们将mousedown事件绑定到滚动条，其余两个事件绑定到window上就可以了。 我们需要保证鼠标是在滚动条上按下才可以拖动，所以加入一个中间变量，鼠标的按下与抬起事件也就比较简单了。 123456789101112// 中间变量let ifKeyDown = false// mousedownfunction handleMouseDown(){ ifKeyDown = true}// mouseupfunction handleMouseUp(){ ifKeyDown = false} 接下来我们的拖动事件就可以根据中间变量的状态来决定是否执行了 12345function handleMouseMove(){ if(ifKeyDown){ // 拖动逻辑 }} 计算元素距离实现拖动逻辑在拖动过程中肯定要实时计算鼠标的位置来改变元素的裁切区域，而且我们需要限制拖动的边界值，我是通过计算元素距离屏幕左侧的位置来计算的。但是offsetLeft只能获取到元素距离其父元素左侧的距离，所以我们有必要写一个函数用于计算。 123456789function getLeftPX(dom){ let curLeft = dom.offsetLeft let parent = dom.offsetParent while (parent != null){ curLeft += parent.offsetLeft parent = parent.offsetLeft } return curLeft} 原图放到底部是不用动的，所以只需要改变对比图的裁切大小就好了 123456789101112131415161718192021222324252627282930313233343536373839function handleMouseMove(){ if(ifKeyDown){ // 拖动条 let dragDom = document.getElementById('dragDom') // 对比图 - 其大小是与原图一致的，只是通过裁切限制了显示的区域 let resultImg = document.getElementById('resultImg') // 计算左右边界 let minLeft = getLeftPX(resultImg) let maxLeft = minLeft + 元素的宽度 // 滚动条距离左侧的距离 let drapDomToLeft = getLeftPX(drapDom) // 滚动条盒子之前的宽度 let widthBefore = dragDom.offsetWidth // 鼠标的位置 let clientX = event.clientX // 初始化宽度的变化 let changeWidth; // 根据向左还是向右拖动执行不同操作 if(clientX &lt; dragDomToLeft){ // 向左拖动 changeWidth = dragDomToLeft - clientX // 没有超过左边界 if(dragDomToLeft - changeWidth &gt; minLeft){ dragDom.style.width = (changeWidth + widthBefore) + 'px' // 计算对比图裁切区域左侧的位置 let imgLeft = (元素宽度 - widthBefore) - changeWidth resultImg.style.clip = `rect(原来的上边界, 原来的右边界, 原来的下边界, ${imgLeft}px)` } }else{ // 向右拖动 changeWith = clientX - dragDomToLeft if(dragDomToLeft + changeWidth &lt; maxLeft){ dragDom.style.width = (widthBefore - changeWidth) + 'px' let imgLeft = (元素宽度 - widthBefore) + changeWidth resultImg.style.clip = `rect(原来的上边界, 原来的右边界, 原来的下边界, ${imgLeft}px)` } } }} 到此为止，效果已经基本实现了，计算可能有点儿绕，自己实际写一些应该就还挺容易理解的。","link":"/2021/12/02/%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E5%8D%B7%E5%B8%98%E5%AF%B9%E6%AF%94%E6%95%88%E6%9E%9C/"},{"title":"常用排序算法的Golang实现","text":"最近在学习Golang，就把之前写过的排序算法拿golang复刻一下吧。 实现思路可以看python篇哈。 冒泡排序12345678910func bubbleSort(nums []int) { n := len(nums) for i := n - 1; i &gt; 0; i-- { for j := 0; j &lt; i; j++ { if nums[j] &gt; nums[j+1] { nums[j], nums[j+1] = nums[j+1], nums[j] } } }} 选择排序12345678910111213func selectSort(nums []int) { n := len(nums) for i := n; i &gt; 0; i-- { pos := 0 for j := 0; j &lt; i; j++ { if nums[j] &gt; nums[pos] { pos = j } } nums[i-1], nums[pos] = nums[pos], nums[i-1] }} 插入排序123456789101112func insertSort(nums []int) { n := len(nums) for i := 1; i &lt; n; i++ { cur := nums[i] pos := i for pos &gt; 0 &amp;&amp; cur &lt; nums[pos-1] { nums[pos] = nums[pos-1] pos -= 1 } nums[pos] = cur }} 希尔排序1234567891011121314151617181920func shellSort(nums []int) { n := len(nums) gap := n / 2 for gap &gt;= 1 { insertByGap(nums, gap) gap /= 2 }}func insertByGap(nums []int, gap int) { n := len(nums) for i := gap; i &lt; n; i += gap { cur := nums[i] pos := i for pos &gt; 0 &amp;&amp; nums[pos-gap] &gt; cur { nums[pos] = nums[pos-gap] pos -= gap } nums[pos] = cur }} 归并排序123456789101112131415161718192021222324252627func mergeSort(nums []int) []int { n := len(nums) if n &lt;= 1 { return nums } mid := n / 2 left := mergeSort(nums[:mid]) right := mergeSort(nums[mid:]) var merged []int for len(left) &gt; 0 &amp;&amp; len(right) &gt; 0 { if left[0] &lt; right[0] { merged = append(merged, left[0]) left = left[1:] } else { merged = append(merged, right[0]) right = right[1:] } } if len(left) &gt; 0 { merged = append(merged, left...) } if len(right) &gt; 0 { merged = append(merged, right...) } return merged} 快速排序12345678910111213141516171819202122232425262728293031func quickSort(nums []int) { quickSortHelper(nums, 0, len(nums)-1)}func quickSortHelper(nums []int, first, last int) { if first &lt; last { splitPoint := partition(nums, first, last) quickSortHelper(nums, first, splitPoint-1) quickSortHelper(nums, splitPoint+1, last) }}func partition(nums []int, first, last int) int { pivotValue := nums[first] leftMark := first + 1 rightMark := last done := false for !done { for leftMark &lt;= rightMark &amp;&amp; nums[leftMark] &lt;= pivotValue { leftMark += 1 } for leftMark &lt;= rightMark &amp;&amp; nums[rightMark] &gt;= pivotValue { rightMark -= 1 } if leftMark &gt; rightMark { done = true } else { nums[leftMark], nums[rightMark] = nums[rightMark], nums[leftMark] } } nums[first], nums[rightMark] = nums[rightMark], pivotValue return rightMark} 现在这个是移动数据的位置，还有一个更简洁的实现方式，直接赋值，但是可能理解起来没那么容易： 1234567891011121314151617181920212223242526func quickSortSimple(nums []int) { var helper func([]int, int, int) helper = func(arr []int, begin int, end int) { if begin &lt; end { i := begin j := end empty := arr[begin] for i &lt; j { for i &lt; j &amp;&amp; arr[j] &gt; empty { j-- } arr[i] = arr[j] for i &lt; j &amp;&amp; arr[i] &lt; empty { i++ } arr[j] = arr[i] } arr[i] = empty helper(arr, begin, i-1) helper(arr, i+1, end) } else { return } } helper(nums, 0, len(nums)-1)} 计数排序接收一个数组和数组中的最大值，统计每一个数字的个数，然后排序。 12345678910111213141516171819func countingSort(arr []int, maxValue int) []int { bucketLen := maxValue + 1 bucket := make([]int, bucketLen) sortedIndex := 0 length := len(arr) // 统计arr中每一个数字出现的次数 for i := 0; i &lt; length; i++ { bucket[arr[i]] += 1 } for j := 0; j &lt; bucketLen; j++ { for bucket[j] &gt; 0 { arr[sortedIndex] = j sortedIndex += 1 bucket[j] -= 1 } } return arr}","link":"/2023/01/17/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84Golang%E5%AE%9E%E7%8E%B0/"},{"title":"常用排序算法的JavaScript实现","text":"之前做过常用排序算法的python实现，因为python的语法简单，个人喜欢用python去练习算法题目，毕竟自己是以JavaScript作为主力开发语言的，python仅仅知道基础语法，所以以后准备用JavaScript去练习算法。先把常用排序算法用JavaScript重新实现一遍吧。 直接给答案，就不介绍了，思路可以看python篇。 冒泡排序1234567891011121314151617181920/** * @desc 冒泡排序 * @param {number[]} list */function bubbleSort(list){ for(let i=list.length-1; i&gt;0; i--){ for(let j=0; j&lt;i; j++){ if(list[j] &gt; list[j+1]){ let cur = list[j] list[j] = list[j+1] list[j+1] = cur } } }}let arr = [3, 14, 6, 4, 8, 7, 25, 9, 0, 12, 13, 24,10, 17]bubbleSort(arr)// arr: [0, 3, 4, 6, 7, 8, 9, 10, 12, 13, 14, 17, 24, 25]console.log(&quot;arr:&quot;, arr) 选择排序123456789101112131415161718192021/** * @desc 选择排序 * @param {number[]} list */function selectionSort(list){ for(let i=list.length; i&gt;0; i--){ let posMax = 0 for(let j=0; j&lt;i; j++){ if(list[j] &gt; list[posMax]){ posMax = j } } let cur = list[posMax] list[posMax] = list[i-1] list[i-1] = cur }}let arr = [3, 14, 6, 4, 8, 7, 25, 9, 0, 12, 13, 24,10, 17]selectionSort(arr)// arr: [0, 3, 4, 6, 7, 8, 9, 10, 12, 13, 14, 17, 24, 25]console.log(&quot;arr:&quot;, arr) 插入排序1234567891011121314151617181920/** * @desc 插入排序 * @param {number[]} list */function insertionSort(list){ for(let i=1; i&lt;list.length; i++){ let cur = list[i] let pos = i while (pos &gt; 0 &amp;&amp; list[pos-1] &gt; cur) { list[pos] = list[pos-1] pos -= 1 } list[pos] = cur }}let arr = [3, 14, 6, 4, 8, 7, 25, 9, 0, 12, 13, 24,10, 17]insertionSort(arr)// arr: [0, 3, 4, 6, 7, 8, 9, 10, 12, 13, 14, 17, 24, 25]console.log(&quot;arr:&quot;, arr) 希尔排序1234567891011121314151617181920212223242526272829303132/** * @desc 希尔排序 * @param {number[]} list */function shellSort(list){ let gap = Math.floor(list.length / 2) while(gap &gt;= 1){ insertSortByGap(list, gap) gap = Math.floor(gap / 2) }}/** * @desc 希尔排序的辅助算法，就是一个基于gap的插入排序 * @param {number[]} list * @param {number} gap */function insertSortByGap(list, gap){ for(let i=gap; i&lt;list.length; i++){ let pos = i let cur = list[i] while(pos &gt; 0 &amp;&amp; list[pos-gap] &gt; cur){ list[pos] = list[pos-gap] pos -= gap } list[pos] = cur }}let arr = [3, 14, 6, 4, 8, 7, 25, 9, 0, 12, 13, 24,10, 17]shellSort(arr)// arr: [0, 3, 4, 6, 7, 8, 9, 10, 12, 13, 14, 17, 24, 25]console.log(&quot;arr:&quot;, arr) 归并排序123456789101112131415161718192021222324252627282930/** * @desc 归并排序 * @param {number[]} list */function mergeSort(list){ if(list.length &lt;= 1){ return list } let mid = Math.floor(list.length / 2) let left = mergeSort(list.slice(0, mid)) let right = mergeSort(list.slice(mid)) let merged = [] while(left &amp;&amp; left.length&gt;0 &amp;&amp; right &amp;&amp; right.length&gt;0){ if(left[0] &lt; right[0]){ merged.push(left.shift()) }else{ merged.push(right.shift()) } } if(left &amp;&amp; left.length&gt;0){ merged.push(...left) }else{ merged.push(...right) } return merged}let arr = [3, 14, 6, 4, 8, 7, 25, 9, 0, 12, 13, 24,10, 17]let newArr = mergeSort(arr)// arr: [0, 3, 4, 6, 7, 8, 9, 10, 12, 13, 14, 17, 24, 25]console.log(&quot;arr:&quot;, newArr) 快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @desc 快速排序入口程序 * @param {number[]} list */function quickSort(list){ quickSortHelper(list, 0, list.length - 1)}/** * @desc 辅助程序，通过中值将列表分开分别进行快速排序 * @param {number[]} list * @param {number} first 开始下标 * @param {number} last 结束下标 */function quickSortHelper(list, first, last){ if(first &lt; last){ let splitPoint = partition(list, first, last) quickSortHelper(list, first, splitPoint-1) quickSortHelper(list, splitPoint+1, last) }}/** * @desc 分裂程序，返回中值 * @param {number[]} list * @param {number} first * @param {number} last * @returns {number} */function partition(list, first, last){ let pivotValue = list[first] let leftMark = first + 1 let rightMark = last let done = false while(!done){ while (leftMark &lt;= rightMark &amp;&amp; list[leftMark] &lt;= pivotValue){ leftMark += 1 } while(leftMark &lt;= rightMark &amp;&amp; list[rightMark] &gt;= pivotValue){ rightMark -= 1 } if(leftMark &gt; rightMark){ done = true }else{ let cur = list[leftMark] list[leftMark] = list[rightMark] list[rightMark] = cur } } list[first] = list[rightMark] list[rightMark] = pivotValue return rightMark}let arr = [3, 14, 6, 4, 8, 7, 25, 9, 0, 12, 13, 24,10, 17]quickSort(arr)// arr: [0, 3, 4, 6, 7, 8, 9, 10, 12, 13, 14, 17, 24, 25]console.log(&quot;arr:&quot;, arr) 计数排序123456789101112131415161718function countingSort(arr: number[], maxValue: number): number[] { let bucketLen = maxValue + 1 let bucket = new Array(bucketLen+1).fill(0) let sortedIndex = 0 let length = arr.length for (let i = 0; i &lt; length; i ++) { bucket[arr[i]] += 1 } for (let j = 0; j &lt; bucketLen; j ++) { while(bucket[j] &gt; 0) { arr[sortedIndex] = j sortedIndex += 1 bucket[j] -= 1 } } return arr}","link":"/2022/08/03/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84JavaScript%E5%AE%9E%E7%8E%B0/"},{"title":"搭建cli脚手架","text":"大家都会用到@vue/cli或者create-react-app这种脚手架，但是每个公司都或多或少有一些自己的基础框架。每次都从头搭建一个项目比较麻烦，所以准备搭建一个简单的脚手架方便生成项目代码。 前期搭建准备脚手架用到了以下几个库： chalr： 用于命令行绘制彩色文字 commander： 用于提供指令，例如vue/cli的vue create appname就是一个指令 download: 下载 fs-extra： 好用的文件处理 ora： 用于加载动画 inquirer： 用于命令行交互，例如vue/cli在命令行让选择vue版本，css处理器等交互功能。 项目的目录结构如下： cli |____ bin # bin目录 | |____ cli # 入口文件，可以没有后缀名 |____ lib # lib目录 | | ____ create.js # 创建项目过程中的主要交互逻辑 | | ____ Creator.js # Creator类 | | ____ Downloader.js # Downloader类 | ____ package.json 目前的脚手架功能其实没必要这么复杂，但是后续还要有新功能加入，所以暂时搞成这个样子了。 在package.json中配置bin属性。 12345{ &quot;bin&quot;: { &quot;name&quot;: &quot;./bin/cli&quot; }} 这么配置之后就是调用name指令会执行bin/cli这个文件。比如你要用vue create appname来创建项目就配置name为vue这样就可以。 脚手架文件脚手架是以nodejs运行的，在代码的头部加上\\#! /usr/bin/env node标明是以nodejs运行的。 bin/cli 1234567891011121314151617181920212223242526#! /usr/bin/env nodeconst program = require(&quot;commander&quot;);const chalk = require(&quot;chalk&quot;)// 定义指令program .command(`create &lt;app-name&gt;`) .description(`create a new project`) .option('-f, --force', 'overwrite target directory if it exists') .action((name, cmd) =&gt; { require('../lib/create')(name, cmd) })program.on('--help', function(){ console.log() console.log(`Run ${chalk.cyan('脚手架name &lt;command&gt; --help')} for details`) console.log()})program .version(`脚手架名字 ${require(&quot;../package.json&quot;).version}`) .usage(`&lt;command&gt; [option]`)// 解析用户执行命令传入的参数program.parse(process.argv); 这里只是搭建了基础功能，还有更多功能可以自行扩展 command 指令 description 描述 option 额外选项，比如这里的-f就是强制替换同名目录 拉取git仓库创建项目我们在调用create 指令之后调用了lib/create.js这个文件 lib/create.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require(&quot;path&quot;)const fse = require(&quot;fs-extra&quot;)const Inquirer = require(&quot;inquirer&quot;)const Creator = require(&quot;./Creator&quot;)const ora = require(&quot;ora&quot;)module.exports = async function create(projectName, options){ // 当前工作目录 const cwd = process.cwd() // 目标目录 const targetDir = path.join(cwd, projectName) // 如果已存在同名目录 if(fse.existsSync(targetDir)){ // 如果是强制创建项目 --force , -f if(options.force){ // 移除已有目录 await fse.remove(targetDir) }else{ // 提示用户是否确认覆盖 let {action} = await Inquirer.prompt([ // 询问方式 { name: &quot;action&quot;, type: &quot;list&quot;, message: &quot;Target directory already exists, Please pick an action&quot;, choices: [ // 选项 {name: &quot;Overwrite&quot;, value: &quot;overwrite&quot;}, {name: &quot;Cancel&quot;, value: false} ] } ]) // 如果cancel直接退出 if(!action){ return; }else if(action === &quot;overwrite&quot;){ let spinner = ora(&quot;wating for remove...&quot;) spinner.start() await fse.remove(targetDir) spinner.succeed(&quot;remove success&quot;) } } } // 正式创建流程 const creator = new Creator(projectName, targetDir) // 开始创建 creator.create() } lib/Creator.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const Inquirer = require(&quot;inquirer&quot;)const path = require(&quot;path&quot;)const Downloader = require(&quot;./Downloader&quot;)const fse = require(&quot;fs-extra&quot;)const fs = require(&quot;fs&quot;)const chalk = require(&quot;chalk&quot;)class Creator { constructor(projectName, targetDir){ this.name = projectName this.target = targetDir } async create(){ let repo = await this.fetchRepo() await this.download(repo) } /** * @author zhaolei_hu * @description 查询仓库列表 * @returns {string} repo 选择的仓库 */ async fetchRepo(){ // 这里可以动态获取，我这边不做演示，写死 let {repo} = await Inquirer.prompt({ name: &quot;repo&quot;, type: &quot;list&quot;, choices: [&quot;vue2&quot;, &quot;vue3&quot;], message: &quot;Please choice a template to create project&quot; }) return repo } /** * @author zhaolei_hu * @description 下载 * @param {string} repo */ async download(repo){ let requestUrl = `仓库地址` let downloader = new Downloader(requestUrl, path.resolve(process.cwd(), this.name), this.name) downloader.download(this.downloadResHandler, this) } /** * @author zhaolei_hu * @description 下载结果处理 * @param {*} err */ async downloadResHandler(err){ if(err){ return; } let dir = path.resolve(process.cwd(), this.name) await this.editName(dir, this.name) } /** * @author zhaolei_hu * @description 修改package.json的name为项目名 * @param {string} dir * @param {string} name */ async editName(dir, name){ try { const packageObj = await fse.readJson(path.resolve(dir, &quot;package.json&quot;)) packageObj.name = name await fse.outputFile(path.resolve(dir, &quot;package.json&quot;), JSON.stringify(packageObj, &quot;&quot;, &quot;\\t&quot;)) this.drawMessage(name) } catch (err) { console.error(err) } } /** * @author zhaolei_hu * @description 绘制提示信息 */ drawMessage(name){ let logo = fs.readFileSync(path.resolve(__dirname, &quot;logo.txt&quot;), &quot;utf-8&quot;) console.log(logo) console.log(chalk.hex(&quot;#ccc&quot;).bold(&quot;🎉 Successfully created project.&quot;)) console.log(chalk.hex(&quot;#ccc&quot;).bold(&quot;👉 Get started with the following commands:&quot;)) console.log() console.log(' ' + chalk.hex(&quot;#666&quot;).bold(&quot;$&quot;) + &quot; &quot; + chalk.hex(&quot;#60d1dd&quot;).bold('cd '+name)) console.log(' ' + chalk.hex(&quot;#666&quot;).bold(&quot;$&quot;) + &quot; &quot; + chalk.hex(&quot;#60d1dd&quot;).bold('npm install')) console.log(' ' + chalk.hex(&quot;#666&quot;).bold(&quot;$&quot;) + &quot; &quot; + chalk.hex(&quot;#60d1dd&quot;).bold('npm run serve')) console.log() }}module.exports = Creator lib/Downloader.js 12345678910111213141516171819202122232425262728293031323334353637383940414243const downloadUrl = require('download')const ora = require(&quot;ora&quot;)class Downloader { /** * @author zhaolei_hu * @param {string} requestUrl 仓库地址 * @param {string} targetDir 存储地址 * @param {string} 项目名 */ constructor(requestUrl, targetDir, name){ this.requestUrl = requestUrl this.targetDir = targetDir this.name = name } /** * @author zhaolei_hu * @description download * @param {Function} fn * @param {Creator} creator Creator实例，保证this指向问题 */ async download(fn,creator){ let spinner = ora(&quot;please wait for a moment, downloading...&quot;) spinner.start() let downloadOptions = { extract: true, strip: 1, mode: '666', headers: { accept: 'application/zip', } } downloadUrl(this.requestUrl, this.targetDir, downloadOptions) .then(function () { spinner.succeed(&quot;download success&quot;); fn.call(creator) }) .catch(function (err) { spinner.fail(&quot;download failed, please retry...&quot;) fn.call(creator, err) }) }}module.exports = Downloader 这里的代码也并不复杂，看一下注释应该就没问题，基本流程就是选择要下载的仓库，然后去git拉取仓库下来，然后可以对package.json做一些额外配置，比如改项目名等等。。。 fs-extra可以很方便对处理json JSON.stringify(xx,xx, “\\t”)中传入制表符为了格式化json文件","link":"/2022/09/16/%E6%90%AD%E5%BB%BAcli%E8%84%9A%E6%89%8B%E6%9E%B6/"},{"title":"浏览器数据库系统-IndexedDB","text":"前端存储数据，我们一般会用到cookie和Web Storage，但是他们都有存储长度的限制，尤其是cookie存储内容是比较小的。如果想要大容量的存储就要用到浏览器的数据库indexedDB了，第一次听说indexedDB是在美团开源的前端监控项目中，用indexedDB存储了日志，但是并没有去研究这个项目，也没有对indexedDB进行学习，但是前段时间接手了一个项目用到了indexedDB来存储数据，所以抽点时间来学习一下。 IndexedDB介绍IndexedDB 是一种底层 API，用于在客户端存储大量的结构化数据（也包括文件/二进制大型对象（blobs））。该 API 使用索引实现对数据的高性能搜索。 IndexedDB 是一个事务型数据库系统，类似于基于 SQL 的 RDBMS。然而，不像 RDBMS 使用固定列表，IndexedDB 是一个基于 JavaScript 的面向对象数据库。IndexedDB 允许您存储和检索用键索引的对象；可以存储结构化克隆算法支持的任何对象。 IndexedDB 并不支持 SQL 查询。 特点 键值对储存 IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入。 每一个数据都有对应的主键，主键不能重复。 IndexedDB 操作是异步的，不会堵塞浏览器。 支持事务 遵守同源策略，不能操作其他域名下的数据库。 存储空间大。 关于异步问题，引自MDN： 使用 IndexedDB 执行的操作是异步执行的，以免阻塞应用程序。IndexedDB 最初包括同步和异步 API。同步 API 仅用于 Web Workers，且已从规范中移除，因为尚不清晰是否需要。但如果 Web 开发人员有足够的需求，可以重新引入同步 API。 基本使用连接数据库直接放一段简单的代码，看一下怎么连接数据库： 123456789101112const request = window.indexedDB.open('db1')request.onerror = (event) =&gt; { console.log('error:', event)}request.onsuccess = (event) =&gt; { console.log('success:', event)}request.onupgradeneeded = function(event) { console.log('upgrade:', event)}; 先解释一下代码的内容： window.indexedDB.open('db1'): 我们打开一个名为 db1 的数据库，如果不存在会创建。 onsuccess： 数据库连接成功触发 onerror： 数据库连接失败触发 onupgradeneeded： 数据库初次连接和版本升级触发 执行上面的代码，我们会看到控制台打印了内容，并成功创建了名为 db1 的数据库，且版本为1 其他的都很好理解，但是版本是怎么控制的呢？ 其实window.indexedDB.open()接受两个参数： name：string，数据库的名字 version：number，数据库的版本，是一个可选参数，如果我们省略了该参数的情况下： 如果数据库不存在，会创建version为1的数据库，即会触发 onupgradeneeded 如果数据库已经存在了，会以当前的version打开，即不会触发 onupgradeneeded 我们可以指定一个版本号来升级数据库的版本看一下： 1const request = window.indexedDB.open('db1', 5) 可以看一下控制台与数据库的信息： 可以发现成功打开了数据库且触发了 onupgradeneeded 如果此时我们降低版本呢？ 1const request = window.indexedDB.open('db1', 2) 好吧，出错了，数据库版本并没有被降低，我们可以看到报错信息 The requested version (2) is less than the existing version (5). ，所以并不能通过这种方式来降低数据库的版本。 一般我们会在 onupgradeneeded 中创建 ObjectStore，版本更新后并不会删除之前版本创建的 store，之前版本的 store 是依然存在的。 多次创建相同名称的 store 会抛出错误，即使数据库版本不同。 例： 1234567request.onupgradeneeded = function(event) { // 保存 IDBDataBase 接口 var db = event.target.result; // 为该数据库创建一个对象仓库 var objectStore = db.createObjectStore(&quot;name&quot;, { keyPath: &quot;myKey&quot; });}; 增删改查我们先来对数据库写入一些数据用于后边的演示： 1234567891011121314151617181920212223242526272829303132const dbName = 'db1'// 连接数据库const request = window.indexedDB.open(dbName, 1)// 错误处理request.onerror = function() {}// 假设我们要存储的数据如下const users = [ { id: 1, name: 'xiaoming', age: 20, idCard: '123' }, { id: 2, name: 'xiaohong', age: 18, idCard: '456' }, { id: 3, name: 'dahuang', age: 22, idCard: '789' }]// onupgradeneeded是我们唯一可以修改数据库结构的地方，可以在这里创建对象存储空间request.onupgradeneeded = function(e) { // 获取数据库 const db = e.target.result // 创建对象仓库，我们选择id作为key path，因为其是唯一的。 const objectStore = db.createObjectStore('users', { keyPath: 'id' }) // 使用idCard建立索引，因为其不会重复，我们使用unique索引 [name, keyPath, options] objectStore.createIndex('idCard', 'idCard', { unique: true }) // 使用事务的 oncomplete 事件确保在插入数据前对象仓库已经创建完毕 objectStore.transaction.oncomplete = function() { // 需要开启一个事务才能对你的创建的数据库进行操作 const usersObjectStore = db.transaction('users', 'readwrite').objectStore('users') users.forEach(user =&gt; { usersObjectStore.add(user) }) }} 执行代码可以发现已经写入了数据： 需要开启一个事务才能对你的创建的数据库进行操作。事务来自于数据库对象，而且你必须指定你想让这个事务跨越哪些对象仓库。一旦你处于一个事务中，你就可以目标对象仓库发出请求。你要决定是对数据库进行更改还是只需从中读取数据。事务提供了三种模式：readonly、readwrite 和 versionchange。 因为已经创建了数据库，如果不再修改版本号，是不会再次触发 onupgradeneeded事件的，所以后续的增删改查我们在 onsuccess 中获取数据库来进行演示： 增加数据使用 add 方法： 123456789101112131415161718192021222324request.onsuccess = function(event) { const db = event.target.result // 通过db.transaction获取一个事务，第一个参数是 希望操作的对象存储空间的列表，只有一个也可以用字符串。 第二个参数就是事务的模式 const transaction = db.transaction(['users'], 'readwrite') // 成功与失败的回调 transaction.oncomplete = function() { console.log('all done') } transaction.onerror = function () { console.log('error') } // 获取对象存储空间 const store = transaction.objectStore('users') // 增加数据使用add方法 store.add({ id: 4, name: 'daming', age: 22, idCard: '000' })} 修改数据使用 put 方法 1234567891011121314151617181920212223242526272829303132request.onsuccess = function(event) { const db = event.target.result // 通过db.transaction获取一个事务，第一个参数是 希望操作的对象存储空间的列表，只有一个也可以用字符串。 第二个参数就是事务的模式 const transaction = db.transaction(['users'], 'readwrite') // 成功与失败的回调 transaction.oncomplete = function() { console.log('all done') } transaction.onerror = function () { console.log('error') } // 获取对象存储空间 const store = transaction.objectStore('users') // 增加数据使用add方法 // store.add({ // id: 4, // name: 'daming', // age: 22, // idCard: '000' // }) // 修改数据使用put方法 store.put({ id: 2, name: 'new name', age: 30, idCard: 'xxx' })} 删除数据使用 delete 方法 12345678910111213141516171819202122232425262728293031323334request.onsuccess = function(event) { const db = event.target.result // 通过db.transaction获取一个事务，第一个参数是 希望操作的对象存储空间的列表，只有一个也可以用字符串。 第二个参数就是事务的模式 const transaction = db.transaction(['users'], 'readwrite') // 成功与失败的回调 transaction.oncomplete = function() { console.log('all done') } transaction.onerror = function () { console.log('error') } // 获取对象存储空间 const store = transaction.objectStore('users') // 增加数据使用add方法 // store.add({ // id: 4, // name: 'daming', // age: 22, // idCard: '000' // }) // 修改数据使用put方法 // store.put({ // id: 2, // name: 'new name', // age: 30, // idCard: 'xxx' // }) // 删除数据使用delete方法，依据key path删除 store.delete(3)} 查询数据使用 get/getAll 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445request.onsuccess = function(event) { const db = event.target.result // 通过db.transaction获取一个事务，第一个参数是 希望操作的对象存储空间的列表，只有一个也可以用字符串。 第二个参数就是事务的模式 const transaction = db.transaction(['users'], 'readwrite') // 成功与失败的回调 transaction.oncomplete = function() { console.log('all done') } transaction.onerror = function () { console.log('error') } // 获取对象存储空间 const store = transaction.objectStore('users') // 增加数据使用add方法 // store.add({ // id: 4, // name: 'daming', // age: 22, // idCard: '000' // }) // 修改数据使用put方法 // store.put({ // id: 2, // name: 'new name', // age: 30, // idCard: 'xxx' // }) // 删除数据使用delete方法，依据key path删除 // store.delete(3) // 查询数据使用get，依照key path查询 const result = store.get(2) result.onsuccess = function(e) { console.log(e.target.result) } // 查询全部使用getAll const allResult = store.getAll() allResult.onsuccess = function(e) { console.log(e.target.result) }} 以上就是一些 indexedDB 的常用 API 的说明了，用起来吧感觉确实不优雅，感觉自己也并没有什么应用场景，所以如果有场景深入使用有更深的理解再继续更这篇帖子吧。","link":"/2023/06/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-IndexedDB/"},{"title":"经典面试题[1,2,3].map(parseInt)解析","text":"最近看到这道经典面试题[1,2,3].map(parseInt)，本来想的很简单，不就是把1，2，3分别传入parseInt然后返回嘛，结果不应该是[1,2,3]嘛，但是看了答案才发现不是这么简单，还是要细心点多想想。。。 这道题目其实真心不难，只要相同了就好，我们拆解开来看。 map函数map()方法创建一个新数组，其结果是该数组中每个元素都调用一个提供的函数后返回的结果。 123let newArray = array.map((item[, index[, array]]) =&gt; { // return...}) item： 回调函数当前正在处理的元素 index： 正在处理元素的索引 array： 调用map的数组 一般来说我们只需要用到item就够了，但是这几个参数map方法是全部会传递给你的 划重点，item，index，array这几个参数在回调函数中是都可以接收到的 接下来看parseInt方法吧 parseIntparseInt(string, radix)将一个字符串string转为radix进制的整数，返回解析后的整数的十进制数，如果无法解析则返回NaN。 string： 要解析到值 radix： 2-36之间的一个基数或者说进制。 123parseInt(10) // 10 ---- 10进制的字符串'10'转成10parseInt(10, 2) // 2 ---- 2进制的字符串’10‘转成2parseInt(3, 2) // NaN --- 在2进制中不存在3 对于radix还需要注意在基数为 undefined，或者基数为 0 或者没有指定的情况下，JavaScript 作如下处理： 如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制). 如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。 综合map和parseInt记住map方法中回调函数的第二个参数是操作元素的索引 所以 1[1,2,3].map(parseInt) 等同于 123[1,2,3].map((item, index) =&gt; { return parseInt(item, index)}) 所以得到的结果数组应该是 1[parseInt(1, 0), parseInt(2, 1), parseInt(3, 2)] 二进制中不可能有3，同样1作为基数也不可能有2 所以最终结果是 1[1, NaN, NaN]","link":"/2022/08/23/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98-1-2-3-map-parseInt-%E8%A7%A3%E6%9E%90/"},{"title":"肆:Cancel与CancelToken","text":"前边碰到取消请求相关的部分内容都是直接略过的，现在主线任务已经完成了，好好看一下支线任务Cancel与CancelToken吧。 取消请求的相关源码存放在lib/cancel目录下，我们先分析一下该目录下的几个文件，然后看一下在axios中是怎么使用他们的。 Cancel类Cancel类的内容太简单了，构造函数接收一个message，原型对象上有一个方法和一个属性。直接贴代码吧。 123456789function Cancel(message) { this.message = message;}Cancel.prototype.toString = function toString() { return 'Cancel' + (this.message ? ': ' + this.message : '');};Cancel.prototype.__CANCEL__ = true; isCancel方法isCancel方法就更简单了，在Cancel类中我们知道Cancel实例的原型对象上有一个属性__CANCEL__的值为true，就判断一下就可以了。 123function isCancel(value) { return !!(value &amp;&amp; value.__CANCEL__);}; CancelToken类CancelToken类才是重点，我们前边在dispatchRequest等地方忽略的内容就用到了CancelToken实例的方法。 CancelToken是一个可以用于取消请求的对象 CancelToken类接收一个函数，在内部会调用这个函数并传入一个新的函数cancel作为参数。 注意CancelToken实例上会有一个属性promise，这个promise在cancel函数内才会resolve。 123456789101112131415161718192021function CancelToken(executor) { if (typeof executor !== 'function') { throw new TypeError('executor must be a function.'); } var resolvePromise; this.promise = new Promise(function promiseExecutor(resolve) { resolvePromise = resolve; }); var token = this; executor(function cancel(message) { if (token.reason) { // Cancellation has already been requested return; } token.reason = new Cancel(message); resolvePromise(token.reason); });} 原型对象上有一个方法throwIfRequested。如果CancelToken实例上有reason就抛出错误抛出reason也就是Cancel实例。 12345CancelToken.prototype.throwIfRequested = function throwIfRequested() { if (this.reason) { throw this.reason; }}; CancelToken类还有一个source方法，方法返回一个对象包含CancelToken实例和用于取消请求的方法。 12345678910CancelToken.source = function source() { var cancel; var token = new CancelToken(function executor(c) { cancel = c; }); return { token: token, cancel: cancel };}; 开发中使用CancelToken取消请求看了CancelToken的源码肯定是有些懵的，为什么要这么做呢？ 我们看一下在真正的开发过程中可以使用的一种取消请求方式： 调用source拿到取消方法，调用这个方法取消请求 12345678const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.post('xx', { name: 'new name'}, { cancelToken: source.token})source.cancel('请勿重复提交'); 再看一下另一种方式： 这个就有点像是自己实现了source方法了，最后还是调用了这个取消请求的方法 12345678910const CancelToken = axios.CancelToken;let cancel;axios.post('xx', { cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; })});// 取消请求cancel(); 现在应该对于CancelToken有一些理解了，虽然我没get到这样设计的好处。 至于为什么调用取消请求的方法就能取消请求了我们往下看哦。 在xhr中的应用前边在dispatchRequest和xhr中都略过了取消请求的部分。 dispatchRequest中就是调用了CancelToken的throwIfRquested这个方法，就不单独说了。 看一下在xhr中的使用，大家要记得CancelToken中的promise我们还没用到呢。在xhr中有如下代码，位于XMLHttpRequest.send()之前。 12345678910111213if (config.cancelToken) { // Handle cancellation config.cancelToken.promise.then(function onCanceled(cancel) { if (!request) { return; } request.abort(); reject(cancel); // Clean up request request = null; });} 大家应该记得在CancelToken中执行了executor并传入了一个函数cancel。如果执行cancel这个函数就会将promise给resolve对吧，所以在我们执行了取消请求的方法之后，promsie会resovle进入.then内部会通过abort方法取消正在进行的异步请求然后在xhr中的promise中调用reject抛出错误。这样请求就被取消了。 即便到现在我也不理解为什么只有axios可以使用CancelToken，但是axios.create创建的实例却不能。 就像在axios1.x版本中，通过axios.create创建的实例可以继续调用create创建实例了，但依然不能取消请求。 关于axios新版本，看时间安排尽量出一期新版本的改动内容吧。","link":"/2022/10/26/%E8%82%86-Cancel%E4%B8%8ECancelToken/"},{"title":"记录vue3学习使用中遇到的小问题","text":"vue3稳定版发布了很久了，很多人也已经开始将vue3应用于生产环境，后续准备开几篇博客写一下自己学习vue3的一些记录，内容比较多比较杂就不好说什么时候开始写了，这篇就简单记录一些vue3使用中发现的一些与vue2的不同吧。 深度样式问题在vue中我们经常遇到一种情况，我们使用了某一款组件库，但是组件库中有一些样式不符合我们的需求。这个时候我们需要对样式进行一些修改，但是我们为了避免自定义组件间的样式会产生干扰，一般会给script标签加上scoped属性。在这个时候我们如果要对组件库对样式进行更改，就需要使用深度样式 123::v-deep selector{ /* 样式内容 */} 但是在vue3中表示以后会废弃该用法，使用以下方法代替： 123:deep(selector){ /* 样式内容 */}","link":"/2021/11/23/%E8%AE%B0%E5%BD%95vue3%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"},{"title":"贰:Interceptor拦截器和Axios类","text":"接下来，我们应该看一下Axios类中究竟做了什么，到底是怎么发送请求的。因为Axios类中应用到了Interceptor，所以我们要先看一下拦截器是怎么实现的。 很遗憾，至于发送请求的详细内容需要到dispatchRequest方法和xhr适配器中才能看到了，在本章节Axios类中我们只能说到调用dispatchRequest方法这一步，所以发送请求的详细内容要留到下一章节来说了，先来看一下本章节的内容吧。 InterceptorManager先来看一下拦截器内容，源码位于lib/core/InterceptorManager.js。 构造函数构造函数的内容太简单了，直接放下边吧： 123function InterceptorManager() { this.handlers = [];} 就是维护了一个handlers数组，用来收集拦截器。 原型方法原型对象上有use，eject和forEach三个方法，其中最常用的就是use方法。 InterceptorManager.prototype.use 函数接收两个参数，分别是成功和失败的回调函数，最后函数会返回最后加入hadnlers中的拦截器的下标 1234567InterceptorManager.prototype.use = function use(fulfilled, rejected) { this.handlers.push({ fulfilled: fulfilled, rejected: rejected }); return this.handlers.length - 1;}; 至于fulfilled和rejected函数应该做哪些内容，放到后边再说，这里只知道拦截器有什么就好了。 函数的返回值是用来配合eject方法使用的。 InterceptorManager.prototype.eject eject方法接收一个下标，将handlers中对应下标的拦截器置为null。注意这里是置为null，而不是从数组中移除这个拦截器。 12345InterceptorManager.prototype.eject = function eject(id) { if (this.handlers[id]) { this.handlers[id] = null; }}; 我们在调用use方法后会得到拦截器的下标，可以使用这个下标通过eject方法来移除这个拦截器。所以在eject方法中是置为null，而不是移除元素，这样可以保证下标的准确性，不会因为调用eject方法导致拦截器的下标发生变化。 InterceptorManager.prototype.forEach 这个函数在Axios类中用到了，平常开发过程中我们一般是用不到这个函数的。 这个函数接收一个参数，这个参数也是一个函数，我们称之为fn。然后forEach函数内部会循环handlers中的所有拦截器，把每个拦截器作为参数传入fn执行。（这里会判断拦截器是否为null，因为我们移除拦截器会置为null） 1234567InterceptorManager.prototype.forEach = function forEach(fn) { utils.forEach(this.handlers, function forEachHandler(h) { if (h !== null) { fn(h); } });}; InterceptorManager源码贴一下拦截器源码： 1234567891011121314151617181920212223242526272829303132'use strict';var utils = require('./../utils');function InterceptorManager() { this.handlers = [];}InterceptorManager.prototype.use = function use(fulfilled, rejected) { this.handlers.push({ fulfilled: fulfilled, rejected: rejected }); return this.handlers.length - 1;};InterceptorManager.prototype.eject = function eject(id) { if (this.handlers[id]) { this.handlers[id] = null; }};InterceptorManager.prototype.forEach = function forEach(fn) { utils.forEach(this.handlers, function forEachHandler(h) { if (h !== null) { fn(h); } });};module.exports = InterceptorManager; Axios类看完了InterceptorManager，我们终于可以来看一下Axios类了。还是分为构造函数会原型对象方法来看。 构造函数Axios类的构造函数也是很简单的，接收一个配置项，然后生成一些默认属性。 1234567function Axios(instanceConfig) { this.defaults = instanceConfig; this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() };} 对于instanceConfig，不知道大家还能否记得第一章节也就是axios.js的内容，如果忘记了需要回顾一下哦。 在axios.js中我们通过new Axios创建实例，对于axios实例，这个instanceConfig就是defaults.js中的默认配置，而对于axios.create(config)创建的实例，这个instanceConfig是defaults.js和config合并后的配置内容。在构造函数中，我们把用于创建实例的配置项存储到this.defaults上。 Axios还维护有一个属性interceptors用来收集拦截器，我们知道拦截器构造函数的内部是维护了一个数组，所以这里Axios类中的interceptors对象的两个属性request和response，分别维护请求拦截器数组和响应拦截器数组。记住这里是维护了两个数组，后边还会说到他。 request方法Axios.prototype.request是Axios类的一个核心方法了，在lib/axios.js中的createInstance方法中有这么一行代码var instance = bind(Axios.prototype.request, context);，关于这一行代码的内容我们说了挺多的，它的存在就是为了让我们方便的调用这个request方法 我们在调用request方法的时候可以传入一个参数，比如axios({method:'post',url:'/url'})这种。但是除了这种方法外request还有一种调用方式入axios.request('/url', config)。 先来看一下reuqest方法中对于config的处理： 12345678910111213Axios.prototype.request = function request(config) { // 如果config是字符串，就是我们说的axios.request('/url', config)这种用法，那么这个字符串请求的url，后边传入的config才是额外配置，当然config不是必传的 // 所以在这里，如果config是字符串我们需要对传入的config进行合并 if (typeof config === 'string') { config = utils.merge({ url: arguments[0] }, arguments[1]); } // 这里很有意思，是对下边的配置项进行合并。我们前边说过merge方法中传入的参数如果有同名属性，后边的会覆盖掉前边的，所以可以得知同名属性优先级最高的是参数config,然后是this.defaults,再之后是方法{method:'get'}，优先级最低的是默认配置，我们前边说过默认配置的内容。 config = utils.merge(defaults, { method: 'get' }, this.defaults, config); // 请求方法转为小写 config.method = config.method.toLowerCase();} 对于config的处理我们需要注意两点，一是config为字符串的情况。而是对所有配置项对合并，注意配置项对优先级。参数config -&gt; this.defaults -&gt; {method:’get’} -&gt; defaults 再看一下request方法中剩下的内容，我们一点点来说 123456789101112var chain = [dispatchRequest, undefined];var promise = Promise.resolve(config);this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) { chain.unshift(interceptor.fulfilled, interceptor.rejected);});this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) { chain.push(interceptor.fulfilled, interceptor.rejected);});while (chain.length) { promise = promise.then(chain.shift(), chain.shift());}return promise; 先说一下chain这个数组，这里维护的都是成对的，比如请求拦截器的成功回调和失败回调、响应拦截器的成功回调和失败回调。而dispatchRequest这个发送请求的方法比较特殊，所以加入了一个undefined与其组成一对。看到后边的调用方式就会理解这里的。 1var chain = [dispatchRequest, undefined]; 定义了一个变量promise，赋值为Promise.resolve(config)。为什么传入config？，想一下我们的请求拦截器接收参数config并要求返回config是不是突然知道为什么传入config了，这里Promise.resolve(config)可以让我们的请求拦截器接收到config，而请求拦截器返回到config可以给后边的请求拦截器和dispatchRequest使用。 1var promise = Promise.resolve(config); 接下来看一下请求拦截器的部分，我们收集请求拦截器肯定是每调用一次Interceptor.use就会往this.interceptors.request中push一个对象，其中有fulfilled和rejected方法。然后在这里我们循环存储请求拦截器的数组并依次将其fulfilled和rejected方法添加到chain的前边，所以最后一个定义的请求拦截器应该是chain的第一对元素哦。 123this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) { chain.unshift(interceptor.fulfilled, interceptor.rejected);}); 响应拦截器差不多，只是往后追加了，所以最后一个定义的响应拦截器是chain的最后一对元素。 123this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) { chain.push(interceptor.fulfilled, interceptor.rejected);}); 然后就是依次调用chain中的内容并将最终结果返回啦，返回结果也是一个Promise。 在调用过程中传入promise.then的依次是 每一组请求拦截器的成功和失败回调 dispathRequest和undefined 每一组响应拦截器的成功和失败回调 1234while (chain.length) { promise = promise.then(chain.shift(), chain.shift());}return promise; 在这里我们需要注意的是，请求拦截器是先定义的后执行，而响应拦截器是先定义的先执行。 request方法完整源码如下： 123456789101112131415161718192021Axios.prototype.request = function request(config) { if (typeof config === 'string') { config = utils.merge({ url: arguments[0] }, arguments[1]); } config = utils.merge(defaults, { method: 'get' }, this.defaults, config); config.method = config.method.toLowerCase(); var chain = [dispatchRequest, undefined]; var promise = Promise.resolve(config); this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) { chain.unshift(interceptor.fulfilled, interceptor.rejected); }); this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) { chain.push(interceptor.fulfilled, interceptor.rejected); }); while (chain.length) { promise = promise.then(chain.shift(), chain.shift()); } return promise;}; 其他扩展方法我们都知道axios还给我们提供了指定请求方法的请求方式，比如axios.get()或者axios.post()等，其实这些方法都是基于Axios.prototype.request来实现的。 1234567891011121314151617181920utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) { /*eslint func-names:0*/ Axios.prototype[method] = function (url, config) { return this.request(utils.merge(config || {}, { method: method, url: url })); };});utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) { /*eslint func-names:0*/ Axios.prototype[method] = function (url, data, config) { return this.request(utils.merge(config || {}, { method: method, url: url, data: data })); };}); 思路一致，如果调用get等方法等时候传入了config就将config传入request方法，但是请求方法、url这些不从config中取，因为在调用的时候已经制定了请求方法且传入了请求url。 几个方法的实现是一样的，只是post/put/patch请求可以传递data 贴一下Axios类的源码内容吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566'use strict';var defaults = require('./../defaults');var utils = require('./../utils');var InterceptorManager = require('./InterceptorManager');var dispatchRequest = require('./dispatchRequest');function Axios(instanceConfig) { this.defaults = instanceConfig; this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() };}Axios.prototype.request = function request(config) { if (typeof config === 'string') { config = utils.merge({ url: arguments[0] }, arguments[1]); } config = utils.merge(defaults, { method: 'get' }, this.defaults, config); config.method = config.method.toLowerCase(); var chain = [dispatchRequest, undefined]; var promise = Promise.resolve(config); this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) { chain.unshift(interceptor.fulfilled, interceptor.rejected); }); this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) { chain.push(interceptor.fulfilled, interceptor.rejected); }); while (chain.length) { promise = promise.then(chain.shift(), chain.shift()); } return promise;};utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) { Axios.prototype[method] = function (url, config) { return this.request(utils.merge(config || {}, { method: method, url: url })); };});utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) { Axios.prototype[method] = function (url, data, config) { return this.request(utils.merge(config || {}, { method: method, url: url, data: data })); };});module.exports = Axios; 到现在，我们已经知道整个axios的执行流程，怎么处理配置项，请求拦截和响应拦截，返回最终的promise等这一个流程已经串下来了，现在就差了关键一步，dispatchRequest中关于发送请求的详细内容是怎么实现的，毕竟axios就是用来发送请求的，这里才是真正的核心内容。","link":"/2022/10/12/%E8%B4%B0-Interceptor%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8CAxios%E7%B1%BB/"},{"title":"零:axios目录结构与入口文件","text":"本系列内容基于axios0.18.0版本，只对核心内容进行梳理，不会具体到每一个方法细节。至于一些辅助方法等内容，只会在碰到的时候说下这个方法做了什么，不会单独去看辅助方法。新版本的axios对于一些部分进行了修改，但大致是一样的。 axios的适配器adapter分别对xhr和http做了处理，我们只关注用于浏览器端的xhr，对应用于node的http内容不做考虑。 目录结构通过webpack.config.js文件发现项目的入口文件是跟目录下的index.js文件 而index.js文件仅仅是引入了lib/axios.js文件并导出，所以我们对于axios源码内容的分析就是对于lib目录下的文件的分析，对于其他的示例、测试用例等不关注。 12// index.jsmodule.exports = require('./lib/axios'); 目录结构如下： 1234567891011121314151617181920lib // 源码目录|---- adapters // 适配器目录| |---- xhr.js // 浏览器xhr| |---- http.js // node环境http|---- cancel // 取消请求相关功能目录| |---- Cancel.js| |---- CancelToken.js| |---- isCancel.js|---- core // 核心代码目录| |---- Axios.js // Axios类，用于创建axios实例| |---- createError.js // 配合enhanceError返回错误| |---- dispatchRequest.js // 封装发送请求的方法| |---- enhanceError.js| |---- InterceptorManager.js // 拦截器| |---- settle.js| |---- transformData.js // 数据转换|---- helpers // 一些辅助函数|---- axios.js // 真正的入口文件|---- defaults.js // 默认配置|---- utils.js // 一些公共方法 入口文件axios与axios.create前边我们已经分析过了，跟目录下的index.js只是导入了lib/axios.js的导出内容并向外导出，所以在这里我们开始看一下lib/axios.js文件： 我们先摘两行代码出来看一下，至于createInstance方法是什么暂时先不需要过多关注，它只是创建了一个axios实例然后做了一些继承操作后将这个实例返回出来 1234567// lib/axios.js// ....var axios = createInstance(defaults);// ....module.exports = axios;// 用于满足在typescript中使用默认导入module.exports.default = axios; 我们可以看到lib/axios.js文件中最后导出了创建的axios实例，而根目录下的index.js文件导入了这个实例并向外导出，所以我们在项目中通过import导入的就是这个axios实例啦。 我们知道axios实例可以通过axios.create()方法创建新的实例，这个是怎么实现的呢？ 1234axios.create = function create(instanceConfig) { // utils.merge可以合并配置项 return createInstance(utils.merge(defaults, instanceConfig));}; 很明显，axios.create内部是调用了createInstance方法来实现的，而且我们又知道axios也是通过createInstance方法创建的，那是不是可以认为axios和axios.create()创建的实例是一样的呢？ 其实只看这些代码的话，可以说他们是基本一样的，只是axios.create可以传入一些额外配置项。 但是看后边的代码就会发现还是有很大不一样的，不需要关注这些方法用来做什么，只看懂这个流程即可： 123456789101112axios.create = function create(instanceConfig) { return createInstance(utils.merge(defaults, instanceConfig));};// Expose Cancel &amp; CancelTokenaxios.Cancel = require('./cancel/Cancel');axios.CancelToken = require('./cancel/CancelToken');axios.isCancel = require('./cancel/isCancel');// Expose all/spreadaxios.all = function all(promises) { return Promise.all(promises);};axios.spread = require('./helpers/spread'); 可以看到，像是Cancel、CancelToken等方法是在axios创建之后手动添加到axios身上的，而不是在createInstance中添加到axios上的，那么也就是说，Cancel、CancelToken这些方法可以通过axios调用，但是通过axios.create创建的实例是不能调用这些方法的。 axios.all和axios.spread我们现在回过头看一下这几个方法，Cancel、CancelToken和isCancel这几个用于取消请求的方法我们放到后边看这几个文件的时候再说，all方法其实就是用了Promise.all方法，没什么太多好说的，直接看spread方法吧，这个方法是个高阶函数，而且还让我感觉有那么点儿函数柯里化的意思，主要是用来打散数组参数类似于apply的效果。 all和spread方法在平常的应用场景中使用不那么多，我们来看一下。 spread方法实现如下： 12345module.exports = function spread(callback) { return function wrap(arr) { return callback.apply(null, arr); };}; 假设我们有一个函数f接受三个参数 1function f (x, y, z){} 我们希望传递一个有三个元素的数组作为参数，可以这么做 12var args = [1, 2, 3]f.apply(null, args) apply方法不仅可以改变this指向，还可以打散数组参数传入。 那么现在我们有了spread方法怎么实现这个功能呢？ 1spread(f)(args) 看到这里，大家是不是不太清楚spread方法的意义何在，其实spread与all方法配合使用有不错的效果。 比如我们需要同时请求多个接口且需要等待多个接口都返回了才能进行下一步操作，这时如果同步进行会影响运行效率，所以可以使用这两个方法完成高并发请求，比如： 12345678910111213// 两个axios请求function fetch1(){ return axios()}function fetch2(){ return axios()}// 使用axios.all等两个请求都结束才向后运行，返回一个数组axios.all([fetch1(), fetch2()]) .then(axios.spread(function(res1, res2){ console.log(res1) // fetch1的结果 console.log(res2) // fetch2的结果})) 因为axios.all返回的是一个数组，是所有请求的结果，我们需要手动从数组中取值，这个情况下使用axios.spread打散结果数组取值会更加方便。 总结, axios.all和axios.spread方法适用于并发请求。 createInstance现在整个lib/axios.js文件就剩下一个createInstance方法没有去看了，我们就看看这里究竟做了些什么。 这里用到了Axios类，我们会在下一节去详细介绍Axios类的内容，这里只会把必须要讲到的大概说一下能理清createInstance方法的功能即可。 先看一下createInstance方法做了什么： 1234567function createInstance(defaultConfig) { var context = new Axios(defaultConfig); var instance = bind(Axios.prototype.request, context); utils.extend(instance, Axios.prototype, context); utils.extend(instance, context); return instance;} 源码对这个函数的描述是Create an instance of Axios 我们根据最开始说过的var axios = createInstance(defaults);可以知道这个实例是使用默认配置创建的。函数内部第一行是通过new创建了一个实例context，最后一行是把实例返回出去，这两行不过多解释，我们专注于函数内的第二行、第三行和第四行。 var instance = bind(Axios.prototype.request, context); 先说Axios.prototype.request，它就是我们用来发请求的方法，这一行代码就是为了实现我们使用axios({method:'get',url:''})这样来发送请求，其实调用的就是Axios原型对象上的这个request方法，大家这么说应该能知道这个request方法大概是什么，其具体实现不在这里展开讲，留到下一节再说。 这里主要讲bind方法是怎么实现上边说的使用方式的。看到bind方法我们应该会想到js中用于永久改变this指向的bind方法，当然这里的bind是axios中封装过的并不是我们想的那个，其内部用到的是js中的apply方法，很意外吧。 先来看一下这个bind方法的源码 123456789function bind(fn, thisArg) { return function wrap() { var args = new Array(arguments.length); for (var i = 0; i &lt; args.length; i++) { args[i] = arguments[i]; } return fn.apply(thisArg, args); };}; 看我们传入的参数，fn就是那个request方法，而thisArg就是我们通过new创建的Axios实例context。执行bind之后我们得到的instance就是这个wrap函数。在wrap函数内部先是处理了一下参数，因为arguments是一个类数组对象，并不是一个真正的数组，然后通过apply调用将this指向我们的实例context并传入参数。 所以，我们也可以对这行代码这么理解(只是这么理解，这是不对的)： 1instance(...args) = Axios.prototype.request.apply(context, arguments) utils.extend(instance, Axios.prototype, context); 第三行和第四行都用到了extend这个方法，这个方法比较复杂，内部还用到了封装过的bind方法和forEach方法，其中的bind已经说过了，forEach还是用来循环的，接收两个参数，第一个是用来循环的内容，第二个是回调函数，把循环内容中每一个元素的值，键，元素本身传入回调函数执行。这里不做详细解释，后边把forEach的源码贴出来，感兴趣自己看一下。 我们先看下extend这个方法的内容 12345678910function extend(a, b, thisArg) { forEach(b, function assignValue(val, key) { if (thisArg &amp;&amp; typeof val === 'function') { a[key] = bind(val, thisArg); } else { a[key] = val; } }); return a;} 第三行就是传递了第三个参数thisArg的情况，这行代码的作用就是把Axios.prototype的内容复制到instance上且方法的this指向context，所以可以说第三行是用来把原型对象上的内容复制到instance上 utils.extend(instance, context); 第四行这样来看也就比较简单了，是把context的内容复制到instance身上，所以可以说第四行是把构造函数上的内容复制到instance上 贴一下forEach源码： 1234567891011121314151617181920function forEach(obj, fn) { if (obj === null || typeof obj === 'undefined') { return; } if (typeof obj !== 'object') { obj = [obj]; } if (isArray(obj)) { for (var i = 0, l = obj.length; i &lt; l; i++) { fn.call(null, obj[i], i, obj); } } else { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { fn.call(null, obj[key], key, obj); } } }} axios.js总览现在整个入口文件就只剩一行代码没看了,如下： 1axios.Axios = Axios; 这行代码的意义就是暴露Axios类来允许类继承，不过多解释。 这样我们把整个入口文件就说完了，把源码贴出来看一下吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546'use strict';// 引入var utils = require('./utils');var bind = require('./helpers/bind');var Axios = require('./core/Axios');var defaults = require('./defaults');// 创建axios实例function createInstance(defaultConfig) { var context = new Axios(defaultConfig); // 可以直接把实例当作函数来调用发送请求 var instance = bind(Axios.prototype.request, context); // Axios原型内容拷贝 utils.extend(instance, Axios.prototype, context); // Axios构造函数内容拷贝 utils.extend(instance, context); return instance;}// 创建实例var axios = createInstance(defaults);// 暴露Axios类axios.Axios = Axios;// create工厂函数axios.create = function create(instanceConfig) { return createInstance(utils.merge(defaults, instanceConfig));};// 取消请求的相关内容axios.Cancel = require('./cancel/Cancel');axios.CancelToken = require('./cancel/CancelToken');axios.isCancel = require('./cancel/isCancel');// 用于处理并发请求的方法axios.all = function all(promises) { return Promise.all(promises);};axios.spread = require('./helpers/spread');// 导出module.exports = axios;// 适配typescriptmodule.exports.default = axios; 那么对于入口文件的内容就说到这里了。","link":"/2022/10/08/%E9%9B%B6-axios%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%B8%8E%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6/"},{"title":"页面关闭时上传监控数据","text":"最近有个需求，需要在页面关闭时请求后台发送一些监控数据，真是想的头大。最开始想到了ajax发送同步请求，但是效果不好而且在新版本chrome已经被废弃，无奈网上搜寻，找到了fetch实现的解决方案，算是解决了掉头发的困扰。 AJAX发送同步请求先给出代码： 1234567891011121314151617const data = JSON.stringify({ // 监控数据});var xhr = new XMLHttpRequest();// 第三个参数false，表示当前请求是同步xhr.open('post', '后台地址', false);// 发送json数据xhr.setRequestHeader('content-type', 'application/json');xhr.onreadystatechange = function() { // 发送成功后，页面已销毁，所以这里执行不了}xhr.send(data); 同步请求后阻止代码的执行，这会导致用户操作屏幕无响应，体验实在太差了。 而且由于发送成功后页面已经销毁，不能读取响应值。 而且在新版的chrome(版本高于80)已经不支持了。公告如下： Chrome now disallows synchronous calls to XMLHTTPRequest() during page dismissal when the page is being navigated away from or is closed by the user. This applies to beforeunload, unload, pagehide, and visibilitychange. Fetchkeepalive的作用： 当用户离开网页时,脚本向服务器提交一些用户行为的统计信息.如果keepalive是false,数据无法发送,因为浏览器已经把页面卸载了 标记keepalive的fetch请求允许在页面卸载后执行。 1234567891011121314const url = '后端接口';const data = JSON.stringify({ // 监控数据 }); fetch(url, { method: 'POST', body: data, headers: { 'Content-Type': 'application/json' }, // keepalive为true，允许fetch请求在页面卸载后执行。 keepalive: true,});","link":"/2022/06/24/%E9%A1%B5%E9%9D%A2%E5%85%B3%E9%97%AD%E6%97%B6%E4%B8%8A%E4%BC%A0%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE/"},{"title":"通过html2canvas将dom节点到出为图片","text":"通过html2canvas将dom节点内容导出为图片的实现方法 项目使用的vue2技术栈，所以也以vue2来做演示 123456789101112131415161718192021222324252627282930313233343536373839404142import html2canvas from 'html2canvas'// 下面是methods内容// 导出图片的触发事件async exportImage(){ // 拿到要导出的dom节点 let container = this.$refs.dashContainer // 返回base64编码的文件 let imgData = await this.convertToImage(container) // 通过a标签下载图片 const a = document.createElement('a'); a.href = imgData; a.setAttribute('download', 'chart-download'); a.click();},// 接收dom节点和配置项convertToImage(container, options = {}){ // 设置放大倍数 const scale = window.devicePixelRatio; // 拿到节点原始宽高 const _width = container.offsetWidth; const _height = container.offsetHeight; // 如果传入了宽高则以传入的为主，否则以节点的宽高为主 let { width, height } = options; width = width || _width; height = height || _height; // html2canvas配置项 const ops = { scale, // width, // height, useCORS: true, allowTaint: false, ...options }; return html2canvas(container, ops).then(canvas =&gt; { // 返回图片的二进制数据 return canvas.toDataURL(&quot;image/png&quot;); });},","link":"/2022/03/29/%E9%80%9A%E8%BF%87html2canvas%E5%B0%86dom%E8%8A%82%E7%82%B9%E5%88%B0%E5%87%BA%E4%B8%BA%E5%9B%BE%E7%89%87/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包问题","slug":"背包问题","link":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"Proxy","slug":"Proxy","link":"/tags/Proxy/"},{"name":"NodeJs","slug":"NodeJs","link":"/tags/NodeJs/"},{"name":"EggJs","slug":"EggJs","link":"/tags/EggJs/"},{"name":"Dart","slug":"Dart","link":"/tags/Dart/"},{"name":"Reflect","slug":"Reflect","link":"/tags/Reflect/"},{"name":"EggJss","slug":"EggJss","link":"/tags/EggJss/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"ElementUI","slug":"ElementUI","link":"/tags/ElementUI/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Gin","slug":"Gin","link":"/tags/Gin/"},{"name":"HarmonyOS","slug":"HarmonyOS","link":"/tags/HarmonyOS/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"GetX","slug":"GetX","link":"/tags/GetX/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"二叉搜索树","slug":"二叉搜索树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"前缀树","slug":"前缀树","link":"/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"},{"name":"哈希表","slug":"哈希表","link":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"哈希集合","slug":"哈希集合","link":"/tags/%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"图","slug":"图","link":"/tags/%E5%9B%BE/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"NestJs","slug":"NestJs","link":"/tags/NestJs/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"Mongodb","slug":"Mongodb","link":"/tags/Mongodb/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"Scss","slug":"Scss","link":"/tags/Scss/"},{"name":"Sass","slug":"Sass","link":"/tags/Sass/"},{"name":"log4js","slug":"log4js","link":"/tags/log4js/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"装饰器","slug":"装饰器","link":"/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"name":"Decorator","slug":"Decorator","link":"/tags/Decorator/"},{"name":"Vue-Router","slug":"Vue-Router","link":"/tags/Vue-Router/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"pinia","slug":"pinia","link":"/tags/pinia/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"mustache","slug":"mustache","link":"/tags/mustache/"},{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"},{"name":"EventEmitter","slug":"EventEmitter","link":"/tags/EventEmitter/"},{"name":"cron表达式","slug":"cron表达式","link":"/tags/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"yarn","slug":"yarn","link":"/tags/yarn/"},{"name":"monorepo","slug":"monorepo","link":"/tags/monorepo/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"lunarvim","slug":"lunarvim","link":"/tags/lunarvim/"},{"name":"neovim","slug":"neovim","link":"/tags/neovim/"},{"name":"文件上传","slug":"文件上传","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"cli","slug":"cli","link":"/tags/cli/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"IndexedDB","slug":"IndexedDB","link":"/tags/IndexedDB/"},{"name":"Web Storage","slug":"Web-Storage","link":"/tags/Web-Storage/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Javascript","slug":"前端/Javascript","link":"/categories/%E5%89%8D%E7%AB%AF/Javascript/"},{"name":"CSS","slug":"前端/CSS","link":"/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"NodeJs","slug":"NodeJs","link":"/categories/NodeJs/"},{"name":"跨端开发","slug":"跨端开发","link":"/categories/%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"ElementUI组件库","slug":"前端/ElementUI组件库","link":"/categories/%E5%89%8D%E7%AB%AF/ElementUI%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"name":"Go语言","slug":"Go语言","link":"/categories/Go%E8%AF%AD%E8%A8%80/"},{"name":"鸿蒙HarmonyOS","slug":"鸿蒙HarmonyOS","link":"/categories/%E9%B8%BF%E8%92%99HarmonyOS/"},{"name":"EggJs","slug":"NodeJs/EggJs","link":"/categories/NodeJs/EggJs/"},{"name":"LeetCode75学习计划","slug":"数据结构与算法/LeetCode75学习计划","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode75%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"},{"name":"Flutter","slug":"跨端开发/Flutter","link":"/categories/%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91/Flutter/"},{"name":"NestJs学习日记","slug":"NodeJs/NestJs学习日记","link":"/categories/NodeJs/NestJs%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"Scss","slug":"前端/Scss","link":"/categories/%E5%89%8D%E7%AB%AF/Scss/"},{"name":"TypeScript","slug":"前端/TypeScript","link":"/categories/%E5%89%8D%E7%AB%AF/TypeScript/"},{"name":"Vue","slug":"前端/Vue","link":"/categories/%E5%89%8D%E7%AB%AF/Vue/"},{"name":"源码学习","slug":"前端/源码学习","link":"/categories/%E5%89%8D%E7%AB%AF/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"name":"NextJs全栈开发","slug":"NextJs全栈开发","link":"/categories/NextJs%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/"},{"name":"axios0.18.0源码学习","slug":"前端/axios0-18-0源码学习","link":"/categories/%E5%89%8D%E7%AB%AF/axios0-18-0%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"name":"未分类内容","slug":"未分类内容","link":"/categories/%E6%9C%AA%E5%88%86%E7%B1%BB%E5%86%85%E5%AE%B9/"},{"name":"Yarn","slug":"前端/Yarn","link":"/categories/%E5%89%8D%E7%AB%AF/Yarn/"},{"name":"canvas","slug":"前端/canvas","link":"/categories/%E5%89%8D%E7%AB%AF/canvas/"}]}